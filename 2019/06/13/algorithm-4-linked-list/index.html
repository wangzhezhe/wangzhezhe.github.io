<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Algorithm(4) linked list | AverageMind</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="这一块主要记录一下链表相关的一些常考题目以及解题思路。">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithm(4) linked list">
<meta property="og:url" content="http://yoursite.com/2019/06/13/algorithm-4-linked-list/index.html">
<meta property="og:site_name" content="AverageMind">
<meta property="og:description" content="这一块主要记录一下链表相关的一些常考题目以及解题思路。">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-06-14T01:40:46.163Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Algorithm(4) linked list">
<meta name="twitter:description" content="这一块主要记录一下链表相关的一些常考题目以及解题思路。">
  
    <link rel="alternate" href="/atom.xml" title="AverageMind" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-165927341-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AverageMind</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Writing is nature&#39;s way of letting you know how sloppy your thinking is.</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-algorithm-4-linked-list" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/13/algorithm-4-linked-list/" class="article-date">
  <time datetime="2019-06-14T01:13:50.000Z" itemprop="datePublished">2019-06-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Algorithm(4) linked list
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>这一块主要记录一下链表相关的一些常考题目以及解题思路。</p>
<a id="more"></a>
<h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p>这一块的难点主要是考察代码的实现能力，链表相关的题目在思路上比较简单，链表上每一个元素都存储空间都是临时分配的，每一个节点在存储空间的物理位置上是不一定连续的。链表的问题，在实现的时候，最优解往往不是使用额外的数据结构，这往往需要更多的技巧（最基本的比如链表的翻转）</p>
<p><strong>在分类上</strong></p>
<ul>
<li>按照链表链接的方向，可以分为单链表以及双链表。对于单链表，每个节点只能通过其next指针指向下一个节点，双链表的每个节点，除了next指针之外，还有一个previous指针，可以指向它的前一个节点，通过当前节点，既可以找到前一个节点，也可以找到后一个节点。</li>
<li>按照有环以及无环分类，又可以分成普通链表（无环）以及循环链表（有环），循环链表是首尾相接的链表，循环链表的最后一个元素的next指针会指向其第一个元素，循环链表的第一个元素的previous指针会指向其最后一个元素。</li>
</ul>
<p><strong>实现上的注意问题</strong></p>
<ul>
<li>链表调整函数的返回值类型，根据要求，往往是节点的类型</li>
<li>处理链表的过程中，需要采用画图的方式，来使得整个逻辑尽量清晰</li>
<li>边界条件的处理要严格（头结点 尾节点 空节点）</li>
</ul>
<p><strong>链表插入和删除的注意事项</strong></p>
<ul>
<li>特殊处理链表为空，或者链表长度为1的情况</li>
<li>注意插入和删除的时候，要找到插入位置和删除位置的前一个节点，在头尾部进行插入和删除操作的时候需要特殊考虑</li>
<li>双链表的时候还需要考虑previous指针的情况</li>
</ul>
<p><strong>单链表翻转的操作（需要同时记录 previous节点 now节点 next节点 三个位置)</strong></p>
<ul>
<li>用临时变量记录下now节点的下一个节点的位置</li>
<li>now节点的next指针指向前一个节点 now节点变为新的head节点</li>
<li>循环以上操作，最后返回最新的head节点</li>
</ul>
<p><strong>实现上的注意事项</strong></p>
<p>listnode类的题目，总是做起来不爽，因为要自己定义结构体还有组链表什么的。其实还是有点不熟悉。</p>
<p>自己定义结构体，注意初始化的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct ListNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	ListNode *next;</span><br><span class="line">	ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">&#125;ListNode;</span><br></pre></td></tr></table></figure>
<p>还有就是初始化的时候 申请空间 给初始的空间赋值这些操作<br><code>ListNode *h=(ListNode*)malloc(sizeof(ListNode)); h-&gt;next=NULL;</code>（事实上 这里的初始化赋值的操作完全可以根据链表的定义来进行，在定义的时候，就把初始化的操作写清楚了）</p>
<p>注意根据题目的要求，看链表在定义的时候究竟需不需要包含头结点，一般头结点就放在那里不动了，之后设置一个temp指针，来不断向后移动，用于执行具体的操作。</p>
<p>关于退出条件以及一些细节，在进行h-&gt;next这种操作之前，一定要判断是否h指针是否为NULL，要不然总会在莫名奇妙的地方出现问题。</p>
<p><strong>一些常用的tips</strong></p>
<ul>
<li>这块的操作确比较繁琐，在初始话的时候最好使用构造函数的形式head=new ListNode(val);以免造成忘记初始化为NULL</li>
<li>head指针太关键了，所有操作也都是从head指针开始的，不管是循环的还是非循环的，都要保存一个head指针，根据题目的实际情况判断头结点设置为空节点，还是第一个元素所在位置的节点。（比如后面的删除值为val的节点的题目）</li>
<li>注意保存lastNode，即是当前节点的上一个节点，许多操作都是lastNode和currentNode结合起来进行的</li>
<li>插入，删除的时候，改变指针也都是先改变后面的再改变前面的</li>
</ul>
<p><strong>链表遍历的注意事项</strong></p>
<p>为何链表的题目容易做错，既然思路不难，关键就在规范性上，在细节上面。比如遍历链表的操作，模式很简单，但是总是忘记tail指针，直接每次去拿头节点遍历，然后发现，要保存head指针，之后又调，总之，大多数的时候都是应为细节注意不到位带来的错误，还有比如链表节点的初始化等等。在这里规范一下遍历的思路。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//给定了链表的头指针 head</span><br><span class="line">//这里一定要注意 遍历的时候是用另外一个tail指针进行 头节点指针保持不变</span><br><span class="line">ListNode *tail=head;</span><br><span class="line">while(tail!=NULL)&#123;</span><br><span class="line">	//do sth (create or some operations) for tail node </span><br><span class="line">	tail=tail-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际实现的时候，有好多题目会借用到两指针的相关思路</p>
<h3 id="有序的环形单链表中插入新的元素"><a href="#有序的环形单链表中插入新的元素" class="headerlink" title="有序的环形单链表中插入新的元素"></a>有序的环形单链表中插入新的元素</h3><p>用两个index保存有当前元素和下一个元素的位置，开始的时候，一个在头结点，一个在第一个位置，之后两个指针同时向后移动，要是发现了合适的位置（insert值比前一个大 比后一个小）就插入元素。要是没有发现，就将最终的值插入到头结点和尾节点之间，此时插入的元素可能是所有元素里面最小的，也有可能是所有元素里面最大的。</p>
<p>如果插入元素是所有里面最小的，还是返回当前这个元素的位置，如果是所有元素里面最大的，返回原来头结点的位置。</p>
<p>这个题目在做的时候，总是报您的程序打印了太多的内容，暂时不知到错在哪里(估计还是哪里有死循环？？？)，以下是源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode</span><br><span class="line">&#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class InsertValue</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* insert(vector&lt;int&gt; A, vector&lt;int&gt; nxt, int val)</span><br><span class="line">    &#123;</span><br><span class="line">        // write code here</span><br><span class="line">        int i,len,num;</span><br><span class="line">        len=A.size();</span><br><span class="line">        int nxtIndex=0;</span><br><span class="line">        int currVlue;</span><br><span class="line">        ListNode *lastNode=NULL;</span><br><span class="line">        ListNode *currNode=NULL;</span><br><span class="line">        ListNode *head=NULL;</span><br><span class="line">        if (len==0)</span><br><span class="line">        &#123;</span><br><span class="line">            head=new ListNode(val);</span><br><span class="line">            head-&gt;next=head;</span><br><span class="line">            return head;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        //lastNode could be the head node</span><br><span class="line">        head=new ListNode(-1);</span><br><span class="line">        lastNode=head;</span><br><span class="line">        nxtIndex=0;</span><br><span class="line">        num=0;</span><br><span class="line">        while(num&lt;len)</span><br><span class="line">        &#123;</span><br><span class="line">            currVlue=A[nxtIndex];</span><br><span class="line">            currNode=new ListNode(currVlue);</span><br><span class="line">            lastNode-&gt;next=currNode;</span><br><span class="line">            lastNode=currNode;</span><br><span class="line">            num++;</span><br><span class="line">            nxtIndex=nxt[nxtIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        //could be a circle</span><br><span class="line">        if(nxtIndex==0)</span><br><span class="line">        &#123;</span><br><span class="line">            currNode-&gt;next=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        //debug</span><br><span class="line">        ListNode *temp;</span><br><span class="line">        temp=head;</span><br><span class="line">        for(i=0; i&lt;num+num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot; %d&quot;,temp-&gt;val);</span><br><span class="line">            temp=temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        putchar(&apos;\n&apos;);</span><br><span class="line">        //debugok</span><br><span class="line">        lastNode=head-&gt;next;</span><br><span class="line">        currNode=head-&gt;next-&gt;next;</span><br><span class="line">        bool ifInsert=false;</span><br><span class="line">        while(true)</span><br><span class="line">        &#123;</span><br><span class="line">            if (currNode-&gt;next==NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //problem here</span><br><span class="line">            //same value but different address??</span><br><span class="line">            if (currNode-&gt;next==head-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if((lastNode-&gt;val&lt;=val)&amp;&amp;(currNode-&gt;val&gt;=val))</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *insertNode=new ListNode(val);</span><br><span class="line">                lastNode-&gt;next=insertNode;</span><br><span class="line">                insertNode-&gt;next=currNode;</span><br><span class="line">                ifInsert=true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            lastNode=lastNode-&gt;next;</span><br><span class="line">            currNode=currNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ifInsert)</span><br><span class="line">        &#123;</span><br><span class="line">            return head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(val&gt;currNode-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *insertNode=new ListNode(val);</span><br><span class="line">            insertNode-&gt;next=currNode-&gt;next;</span><br><span class="line">            currNode-&gt;next=insertNode;</span><br><span class="line">            return head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *insertNode=new ListNode(val);</span><br><span class="line">            insertNode-&gt;next=head-&gt;next;</span><br><span class="line">            head-&gt;next=insertNode;</span><br><span class="line">            if(currNode-&gt;next!=NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                currNode-&gt;next=insertNode;</span><br><span class="line">            &#125;</span><br><span class="line">            return head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int A[10]= &#123;1,3,4,5,7&#125;;</span><br><span class="line">    int nxt[10]= &#123;1,2,3,4,0&#125;;</span><br><span class="line">    vector&lt;int&gt; va;</span><br><span class="line">    vector&lt;int&gt; vnxt;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0; i&lt;5; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        va.push_back(A[i]);</span><br><span class="line">        vnxt.push_back(nxt[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    InsertValue iv=InsertValue();</span><br><span class="line">    //debug</span><br><span class="line">    ListNode *temp;</span><br><span class="line">    ListNode *head;</span><br><span class="line">    head=iv.insert(va,vnxt,0);</span><br><span class="line">    int num=5;</span><br><span class="line">    temp=head;</span><br><span class="line">    for(i=0; i&lt;num+num+num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot; %d&quot;,temp-&gt;val);</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">        if (temp==head)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //debugok</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除链表中的节点-简单但是不容易想到-有种跳跃思维在里面"><a href="#删除链表中的节点-简单但是不容易想到-有种跳跃思维在里面" class="headerlink" title="删除链表中的节点(简单但是不容易想到 有种跳跃思维在里面)"></a>删除链表中的节点(简单但是不容易想到 有种跳跃思维在里面)</h3><p>给定一个链表中的节点node，但不给定整个链表的头结点，如何在链表中删除node?<br>只有一些简单的替代思路，暂时还没有更好的办法。</p>
<p>替代思路:<br>如果是双链表的情况，会比较容易处理，直接根据当前节点的preious以及next指针找到前一个元素以及后一个元素，之后把这两个元素的指针进行对应的调整，可以删除掉当前元素。</p>
<p>如果是单链表的情况，比如 1-&gt;2-&gt;3 这种情况，比如要删除值为2的节点，此时可以用节点3的值覆盖掉节点2之后把节点3删除，这仅仅是逻辑上的删除，不是真正意义上的删除，因为这种操作是通过值拷贝来进行的。</p>
<p>这种操作的问题是，无法删除最后一个节点，比如无法删除3号位置的节点。而且在实际工程中，每个节点所代表的意义并不相同，比如每个节点如果代表一个一个的服务器，这种copy可能无法把全部的依赖都copy过去，比如节点3的环境可能无法完全在节点2上重现，这个时候，把节点3删除了会带来未知问题。</p>
<p>代码实际上比较trick，仅仅是一种模拟的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Remove &#123;</span><br><span class="line">public:</span><br><span class="line">    bool removeNode(ListNode* pNode) &#123;</span><br><span class="line">        // write code here</span><br><span class="line">        if(pNode-&gt;next==NULL)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode-&gt;val=pNode-&gt;next-&gt;val;</span><br><span class="line">        pNode-&gt;next=pNode-&gt;next-&gt;next;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="调整链表元素的位置（partition）"><a href="#调整链表元素的位置（partition）" class="headerlink" title="调整链表元素的位置（partition）"></a>调整链表元素的位置（partition）</h3><p>给定一个链表的头结点head，再给定一个数字num，请把链表调整成节点值小于num的节点都放在链表的左边，值等于num的节点都放在链表的中间，值大于num的节点都放在链表的右边。（虽然比较简单 还是一下想不到 多少有点豁然开朗的感觉）</p>
<p>考察的重点代码实现不出错的能力</p>
<p>思路一：<br>使用额外的数组，将链表中的元素放到数组中。之后类似荷兰国旗问题，对数组进行一次partition，之后再还原为链表。</p>
<p>思路二：<br>思路一其实没有发挥链表的优势：拆分灵活，实质上只需要在遍历链表的时候，把原来的大链表拆分成三个小的链表就可以了，拆分之后再讲这三个小的链表串起来，灵活方便，也不容易出错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode</span><br><span class="line">&#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Divide</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int ifempty(ListNode *head)</span><br><span class="line">    &#123;</span><br><span class="line">        if (head-&gt;next==NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* listDivide(ListNode* head, int val)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *heada=new ListNode(-1);</span><br><span class="line">        ListNode *headc=new ListNode(-1);</span><br><span class="line">        ListNode *taila=heada;</span><br><span class="line">        ListNode *tailc=headc;</span><br><span class="line">        ListNode *returnHead;</span><br><span class="line">        ListNode *temp=head;</span><br><span class="line">        if (temp-&gt;next==NULL)&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        while(temp!=NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *newnode=new ListNode(temp-&gt;val);</span><br><span class="line">            if(temp-&gt;val&lt;=val)</span><br><span class="line">            &#123;</span><br><span class="line">                taila-&gt;next=newnode;</span><br><span class="line">                taila=newnode;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                tailc-&gt;next=newnode;</span><br><span class="line">                tailc=newnode;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ifempty(heada)==false)</span><br><span class="line">        &#123;</span><br><span class="line">            returnHead=heada-&gt;next;</span><br><span class="line">            taila-&gt;next=headc-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ifempty(heada)==true &amp;&amp; ifempty(headc)==false)</span><br><span class="line">        &#123;</span><br><span class="line">            returnHead=headc-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return returnHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[5]= &#123;360,220,2&#125;;</span><br><span class="line">    int val=2;</span><br><span class="line">    int i;</span><br><span class="line">    ListNode *head=new ListNode(360);</span><br><span class="line">    ListNode *tail=head;</span><br><span class="line">    ListNode *returnHead;</span><br><span class="line">    for(i=1; i&lt;3; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *temp=new ListNode(a[i]);</span><br><span class="line">        tail-&gt;next=temp;</span><br><span class="line">        tail=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    tail=head;</span><br><span class="line">    while(tail!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot; %d&quot;,tail-&gt;val);</span><br><span class="line">        tail=tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    putchar(&apos;\n&apos;);</span><br><span class="line">    Divide d;</span><br><span class="line">    returnHead=d.listDivide(head,val);</span><br><span class="line">    tail=returnHead;</span><br><span class="line">    while(tail!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot; %d&quot;,tail-&gt;val);</span><br><span class="line">        tail=tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两个链表的公共部分-这个没有要求公共部分连续-降低了一些难度"><a href="#两个链表的公共部分-这个没有要求公共部分连续-降低了一些难度" class="headerlink" title="两个链表的公共部分(这个没有要求公共部分连续 降低了一些难度)"></a>两个链表的公共部分(这个没有要求公共部分连续 降低了一些难度)</h3><p>给定两个有序链表的头结点head1以及head2，求两个有序链表的公共部分。</p>
<p>其实思路也很简单，就是类似于之前的两指针的思路。</p>
<p>是指上是两指针问题的一个链表版本的实现。</p>
<p>首先是前提条件判断，如果为空的时候，就直接返回空，之后index1与index2都从头开始往后遍历，如果两个元素的值相等，则打印，之后两个index全都后移，否则，值稍微小一点的那个链表的index向后移动，重复前面的逻辑。</p>
<p>代码实现起来倒是比较简单，注意开始时候的空值判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Common</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findCommonParts(ListNode* headA, ListNode* headB)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; common;</span><br><span class="line">        if (headA-&gt;next==NULL||headB-&gt;next==NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return common;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *tailA=headA;</span><br><span class="line">        ListNode *tailB=headB;</span><br><span class="line">        while(tailA!=NULL&amp;&amp;tailB!=NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            if(tailA-&gt;val==tailB-&gt;val)&#123;</span><br><span class="line">                common.push_back(tailA-&gt;val);</span><br><span class="line">                tailA=tailA-&gt;next;</span><br><span class="line">                tailB=tailB-&gt;next;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;else if(tailA-&gt;val&lt;tailB-&gt;val)&#123;</span><br><span class="line">                tailA=tailA-&gt;next;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                tailB=tailB-&gt;next;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return common;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="链表局部逆序（比较灵活-综合性较强）"><a href="#链表局部逆序（比较灵活-综合性较强）" class="headerlink" title="链表局部逆序（比较灵活 综合性较强）"></a>链表局部逆序（比较灵活 综合性较强）</h3><p>给定一个链表的头结点head，实现一个调整单链表的函数，使得每K个节点之间逆序，如果最后不够K格节点一组，则不调整最后的几个节点。</p>
<p>比如链表 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;null K=3 进行调整之后，就会变成3-&gt;2-&gt;1-&gt;6-&gt;5-&gt;4-&gt;7-&gt;8-&gt;null 因为最后两个元素的个数加起来没有组成3，所以最后两个节点不够一组。<br>说起来简单做起来难，总之有好多边界情况需要考虑，这块可能隐藏着的坑比较多。</p>
<p>思路一：<br>其实有点综合题的感觉，涉及到逆序类的题目，可以很自然的联想到逆序的操作，比如前面K个元素先入栈，之后再反向一一弹出，每次弹出的时候，需要链表的next指针进行重连，具体涉及到的细节比较多。</p>
<p>注意最后元素不足k个的时候，应该如何处理。<br>组与组之前需要经行连接，需要记下上一组中的最后一个元素。<br>返回调整时候链表的头结点，函数应该返回链表的头结点。</p>
<p>思路二：<br>与方法一类似，就是省去了栈的这种额外结构，依然是搜集到k个元素就进行一次k个元素之间的逆序操作。每组逆序之后的头节点和上一组已经调整好的尾节点相连。</p>
<p>总的来说，使用栈的话，实现上还是会简单一些，下面是相关代码，做题的时候还是要仔细一点，别把stack与vector两个结构给弄混了。。。：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct ListNode</span><br><span class="line">&#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class KInverse</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* inverse(ListNode* head, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *tail=head;</span><br><span class="line">        ListNode *newhead=new ListNode(-1);</span><br><span class="line">        ListNode *newtail=newhead;</span><br><span class="line">        stack&lt;ListNode*&gt; help;</span><br><span class="line">        while(tail!=NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            help.push(tail);</span><br><span class="line">            tail=tail-&gt;next;</span><br><span class="line">            if (help.size()==k)</span><br><span class="line">            &#123;</span><br><span class="line">                //pop and link to new list</span><br><span class="line">                while(help.empty()==false)</span><br><span class="line">                &#123;</span><br><span class="line">                    ListNode *temp=help.top();</span><br><span class="line">                    help.pop();</span><br><span class="line">                    newtail-&gt;next=temp;</span><br><span class="line">                    newtail=newtail-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //extra element in stack</span><br><span class="line">        ListNode *lastone;</span><br><span class="line">        if(help.empty()==false)&#123;</span><br><span class="line">            lastone=help.top();</span><br><span class="line">            help.pop();</span><br><span class="line">            lastone-&gt;next=NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        while(help.empty()==false) &#123;</span><br><span class="line">                ListNode *temp=help.top();</span><br><span class="line">                help.pop();</span><br><span class="line">                temp-&gt;next=lastone;</span><br><span class="line">                lastone=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        newtail-&gt;next=lastone;</span><br><span class="line">        return newhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int a[10]=&#123;1,2,3,4,5,6,7,8&#125;;</span><br><span class="line">    ListNode *head=new ListNode(a[0]);</span><br><span class="line">    int i;</span><br><span class="line">    ListNode *tail=head;</span><br><span class="line">    for (i=1;i&lt;8;i++)&#123;</span><br><span class="line">        ListNode *temp=new ListNode(a[i]);</span><br><span class="line">        tail-&gt;next=temp;</span><br><span class="line">        tail=tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tail=head;</span><br><span class="line">    while(tail!=NULL)&#123;</span><br><span class="line">        printf(&quot; %d&quot;,tail-&gt;val);</span><br><span class="line">        tail=tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    putchar(&apos;\n&apos;);</span><br><span class="line">    KInverse k;</span><br><span class="line">    ListNode *newhead=k.inverse(head,3);</span><br><span class="line">    tail=newhead;</span><br><span class="line">    while(tail!=NULL)&#123;</span><br><span class="line">        printf(&quot; %d&quot;,tail-&gt;val);</span><br><span class="line">        tail=tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除值为val的节点"><a href="#删除值为val的节点" class="headerlink" title="删除值为val的节点"></a>删除值为val的节点</h3><p>给定一个单链表的头节点head，链表中的每个节点保存一个整数，再给定一个值val，把左右值等于val的节点全部删掉。（注意边界条件 仅有一个节点的时候怎么处理）</p>
<p>思路上不难，把整个过程看做是一个新链表的构造过程，还是细节，如果当前的这个节点是val，就直接抛弃，否则就接到新节点的末尾。</p>
<p><strong>注意设置专用头结点的小技巧：</strong><br>这个题目在给的时候，头结点的位置实际上是第一个元素，这种问题给法在实际处理的时候很不方便，应为总是要考虑第一个元素的特殊情况，后面case的处理方式无法和第一个统一起来，这个时候可以对原来的链表进行适当的“扩展”，就是扩展出一个realHead，作为真正的头结点，让realHead的next值指向第一个存储了元素的节点，即head，prev指针开始的时候就放在realHead的这个位置上，这样后面的情况处理起来就可以用一个逻辑进行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class ClearValue &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* clear(ListNode* head, int val) &#123;</span><br><span class="line">        // write code here</span><br><span class="line">        ListNode *realHead=new ListNode(-1);</span><br><span class="line">        realHead-&gt;next=head;</span><br><span class="line">        ListNode *prev=realHead;</span><br><span class="line">        ListNode *curr=head;</span><br><span class="line">        int temp;</span><br><span class="line">        while(curr!=NULL)&#123;</span><br><span class="line">            temp=curr-&gt;val;</span><br><span class="line">            if(temp==val)&#123;</span><br><span class="line">                prev-&gt;next=curr-&gt;next;</span><br><span class="line">                delete(curr);</span><br><span class="line">                curr=prev-&gt;next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                curr=curr-&gt;next;</span><br><span class="line">                prev=prev-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return realHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="判断一个链表是否为回文结构（后面两种方法很有启发性）"><a href="#判断一个链表是否为回文结构（后面两种方法很有启发性）" class="headerlink" title="判断一个链表是否为回文结构（后面两种方法很有启发性）"></a>判断一个链表是否为回文结构（后面两种方法很有启发性）</h3><p>比如：链表 1-2-3-2-1 是回文结构，返回true，链表1-2-3-1不是回文结构，返回false。</p>
<p>思路1</p>
<p>借用栈，第一次遍历，把元素压入栈中，第二次遍历，栈中元素同时也向外弹出，一次比较，如果比较到最后，所有的元素都相等，说明是回文结构。（实现上是最简单的）<br>代码如下，注意stack的基本操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Palindrome &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* pHead) &#123;</span><br><span class="line">        // write code here</span><br><span class="line">        stack&lt;ListNode*&gt; s;</span><br><span class="line">        ListNode*tail=pHead;</span><br><span class="line">        while(tail!=NULL)&#123;</span><br><span class="line">            s.push(tail);</span><br><span class="line">            tail=tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail=pHead;</span><br><span class="line">        ListNode*temp = NULL;</span><br><span class="line">        while(tail!=NULL)&#123;</span><br><span class="line">            temp=s.top();</span><br><span class="line">            if (temp-&gt;val!=tail-&gt;val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            tail=tail-&gt;next;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return true;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>思路2</p>
<p>思路1的升级版本，采用快指针和慢指针两个指针，慢指针一次向后移动一个元素，快指针一次向后移动两个元素，慢指针每次移动到的元素入栈。当快指针移动到末尾的时候，如果链表的个数奇数，就不入栈，如果为偶数则入栈，之后慢指针再向后移动，同时弹出栈中元素，依次比较是否相等，判断是否为回文链表。相当于是把链表左半部分折过来与链表的右半部分进行比较。</p>
<p>思路3</p>
<p>找到链表中间的位置，之后把链表右半部分逆序，之后采用两指针的思路，从链表的两端向中间的位置遍历，链表将被调整成这样的结构：1-&gt;2-&gt;3&lt;-2&lt;-1</p>
<h3 id="random指针（较难-链表的拆分-拷贝）"><a href="#random指针（较难-链表的拆分-拷贝）" class="headerlink" title="random指针（较难 链表的拆分 拷贝）"></a>random指针（较难 链表的拆分 拷贝）</h3><p>一个链表结构中，每个节点不仅含有一条指向下一个节点的next指针，同时含有一条random指针，random指针可能指向链表当中的任意一个节点（可前可后），请复制这种含有random指针节点的链表。</p>
<p>这个题目的难点在与random指针的复制，比如新copy了一个节点，这个时候，如何让新节点的random指针指过去的元素也是新copy出来的，这是这个题目的难点所在。</p>
<p>思路：</p>
<ul>
<li>遍历链表，每次遍历的时候，复制一个元素在后面，比如原先的链表为1-&gt;2-&gt;3，复制操作之后变为1-&gt;1’-&gt;2-&gt;2’-&gt;3-&gt;3’，这种结构的一个特殊性，或者说是规律性就在与，新copy出来的元素的位置在原来的老元素的下一个位置（这一点是相当关键的）</li>
<li>之后开始指针的复制，通过1’的random指针，可以找到原来1节点指向的元素位置，比如说是3，那么3的下一个位置就是3’，这个时候，就可以找到3’，将1’的random指针调整过去，依次这样进行，就可以完成所有的random指针的调整。</li>
<li>最后一步就会把就的链表和新的链表进行拆分处理，拆成两个新的链表。<br>下面是代码，不知道为内存超限了，注意一点就是第一次copy的时候，tail指针的位置要落在原来的元素上，而不是copy了之后的元素上。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct RandomListNode &#123;</span><br><span class="line">    int label;</span><br><span class="line">    struct RandomListNode *next, *random;</span><br><span class="line">    RandomListNode(int x) :</span><br><span class="line">            label(x), next(NULL), random(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    RandomListNode* Clone(RandomListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        RandomListNode* realHead=new RandomListNode(-1);</span><br><span class="line">        realHead-&gt;next=pHead;</span><br><span class="line">        RandomListNode* prev=realHead;</span><br><span class="line">        RandomListNode* tail=pHead;</span><br><span class="line">        while(tail!=NULL)&#123;</span><br><span class="line">            RandomListNode* newNode=new RandomListNode(tail-&gt;label);</span><br><span class="line">            newNode-&gt;next=tail-&gt;next;</span><br><span class="line">            newNode-&gt;random=tail-&gt;random;</span><br><span class="line">            prev-&gt;next=newNode;</span><br><span class="line">            prev=tail-&gt;next;</span><br><span class="line">            tail=tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tail=pHead;</span><br><span class="line">        RandomListNode*copyNode=NULL;</span><br><span class="line">        while(tail!=NULL)&#123;</span><br><span class="line">            copyNode=tail-&gt;next;</span><br><span class="line">            copyNode-&gt;random=copyNode-&gt;random-&gt;next;</span><br><span class="line">            tail=tail-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        prev=realHead;</span><br><span class="line">        tail=pHead;</span><br><span class="line">        while(tail!=NULL)&#123;</span><br><span class="line">            prev-&gt;next=tail-&gt;next;</span><br><span class="line">            prev=prev-&gt;next;</span><br><span class="line">            tail=tail-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return realHead-&gt;next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="判断一个单链表是否有环并找出相遇点"><a href="#判断一个单链表是否有环并找出相遇点" class="headerlink" title="判断一个单链表是否有环并找出相遇点"></a>判断一个单链表是否有环并找出相遇点</h3><p>如何判断一个单链表中是否有环，有环的话，进入环的第一个节点，无环的话，返回空。判断单链表是否有环的操作还是挺容易的，但是找第一个节点的这个操作还是有点难，可以看之前的这个，还是死记住吧。。。关键是中间的那个方程的推导。</p>
<p>当然还是有简单思路的，如果没有空间复杂度的限制条件，可以采用hash表的思路进行求解，每次遍历一个元素，在hash表中将这个元素记录一下，key值可以是一个自增的index，value值可以是地址，之后如果在hash表中，发现了重复出现的元素，就说明其中有环，那么第一个重复出现的元素，也就是环开始的地方，这种方式相比于上一种，思路上是简洁明了的，实现上也是会简单许多的。</p>
<p>注意题目的多种解法。</p>
<p>稍微把之前blog中的算法做一下改动即可，前面的各种情况判断确实有点复杂，不确定重新写一次的话，还是否能够写对，前面在考虑链表长度为0和1的时候，已经考虑了许多特殊的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class ChkLoop &#123;  </span><br><span class="line">public:</span><br><span class="line">    int chkLoop(ListNode* head, int adjust) &#123;</span><br><span class="line">        ListNode *h1=head;</span><br><span class="line">        ListNode *h2=head;</span><br><span class="line">        bool cycle=false;</span><br><span class="line">        int flag=0;</span><br><span class="line">        if (head==NULL)&#123;</span><br><span class="line">            cycle = false;</span><br><span class="line">            flag=1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (h1!=NULL&amp;&amp;h1-&gt;next==h1)&#123;</span><br><span class="line">            cycle =true;</span><br><span class="line">            flag=1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (h1!=NULL&amp;&amp;h1-&gt;next==NULL)&#123;</span><br><span class="line">            cycle = false;</span><br><span class="line">            flag=1;</span><br><span class="line">        &#125;</span><br><span class="line">        while(h1!=NULL&amp;&amp;h2!=NULL&amp;&amp;flag==0)&#123;</span><br><span class="line">            h1=h1-&gt;next;</span><br><span class="line">            if(h2-&gt;next!=NULL)&#123;</span><br><span class="line">                h2=h2-&gt;next-&gt;next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(h1==h2)&#123;</span><br><span class="line">                cycle=true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cycle==false)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            h1=head;</span><br><span class="line">            while(h1!=h2)&#123;</span><br><span class="line">                h1=h1-&gt;next;</span><br><span class="line">                h2=h2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return h1-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="判断两个无环单链表是否相交"><a href="#判断两个无环单链表是否相交" class="headerlink" title="判断两个无环单链表是否相交"></a>判断两个无环单链表是否相交</h3><p>考研时候的场景真是历历在目啊。</p>
<ul>
<li>首先是遍历两个链表，得到它们的长度，m以及n，比如m&gt;n，说明第一个链表比第二个多出m-n个节点。</li>
<li>之后让指向第一个链表的指针向后走m-n步，这样两个链表就在同样的起点位置了。</li>
<li>之后让指向两个链表的指针一起往后遍历，如果出现了公共的节点，说明两个链表在某个位置开始相交了。</li>
</ul>
<p>当然还是有普通解法，就是类似上个题目一样，采用“万能的”hash表来实现，分别遍历两个链表，然后把其中的元素记录在hash表中，如果出现重复的，说明两个链表在这个位置开始相交了。如果一直没有出现重复的元素，说明两个链表不相交。</p>
<p>注意程序里面，最后一步的地方，先判断两个节点是否相同，然后再往下走，注意清楚逻辑顺序！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class CheckIntersect &#123;</span><br><span class="line">int getLen(ListNode* head)&#123;</span><br><span class="line">    int len=0;</span><br><span class="line">    ListNode* tail=head;</span><br><span class="line">    while(tail!=NULL)&#123;</span><br><span class="line">        len=len+1;</span><br><span class="line">        tail=tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">    bool chkIntersect(ListNode* headA, ListNode* headB) &#123;</span><br><span class="line">        // write code here</span><br><span class="line">        int lena=getLen(headA);</span><br><span class="line">        int lenb=getLen(headB);</span><br><span class="line">        ListNode*taila=headA;</span><br><span class="line">        ListNode*tailb=headB;</span><br><span class="line">        int temp;</span><br><span class="line">        if(lena&gt;lenb)&#123;</span><br><span class="line">            temp=lena-lenb;</span><br><span class="line">            while(temp--)&#123;</span><br><span class="line">                taila=taila-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            temp=lenb-lena;</span><br><span class="line">            while(temp--)&#123;</span><br><span class="line">                tailb=tailb-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //move together</span><br><span class="line">        while(taila!=NULL&amp;&amp;tailb!=NULL)&#123;</span><br><span class="line">            if (taila==tailb)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            taila=taila-&gt;next;</span><br><span class="line">            tailb=tailb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="如何判断两个有环的单链表是否相交"><a href="#如何判断两个有环的单链表是否相交" class="headerlink" title="如何判断两个有环的单链表是否相交"></a>如何判断两个有环的单链表是否相交</h3><p>如何判断两个有环的单链表是否相交，相交的话，返回第一个相交的节点，不相交的话，返回空。</p>
<p>当然，万能的hash表还是可以解决这个题目的。</p>
<p>首先要明确的一个基本概念，什么样的情况叫做链表相交，实际上更准确的表述是说，两个链表，从某个节点开始之后，剩下的部分都开始重合了，不存才那种”X”形式的相交，因为根据链表的结构，不会有两个next指针，只能是类似”Y”形的这种情况。或者是Y形后面接一个环的形状，再或者是一个环，然后分出两个小枝，两个链表在环的不同节点位置入环。</p>
<p>更高效的思路，首先是判断两个链表的环的起始的节点，具体方法可以根据上面的题目中的思路，比如两个如环节点分别是head1与head2</p>
<ul>
<li>如果head1=head2，两个链表可能在入环之前就出现相交，这个时候按照上上题的方式，只不过遍历的终止节点为head1=head2</li>
<li>如果head1！=head2 可能是两个有换的链表根本不相交，或者如环节点是大环上的两个节点，这个时候从head1开始遍历，如果在遍历过程中找到了head2，说明是第二种情况，返回head1或者是head2都是可以的，如果在遍历的过程中，没有找到head2，又回到了head1节点，说明两个环形链表是不相交的。<br>没有在规定时间运行完？？(需要把上一个题目的程序修改下，结束标志由NULL变为公共元素)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class ChkIntersection &#123;</span><br><span class="line">    </span><br><span class="line">    int getLen(ListNode* head,ListNode*common)&#123;</span><br><span class="line">    int len=0;</span><br><span class="line">    ListNode* tail=head;</span><br><span class="line">    while(tail!=common)&#123;</span><br><span class="line">        len=len+1;</span><br><span class="line">        tail=tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br><span class="line">    bool chkIntersect(ListNode* headA, ListNode* headB,ListNode*common) &#123;</span><br><span class="line">        // write code here</span><br><span class="line">        int lena=getLen(headA,common);</span><br><span class="line">        int lenb=getLen(headB,common);</span><br><span class="line">        ListNode*taila=headA;</span><br><span class="line">        ListNode*tailb=headB;</span><br><span class="line">        int temp;</span><br><span class="line">        if(lena&gt;lenb)&#123;</span><br><span class="line">            temp=lena-lenb;</span><br><span class="line">            while(temp--)&#123;</span><br><span class="line">                taila=taila-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            temp=lenb-lena;</span><br><span class="line">            while(temp--)&#123;</span><br><span class="line">                tailb=tailb-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //move together</span><br><span class="line">        while(taila!=common&amp;&amp;tailb!=common)&#123;</span><br><span class="line">            if (taila==tailb)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            taila=taila-&gt;next;</span><br><span class="line">            tailb=tailb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    ListNode* detectCycle(ListNode* head) &#123;</span><br><span class="line">        ListNode *h1=head;</span><br><span class="line">        ListNode *h2=head;</span><br><span class="line">        bool cycle=false;</span><br><span class="line">        int flag=0;</span><br><span class="line">        if (head==NULL)&#123;</span><br><span class="line">            cycle = false;</span><br><span class="line">            flag=1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (h1!=NULL&amp;&amp;h1-&gt;next==h1)&#123;</span><br><span class="line">            cycle =true;</span><br><span class="line">            flag=1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (h1!=NULL&amp;&amp;h1-&gt;next==NULL)&#123;</span><br><span class="line">            cycle = false;</span><br><span class="line">            flag=1;</span><br><span class="line">        &#125;</span><br><span class="line">        while(h1!=NULL&amp;&amp;h2!=NULL&amp;&amp;flag==0)&#123;</span><br><span class="line">            h1=h1-&gt;next;</span><br><span class="line">            if(h2-&gt;next!=NULL)&#123;</span><br><span class="line">                h2=h2-&gt;next-&gt;next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(h1==h2)&#123;</span><br><span class="line">                cycle=true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cycle==false)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            h1=head;</span><br><span class="line">            while(h1!=h2)&#123;</span><br><span class="line">                h1=h1-&gt;next;</span><br><span class="line">                h2=h2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return h1;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    bool chkInter(ListNode* head1, ListNode* head2, int adjust0, int adjust1) &#123;</span><br><span class="line">        // write code here</span><br><span class="line">        ListNode * pointA=detectCycle(head1);</span><br><span class="line">        ListNode * pointB=detectCycle(head2);</span><br><span class="line">        if (pointA==NULL||pointB==NULL)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(pointA==pointB)&#123;</span><br><span class="line">            return chkIntersect(head1,head2,pointA);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">             ListNode*curr=pointA-&gt;next;</span><br><span class="line">             while(curr!=pointA)&#123;</span><br><span class="line">               if (curr==pointB)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="判断两个单链表是否相交（综合题目）"><a href="#判断两个单链表是否相交（综合题目）" class="headerlink" title="判断两个单链表是否相交（综合题目）"></a>判断两个单链表是否相交（综合题目）</h3><p>给定两个单链表的头结点head1以及head2，如何判断两个链表是否相交？相交的话返回第一个相交的节点，不想交的话返回空。</p>
<p>这个题目的关键之处，是不确定两个链表是否为有环链表，还是无环链表。所以只要分类讨论即可，实际上是链表相交类题目的一个综合。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/13/algorithm-4-linked-list/" data-id="cknxb32pq005ubss6gh19p9u2" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
 <script src="/jquery/jquery.min.js"></script>
  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2019/06/13/algorithm-5-hash-table-and-two-pointers-2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          Algorithm(5) hash table and two pointers(2)
        
      </div>
    </a>
  
  
    <a href="/2019/06/13/algorithm-3-stack-and-queue/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Algorithm(3) stack and queue questions</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本知识"><span class="toc-number">1.</span> <span class="toc-text">基本知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有序的环形单链表中插入新的元素"><span class="toc-number">2.</span> <span class="toc-text">有序的环形单链表中插入新的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除链表中的节点-简单但是不容易想到-有种跳跃思维在里面"><span class="toc-number">3.</span> <span class="toc-text">删除链表中的节点(简单但是不容易想到 有种跳跃思维在里面)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调整链表元素的位置（partition）"><span class="toc-number">4.</span> <span class="toc-text">调整链表元素的位置（partition）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两个链表的公共部分-这个没有要求公共部分连续-降低了一些难度"><span class="toc-number">5.</span> <span class="toc-text">两个链表的公共部分(这个没有要求公共部分连续 降低了一些难度)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表局部逆序（比较灵活-综合性较强）"><span class="toc-number">6.</span> <span class="toc-text">链表局部逆序（比较灵活 综合性较强）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除值为val的节点"><span class="toc-number">7.</span> <span class="toc-text">删除值为val的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断一个链表是否为回文结构（后面两种方法很有启发性）"><span class="toc-number">8.</span> <span class="toc-text">判断一个链表是否为回文结构（后面两种方法很有启发性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#random指针（较难-链表的拆分-拷贝）"><span class="toc-number">9.</span> <span class="toc-text">random指针（较难 链表的拆分 拷贝）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断一个单链表是否有环并找出相遇点"><span class="toc-number">10.</span> <span class="toc-text">判断一个单链表是否有环并找出相遇点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断两个无环单链表是否相交"><span class="toc-number">11.</span> <span class="toc-text">判断两个无环单链表是否相交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何判断两个有环的单链表是否相交"><span class="toc-number">12.</span> <span class="toc-text">如何判断两个有环的单链表是否相交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断两个单链表是否相交（综合题目）"><span class="toc-number">13.</span> <span class="toc-text">判断两个单链表是否相交（综合题目）</span></a></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2021 zhe&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;godenwangzhe@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>