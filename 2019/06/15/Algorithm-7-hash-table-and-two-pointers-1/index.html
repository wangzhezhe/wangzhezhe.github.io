<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Algorithm(7) Two pointers and hash table (Part A)(By solution) | AverageMind</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="整理一下leetcode里面关于 2sum 3sum 的几个问题，后面还补充了几个two pointer的其他问题，主要是longest sub str with at most K distinct characters的一系列问题。关于 hashtable 以及 two pointer的应用，由于在实现上不像树、图那些在结构上比较复杂，大多是灵光一闪，或者是绕一两个弯就能想到的，面试也是各种常">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithm(7) Two pointers and hash table (Part A)(By solution)">
<meta property="og:url" content="http://yoursite.com/2019/06/15/Algorithm-7-hash-table-and-two-pointers-1/index.html">
<meta property="og:site_name" content="AverageMind">
<meta property="og:description" content="整理一下leetcode里面关于 2sum 3sum 的几个问题，后面还补充了几个two pointer的其他问题，主要是longest sub str with at most K distinct characters的一系列问题。关于 hashtable 以及 two pointer的应用，由于在实现上不像树、图那些在结构上比较复杂，大多是灵光一闪，或者是绕一两个弯就能想到的，面试也是各种常">
<meta property="og:locale">
<meta property="og:image" content="http://yoursite.com/images/DebugExample.png">
<meta property="article:published_time" content="2019-06-15T15:17:15.000Z">
<meta property="article:modified_time" content="2023-11-30T04:46:36.754Z">
<meta property="article:author" content="zhe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/DebugExample.png">
  
    <link rel="alternate" href="/atom.xml" title="AverageMind" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-165927341-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AverageMind</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Algorithm-7-hash-table-and-two-pointers-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/15/Algorithm-7-hash-table-and-two-pointers-1/" class="article-date">
  <time datetime="2019-06-15T15:17:15.000Z" itemprop="datePublished">2019-06-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Algorithm(7) Two pointers and hash table (Part A)(By solution)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>整理一下leetcode里面关于 2sum 3sum 的几个问题，后面还补充了几个two pointer的其他问题，主要是longest sub str with at most K distinct characters的一系列问题。关于 hashtable 以及 two pointer的应用，由于在实现上不像树、图那些在结构上比较复杂，大多是灵光一闪，或者是绕一两个弯就能想到的，面试也是各种常考，应该是要掌握好的一类基本问题。</p>
<span id="more"></span>

<p>通常思路上而言，two pointer的题目就是把O(N^2)的时间算法简化到O(N)或者O(M+N) (when there are two input arrays)。主要的模式有两种，一个是快慢指针的类型，另一种是指针从两边往中间走的类型。</p>
<p>这一部分题目关键是掌握几种常见的问题背景，因为每一种背景可能有一些隐藏的信息，比如container with water 11 和 42 都是从两边往中间走。因为当前container的长度是最长的，如何后面的container的高度比当前的短的话，就不可能得到更大的容积。</p>
<p>移动指针的时候常用的套路就是每次移动之后再进行比较。一般是一个for loop + while loop 外层for loop 有O(N)的复杂度，内层如果是for就成了O(N^2)的算法了，一般内层就是一个while loop 可以trim 掉很多的组合。while (i&lt;n) { do sth; i++} 这样的操作本质上和 for(i&#x3D;0;i&lt;n;i++) {do sth} 是一样的操作。或者就是另外一种，用一个while(i&lt;j)的loop，每次往中间移动一个元素。</p>
<p>还有常用的套路就是使用map，特别是对于distinct elements以及2&#x2F;3 sum这样的类型的题目。subarray sum 之类的题目常常用到的技巧是prefix sum 比如 560 用到了prefix sum 以及 map 并且还有一些 2 sum 的技巧。</p>
<h3 id="Pointer-from-two-sides"><a href="#Pointer-from-two-sides" class="headerlink" title="Pointer from two sides"></a>Pointer from two sides</h3><h4 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11 Container With Most Water"></a>11 Container With Most Water</h4><p>这个就是指针从两边往中间移动的题目，核心的操作是找 <code>max(h[i],h[j])*(j-i)</code> 所以就是移动左边或者右边比较小的那个指针的位置，固定一边，移动另一边，才有可能找到更大的组合的可能。因为每次while循环开始的时候就认为<strong>假设元素的位置已经移动了，或者是系统的状态已经更新了</strong>，所以要在这里updata metadata。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = h.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxV = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            maxV=<span class="built_in">max</span>(maxV, (j-i)*<span class="built_in">min</span>(h[i],h[j]));</span><br><span class="line">            <span class="keyword">if</span>(h[i]&lt;h[j]) </span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>One good explanation is that, since we move from largest distance to the smallest distance, once the h[i]&lt;h[j], the h[i] will not be used in future cases when there is less distance. (even if we get higher number of the right value, the min value is still h[i], since the current dist is the largest one we iterate, the further container volum can not larger than current one) in current dist, there might exist some combination larger than (h[i],h[j]). </p>
<h4 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42 Trapping Rain Water"></a>42 Trapping Rain Water</h4><p>这个是前一个题目的升级版，关键是首先弄清楚所要search的对象对于每个slot是 <code>min(h[left bound], h[right bound]) - h[curr hight]</code> 这一点不是很容易想到。</p>
<p>具体框架与前面一个题目类似，在比较的时候，比如更新到某个位置的时候，要考虑清楚移动的原因，比如h[lb]&gt;h[rb] 这个时候对于右边的当前元素来说，如果lb 和 rb 中间有更高的wall，那对于右边的元素来说，wall的位置是h[rb] 因为这个位置的元素限制了water的高度。如果它们之间都是比较低的wall的话，那water level的位置还是h[rb]，因为这个时候本身左边的wall的高度就是更高的。</p>
<p>所每次移动的时候要随时更新left tall wall and right tall wall 的位置。因为每次不是更新左边就是更更新右边，所以当前元素的位置也要随时更新。相比起上一个题目，这个难点就是需要维护更多的metadata。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=h.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> LTWall=h[i];</span><br><span class="line">        <span class="type">int</span> RTWall=h[j];</span><br><span class="line">        <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> currPos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="comment">//element moved</span></span><br><span class="line">            <span class="comment">//update metadata</span></span><br><span class="line">            <span class="comment">//i and j are current wall position</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">min</span>(LTWall,RTWall)&gt;h[currPos])&#123;</span><br><span class="line">                <span class="comment">//when current is taller than bounuds, unit is 0</span></span><br><span class="line">                v=v+<span class="built_in">min</span>(LTWall,RTWall)-h[currPos];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//adjust how to move for next round</span></span><br><span class="line">            <span class="keyword">if</span>(h[i]&gt;h[j])&#123;</span><br><span class="line">                <span class="comment">//move right tall wall</span></span><br><span class="line">                j--;</span><br><span class="line">                currPos=j;</span><br><span class="line">                <span class="comment">//update wall</span></span><br><span class="line">                RTWall = <span class="built_in">max</span> (RTWall, h[currPos]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(h[i]&lt;h[j])&#123;</span><br><span class="line">                <span class="comment">//move left tall wall</span></span><br><span class="line">                i++;</span><br><span class="line">                currPos=i;</span><br><span class="line">                LTWall=<span class="built_in">max</span>(LTWall, h[currPos]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//h[i]==h[j]</span></span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">//either i or j</span></span><br><span class="line">                currPos=i;</span><br><span class="line">                LTWall=<span class="built_in">max</span>(RTWall, h[currPos]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This is a good explanation (really good) for this question<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=C8UjlJZsHBw">https://www.youtube.com/watch?v=C8UjlJZsHBw</a></p>
<p>There is even more complicated question, such as this: Trapping Rain Water II, however, it seems that it is not the simple extension from 1d volume water soluation, checking more details <a target="_blank" rel="noopener" href="https://leetcode.com/problems/trapping-rain-water-ii/solutions/2016151/c-explained-why-trapping-water-solution-doesn-t-work/">here</a>, even there is similar backgound, but the solution becomes different. (it becomes a BFS searching, searching cell from the current known lowest position)</p>
<h4 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125. Valid Palindrome"></a>125. Valid Palindrome</h4><p>The simple idea of two sided pointer that shows basic idea, there is no compilated data structure or background knowledge used in the iteration operation.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//converting string</span></span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; strnew;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="type">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">                strnew.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>+c-<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">                strnew.<span class="built_in">push_back</span>(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//the numebr is also included</span></span><br><span class="line">                strnew.<span class="built_in">push_back</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//decide if it is palindrome</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=strnew.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(strnew[i]!=strnew[j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>There are several similar question based on string using same techniques, such as 917.</p>
<h4 id="917-Reverse-Only-Letters"><a href="#917-Reverse-Only-Letters" class="headerlink" title="917. Reverse Only Letters"></a>917. Reverse Only Letters</h4><p>Figuring out the rule is important, when there is non english letter, when just skip it in one side. So there are two small while loop in the large while loop two skip associated elements. Be careful when checking the index such as i&lt;j</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isLetter</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseOnlyLetters</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=s.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="comment">//when either s[i] and s[j] is not english letter</span></span><br><span class="line">            <span class="comment">//just skip it</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isLetter</span>(s[i])==<span class="literal">false</span> &amp;&amp; i&lt;j)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isLetter</span>(s[j])==<span class="literal">false</span> &amp;&amp; i&lt;j)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//move till position where both char are letter</span></span><br><span class="line">            <span class="type">char</span> t = s[i];</span><br><span class="line">            s[i]=s[j];</span><br><span class="line">            s[j]=t;</span><br><span class="line">            <span class="comment">//skip reversed positions</span></span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Other-simple-cases"><a href="#Other-simple-cases" class="headerlink" title="Other simple cases"></a>Other simple cases</h4><p>977 is straightforward, when there is faraway from the center position, the square value is larger, so just compare the square of i position and j position continuously.</p>
<h3 id="Pointer-of-two-arrays"><a href="#Pointer-of-two-arrays" class="headerlink" title="Pointer of two arrays"></a>Pointer of two arrays</h3><h4 id="455-Assign-Cookies"><a href="#455-Assign-Cookies" class="headerlink" title="455. Assign Cookies"></a>455. Assign Cookies</h4><p>Using two pointer for each input array, the outline of code is really standard, just compare two element for each iteration, the important things is to figure out the pointer movement rules for each iteration. For this question, after sorting the input elements, we can get some extra benifits, when satiafaction level does not satisfy current child, we just need to move to next cookies, since the array is sorted. We do not need to need further comparision of current cookie’s satiafaction value with higher children’s satiafaction value.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">rbegin</span>(),g.<span class="built_in">rend</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">rbegin</span>(),s.<span class="built_in">rend</span>());</span><br><span class="line">        <span class="type">int</span> gsize = g.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ssize = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;gsize &amp;&amp; j&lt;ssize)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i]&gt;s[j])&#123;</span><br><span class="line">                <span class="comment">//not satisfy</span></span><br><span class="line">                <span class="comment">//subsequent children will not satisty</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(g[i]&lt;=s[j])&#123;</span><br><span class="line">                <span class="comment">//satisfy, assign cookie</span></span><br><span class="line">                j++;</span><br><span class="line">                i++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="925-Long-Pressed-Name"><a href="#925-Long-Pressed-Name" class="headerlink" title="925. Long Pressed Name"></a>925. Long Pressed Name</h4><p>Be careful about the edge cases, for example, one string completes the iteration but the other one does not compelete the iteration.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isLongPressedName</span><span class="params">(string name, string typed)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> namelen=name.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> typedlen=typed.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(typedlen&lt;namelen)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> prevLetter=name[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//initial positions are zero</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;namelen &amp;&amp; j&lt;typedlen)&#123;</span><br><span class="line">            <span class="keyword">if</span>(name[i]==typed[j])&#123;</span><br><span class="line">                prevLetter=name[i];</span><br><span class="line">                <span class="comment">//when they equal, both jump to next</span></span><br><span class="line">                j++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//when they not equal</span></span><br><span class="line">                <span class="keyword">if</span>(typed[j]==prevLetter)&#123;</span><br><span class="line">                    <span class="comment">//it might be repeated elements</span></span><br><span class="line">                    j++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//it might be wrong type</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//name does not run till the last one, false</span></span><br><span class="line">        <span class="comment">//some characters in raw name is not matched yet</span></span><br><span class="line">        <span class="keyword">if</span>(i!=namelen)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//check remaining part of j if it did not go to last element</span></span><br><span class="line">        <span class="comment">//there can be multiple remaining characters in j</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;typedlen)&#123;</span><br><span class="line">            <span class="keyword">if</span>(typed[j]!=prevLetter)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="986-Interval-List-Intersections"><a href="#986-Interval-List-Intersections" class="headerlink" title="986. Interval List Intersections"></a>986. Interval List Intersections</h4><p>The framework is a common one for this, the a little bit complicated part is to consider all kinds of situations each time when deciding how to move, there are two nonoverlapping case, two partial overlapping case and two fully overlapping case.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">intervalIntersection</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; firstList, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; secondList) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; intervals;</span><br><span class="line">        <span class="type">int</span> firstLen=firstList.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> secondLen=secondList.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;firstLen &amp;&amp; j&lt;secondLen)&#123;</span><br><span class="line">            <span class="comment">//get a new status</span></span><br><span class="line">            <span class="type">int</span> Sa = firstList[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> Ea = firstList[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> Sb = secondList[j][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> Eb = secondList[j][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//decide how to move pointers</span></span><br><span class="line">            <span class="comment">//there are multiple detailed cases here</span></span><br><span class="line">            <span class="comment">//two non overlapping</span></span><br><span class="line">            <span class="keyword">if</span>(Ea&lt;Sb)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Eb&lt;Sa)&#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//two partial overlaping</span></span><br><span class="line">            <span class="keyword">if</span>(Sa&lt;Sb &amp;&amp; Sb&lt;=Ea &amp;&amp; Eb&gt;Ea)&#123;</span><br><span class="line">                intervals.<span class="built_in">push_back</span>(&#123;Sb,Ea&#125;);</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Sa&lt;=Eb &amp;&amp; Eb&lt;Ea &amp;&amp; Sb&lt;Sa)&#123;</span><br><span class="line">                intervals.<span class="built_in">push_back</span>(&#123;Sa,Eb&#125;);</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">continue</span>;         </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//two full overlapping</span></span><br><span class="line">            <span class="keyword">if</span>(Sa&lt;=Sb &amp;&amp; Eb&lt;=Ea)&#123;</span><br><span class="line">                intervals.<span class="built_in">push_back</span>(&#123;Sb,Eb&#125;);</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">continue</span>;                  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Sb&lt;=Sa&amp;&amp; Ea&lt;=Eb)&#123;</span><br><span class="line">                intervals.<span class="built_in">push_back</span>(&#123;Sa,Ea&#125;);</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;         </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="K-sum"><a href="#K-sum" class="headerlink" title="K sum"></a>K sum</h3><h4 id="two-sum-1"><a href="#two-sum-1" class="headerlink" title="two sum (1)"></a>two sum (1)</h4><p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>
<p>You may assume that each input would have exactly one solution.</p>
<p>Input: numbers&#x3D;{2, 7, 11, 15}, target&#x3D;9<br>Output: index1&#x3D;1, index2&#x3D;2</p>
<p><strong>解法一</strong></p>
<p>由于要先定义好结构体，把index和value的值都存入进去，相比解法二直接使用map代码要稍微多一些，时间复杂度要稍微高一些。</p>
<ul>
<li>定义Node接口体 对生成vectorvnode对其进行初始化赋值</li>
<li>对vnode 根据每个元素的value值 进行vector排序</li>
<li>采用左右两个指针 向中间靠 发现符合 node1.v+node2.v&#x3D;target 的两个元素</li>
<li>和大于target则右指针左移 和小于target则左指针右移</li>
<li>取出其index值，index1&#x3D;min(node1.index,node2.index) index2&#x3D;max(node1.index,node2.index)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct Node&#123;</span><br><span class="line">	int index;</span><br><span class="line">	int value;</span><br><span class="line">	&#125;Node;</span><br><span class="line">	</span><br><span class="line">	bool cmp(Node a,  Node b)&#123;</span><br><span class="line">		return a.value&lt;b.value;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	class Solution &#123;</span><br><span class="line">		int min(int a,int b)&#123;</span><br><span class="line">			if (a&lt;=b)&#123;</span><br><span class="line">				return a;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				return b;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int max(int a,int b)&#123;</span><br><span class="line">			if (a&gt;=b)&#123;</span><br><span class="line">				return a;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				return b;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	public:</span><br><span class="line">	vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">	 vector&lt;Node&gt;vnode;</span><br><span class="line">	 int i,len=nums.size();</span><br><span class="line">	 for (i=0;i&lt;len;i++)&#123;</span><br><span class="line">	 		Node n;</span><br><span class="line">	 		n.index=i+1;</span><br><span class="line">	 		n.value=nums[i];</span><br><span class="line">	 		vnode.push_back(n);</span><br><span class="line">	 	&#125;</span><br><span class="line">	 	sort(vnode.begin(), vnode.end(), cmp);</span><br><span class="line">	 	vector&lt;int&gt;v;</span><br><span class="line">	 	i=0;</span><br><span class="line">	 	int j=nums.size()-1;</span><br><span class="line">	 	 while(i&lt;j)&#123;</span><br><span class="line">		    if (vnode[i].value+vnode[j].value==target)&#123;</span><br><span class="line">			int index1=min(vnode[i].index,vnode[j].index);</span><br><span class="line">			int index2=max(vnode[i].index,vnode[j].index);</span><br><span class="line">			v.push_back(index1);</span><br><span class="line">			v.push_back(index2);</span><br><span class="line">			//printf(&quot;index1=%d, index2=%d&quot;,index1,index2);</span><br><span class="line">			break;</span><br><span class="line">			&#125;else if (vnode[i].value+vnode[j].value&gt;target)&#123;</span><br><span class="line">				j--;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">			    i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return v;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>解法二</strong></p>
<p>利用map的特性，代码简单不少，实质上是很好地利用了map的空间和时间特性。</p>
<ul>
<li>create map &lt; int,int &gt; the lenth of vector is len 其中key值为array中的数字的值，value值为该数字在序列中的下标</li>
<li>遍历 vector 每次 keyb&#x3D; nums[i] keya &#x3D; target - keyb</li>
<li>如果keya不在map中，将当前的元素插入到map中，map[keya]&#x3D;i</li>
<li>否则，返回 index1&#x3D;map[keya] index2&#x3D;map[keyb]</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;                                                            </span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">             <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">             <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">             <span class="type">int</span> i;</span><br><span class="line">             map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;m;</span><br><span class="line">             vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">             i=<span class="number">0</span>;</span><br><span class="line">             <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                 <span class="type">int</span> keyb=nums[i];</span><br><span class="line">                 <span class="type">int</span> keya=target-keyb;</span><br><span class="line">                 </span><br><span class="line"> 						  <span class="comment">// or using m.count(keya)&gt;0</span></span><br><span class="line">                 <span class="keyword">if</span> (m.<span class="built_in">find</span>(keya)!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">                     <span class="comment">//or return &#123;i,m[keya]&#125; direactly</span></span><br><span class="line">                     v.<span class="built_in">push_back</span>(m[keya]);</span><br><span class="line">                     v.<span class="built_in">push_back</span>(i);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     m[keyb]=i;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> v;</span><br><span class="line">         &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意特殊用例，就是可能出现像 [ {0，4，1，0}，0 ] 这种情况，所以不能在开始的时候就把vector中的元素全部放到map中再对vector遍历，要一边遍历vector一边把其中的元素存到map中。</p>
<h4 id="167-Two-Sum-II-Input-Array-Is-Sorted"><a href="#167-Two-Sum-II-Input-Array-Is-Sorted" class="headerlink" title="167. Two Sum II - Input Array Is Sorted"></a>167. Two Sum II - Input Array Is Sorted</h4><p>Since the input array is sorted, there are some benifits using the two pointer from the both side. When v[i]+v[j] &gt; target, any value at the right side of j, is more larger, so we decrease j. Similarly, when v[i]+v[j] &lt; target, using any value at the left side of i is less than target, so we increase i </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=numbers.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="type">int</span> sum = numbers[i]+numbers[j];</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//sum==target</span></span><br><span class="line">                <span class="comment">//find i j </span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;i+<span class="number">1</span>,j+<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3Sum-15"><a href="#3Sum-15" class="headerlink" title="3Sum(15)"></a>3Sum(15)</h4><p>基本上是上一题目的基本升级版</p>
<p><strong>解法一</strong><br>采用两指针的思路，a+b+c&#x3D;0实际上就是求，a+b&#x3D;-c , 比上一个2sum的问题多需要考虑的一个地方就是，需要考虑多组不同的解，以及去掉重复的解。大致思路都是基于排序，之后再遍历，在每个元素后面的序列中找两个数字的和为-current的组合。如果不进行优化，肯定会超时的，优化的方面参考了这个</p>
<ul>
<li>整体思路是在2 sum 的基础上多进行一层循环，排序之后遍历每个元素，然后对剩下的部分进行2sum的subroutine。</li>
<li>一个是在遍历的时候 元素重复了就直接跳过</li>
<li>还有一个是 发现一组解之后 指针left right就要向右侧移动，把相同的元素都跳过，就是helper函数中的那两个while循环 但还是要保证 left &lt; right 并且在access i+1 和 j-1 之前要验证一下access的位置是否valid。<br>其他的细节问题，vector嵌套以及声明的时候在vc6.0中注意空格 ，比如 vector&lt;vector<int> &gt; , vector<int> temp 否则会编译错误，虽然老生常谈的了，还是被坑了。每次temp vector存数据的时候，先clear一下，貌似之前的记录还在。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">        void findsolution(int left,int right,int sum,vector&lt;int&gt; &amp;v, vector&lt;vector&lt;int&gt; &gt; &amp;solution)&#123;</span><br><span class="line">             //printf(&quot;l r s %d %d %d\n&quot;,left, right, sum);</span><br><span class="line">             int len=v.size();</span><br><span class="line">             int i=left;</span><br><span class="line">             int j=right;</span><br><span class="line">             vector&lt;int&gt; temp;</span><br><span class="line">             while(i&lt;j &amp;&amp; j&lt;len &amp;&amp; i&gt;=0)&#123;</span><br><span class="line">                if (v[i]+v[j]==sum)&#123;</span><br><span class="line">                    //attention to clear before store the number</span><br><span class="line">                    temp.clear();</span><br><span class="line">                    temp.push_back(-sum);</span><br><span class="line">                    temp.push_back(v[i]);</span><br><span class="line">                    temp.push_back(v[j]);</span><br><span class="line">                    solution.push_back(temp);</span><br><span class="line">                    //if there is repeated case at the beginning or end of the array</span><br><span class="line">                    while(i&lt;j &amp;&amp; i+1&lt;len &amp;&amp; v[i+1]==v[i] )&#123;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    while(i&lt;j &amp;&amp; j&gt;=1 &amp;&amp; v[j-1]==v[j] )&#123;</span><br><span class="line">                        j--; </span><br><span class="line">                    &#125;</span><br><span class="line">                    i++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;else if(v[i]+v[j]&lt;sum)&#123;</span><br><span class="line">                    i++;  </span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    //v[i]+v[j]&gt;sum</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    public:</span><br><span class="line">    vector&lt;vector &lt;int&gt; &gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; solution;</span><br><span class="line">        int i=0;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        //sort input array in ascending order</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">                </span><br><span class="line">        //traverse</span><br><span class="line">        int current;</span><br><span class="line">        for(i=0;i&lt;len-2;i++)&#123;</span><br><span class="line">            current=nums[i];</span><br><span class="line">            if(i&gt;0 &amp;&amp; current==nums[i-1])&#123;</span><br><span class="line">                //if not the first element and</span><br><span class="line">                //current element is same with previous one, skip </span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            int inputsum=-current;</span><br><span class="line">            if (current==0)&#123;</span><br><span class="line">						inputsum=0;</span><br><span class="line">            &#125;</span><br><span class="line">            //for each possible element, call subroutine</span><br><span class="line">            findsolution(i+1,len-1,inputsum,nums,solution);</span><br><span class="line">        &#125;</span><br><span class="line">        return solution;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>解法二</strong></p>
<p>使用map也是可以的，只不过key value的值与上题不同，value不是存储元素所在的位置。这个算法写出来比较容易，理解上有点困难。</p>
<p>比如 序列{-4，-1，-1，0，1，2} 遍历到-4的时候，从后面的元素开始看，需要在后面的元素中找两个元素，使得 a[i]+a[j]&#x3D;4 才符合，-1+5&#x3D;4 所以 map[-1]&#x3D;4 同理 ，map中依次存入 (4+0&#x3D;4) map[4]&#x3D;0 (3+1&#x3D;4) map[3]&#x3D;1 (2+2&#x3D;4) map[2]&#x3D;2 遍历所有的key值 若同时存在 map[a]&#x3D;b 以及 map[b]&#x3D;a 说明 a b 两元素同时都在这个序列中，并且a+b&#x3D;4。</p>
<p>对于去重的话，第一次遍历的时候，后面一个不等于前面一个，第二次存入map的时候，如果key值已经存在，并且 key&#x3D;&#x3D;value 就是三个元素中，有两个是相等的。类似 （2，-1，-1）这种</p>
<p>还有个问题没解决，如果不对原始序列排序的化，去重的问题要怎么考虑？这里还没解决，排序的话有超时了</p>
<p>这个是超时的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	</span><br><span class="line">    int min(int a,int b)&#123;</span><br><span class="line">		if (a&lt;b)&#123;</span><br><span class="line">			return a;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			return b;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int max(int a,int b)&#123;</span><br><span class="line">		if (a&gt;b)&#123;</span><br><span class="line">			return a;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			return b;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	void findsolutionbymap(int left,int right,int localindex,int sum,vector&lt;int&gt; &amp;v, vector&lt;vector&lt;int&gt; &gt; &amp;solution)&#123;</span><br><span class="line">     int i=0;	</span><br><span class="line">		int key,value;</span><br><span class="line">		vector&lt;int&gt; temp;</span><br><span class="line">		map&lt;int,int&gt;m;</span><br><span class="line">		m.clear();</span><br><span class="line">		for(i=left;i&lt;=right;i++)&#123;</span><br><span class="line">			key=sum-v[i];</span><br><span class="line">			value=v[i];</span><br><span class="line">			if(m.find(key)!=m.end()&amp;&amp;key==value&amp;&amp;m[key]==key)</span><br><span class="line">			&#123;</span><br><span class="line">				temp.clear();</span><br><span class="line">				temp.push_back(-sum);</span><br><span class="line">				temp.push_back(min(key,value));</span><br><span class="line">				temp.push_back(max(key,value));</span><br><span class="line">				solution.push_back(temp);</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			if(m.find(value)!=m.end()&amp;&amp;m[value]==key&amp;&amp;key!=value)&#123;</span><br><span class="line">				temp.clear();</span><br><span class="line">				temp.push_back(-sum);</span><br><span class="line">				temp.push_back(min(key,value));</span><br><span class="line">				temp.push_back(max(key,value));</span><br><span class="line">				solution.push_back(temp);</span><br><span class="line">				continue;</span><br><span class="line">			&#125;		</span><br><span class="line">			m[key]=value;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector &lt;int&gt; &gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">		vector&lt;vector&lt;int&gt; &gt; solution;</span><br><span class="line">        int i=0;</span><br><span class="line">		int len=nums.size();</span><br><span class="line">		sort(nums.begin(),nums.end());</span><br><span class="line">		int current;</span><br><span class="line">		//using two sum as the subroutine</span><br><span class="line">		for(i=0;i&lt;len-2;i++)&#123;</span><br><span class="line">			current=nums[i];</span><br><span class="line">        if(i!=0 &amp;&amp; current==nums[i-1])&#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			int inputsum=-current;</span><br><span class="line">			if (current==0)&#123;</span><br><span class="line">				inputsum=0;</span><br><span class="line">			&#125;</span><br><span class="line">			findsolutionbymap(i+1,len-1,i,inputsum,nums,solution);</span><br><span class="line">		&#125;</span><br><span class="line">		return solution;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3Sum-closest"><a href="#3Sum-closest" class="headerlink" title="3Sum closest"></a>3Sum closest</h4><p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For example, given array S = &#123;-1 2 1 -4&#125;, and target = 1.</span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure>
<p>就是三个数相加，和不断接近目标数，其实和上一个题目的思路有点类似，在求和的过程中，不断更新，由于题目中已经保证了有唯一的一组解，就保留最接近的那种就可以了。貌似很容易，代码也很简单，但是最后还是参考了别人写的。问题实质是转化为，如何在一个有序序列中找到a[i]+a[j]&#x3D;sum 使得 abs(sum-target)的值最小，这个还是基于两个指针的策略，但是要好好整理一下。</p>
<ul>
<li>输入序列本身是有序的序列，这个是保证2 sum 类的题目可以进行两边指针往中间遍历的前提。</li>
<li>遍历这个有序序列(从0号位置到len-3号位置)跳过重复的元素，设置left right两个指针, left 位置从当前元素的下一个开始一直到最后一个元素的位置为止 </li>
<li>在每一个subroutine里寻找符合条件的thee sum. temp&#x3D;a[curr]+a[left]+a[right] closet&#x3D;temp</li>
<li>while （left&lt;right） 更新 temp， 具体操作如下</li>
<li>if temp &#x3D;&#x3D; target 返回 temp a[left] a[right] 是所需寻找的值</li>
<li>if temp &lt; target left ++ 如果 abs(temp-target)&lt;abs(closet-target) (说明当前的 three sum的temp结果比记录中的还要更接近target，之后时候更新记录中的位置) closet&#x3D;temp 所有的情况都考虑的话可以有 left ++ &#x2F; – right ++&#x2F;– left – 没有意义，因为当前已经比较小了，想要找更大的元素只能left++。为什么不进行right++？因为right 指针所在的位置是从最右边开始往左边走的，当前right元素右边的可能情况都已经考虑过了，关键的几个细节一个是序列本身有序，一个是left right指针是从序列的两边往中间走。</li>
<li>if temp &gt; target right– 如果 abs(temp-target)&lt;abs(closet-target) closet&#x3D;temp<br>最后返回closet</li>
</ul>
<p>注意closet的持续更新，每次都要用temp-target和closet-target来进行比较，之后更新closet，有需要的话，还需要及时记录当时的left和right的位置，因为不可能靠移动一边的指针找到距离target最近的sum，总之这里要好好体会体会并且记会，属于基本套路了。</p>
<p>还要注意的是init的minValue不需要弄成<code>INT_MAX</code>，只需要弄成一个比较大的数字就好了，因为在比较的过程中还会进行 currsum-target的操作，如果弄成<code>INT_MAX</code>就容易溢出产生错误。</p>
<p>For the time complexity, it is still O(N^2) since the actual iteration opertaions is O(N-1+N-2 … 1) </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findsolution</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> nowindex, <span class="type">int</span> sum, vector&lt;<span class="type">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = left;</span><br><span class="line">        <span class="type">int</span> j = right;</span><br><span class="line">        <span class="type">int</span> closet = v[nowindex] + v[i] + v[j];</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = v[nowindex] + v[i] + v[j];</span><br><span class="line">            <span class="keyword">if</span> (temp == sum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; sum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(temp - sum) &lt; <span class="built_in">abs</span>(closet - sum))</span><br><span class="line">                &#123;</span><br><span class="line">                    closet = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; v[i] == v[i + <span class="number">1</span>]) i++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(temp - sum) &lt; <span class="built_in">abs</span>(closet - sum))</span><br><span class="line">                &#123;</span><br><span class="line">                    closet = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; v[j] == v[j - <span class="number">1</span>]) j--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> closet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> current;</span><br><span class="line">        <span class="type">int</span> lastmin = <span class="number">9999999</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            current = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; current == nums[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> min = <span class="built_in">findsolution</span>(i + <span class="number">1</span>, len - <span class="number">1</span>, i, target, nums);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(min - target) &lt; <span class="built_in">abs</span>(lastmin - target))</span><br><span class="line">            &#123;</span><br><span class="line">                lastmin = min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastmin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个是更简易的一个版本， 在subroutine中没有进行优化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findsolution</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> curr, <span class="type">int</span> target, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = left;</span><br><span class="line">        <span class="type">int</span> j = right;</span><br><span class="line">        <span class="comment">// closetSum can be initialized as curr sum</span></span><br><span class="line">        <span class="type">int</span> closestSum = nums[curr] + nums[i] + nums[j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// two pointer solution</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> currSum = nums[curr] + nums[i] + nums[j];</span><br><span class="line">            <span class="keyword">if</span> (currSum == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> currSum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (currSum &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// increase value</span></span><br><span class="line">                <span class="comment">// check if updating closest</span></span><br><span class="line">                <span class="comment">// TODO, adding another loop here for removing repeated element</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// currSum &gt; target</span></span><br><span class="line">                <span class="comment">// decrease value</span></span><br><span class="line">                <span class="comment">// TODO, adding another loop here for removing repeated element</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// check if updating current closestSum</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(currSum - target) &lt; <span class="built_in">abs</span>(closestSum - target))</span><br><span class="line">            &#123;</span><br><span class="line">                closestSum = currSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> closestSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sort array</span></span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> current;</span><br><span class="line">        <span class="comment">// this can not be the INT_MAX, since there is a lastmin-target option</span></span><br><span class="line">        <span class="type">int</span> lastmin = <span class="number">9999999</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            current = nums[i];</span><br><span class="line">            <span class="comment">// if element is same with previous one, move</span></span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; current == nums[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// left bounds is i+1, right bounds is len-1</span></span><br><span class="line">            <span class="type">int</span> min = <span class="built_in">findsolution</span>(i + <span class="number">1</span>, len - <span class="number">1</span>, i, target, nums);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// update the min if it is less than previous</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(min - target) &lt; <span class="built_in">abs</span>(lastmin - target))</span><br><span class="line">            &#123;</span><br><span class="line">                lastmin = min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastmin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3Sum-smaller"><a href="#3Sum-smaller" class="headerlink" title="3Sum smaller"></a>3Sum smaller</h4><p>这个题目开始收费了，参考了这里(<a target="_blank" rel="noopener" href="http://likesky3.iteye.com/blog/2236385)%EF%BC%9A">http://likesky3.iteye.com/blog/2236385)：</a><br>Given an array of n integers nums and a target, find the number of index triplets i, j, k with 0 &lt;&#x3D; i &lt; j &lt; k &lt; n that satisfy the condition nums[i] + nums[j] + nums[k] &lt; target.</p>
<p>For example, given nums &#x3D; [-2, 0, 1, 3], and target &#x3D; 2.</p>
<p>Return 2. Because there are two triplets which sums are less than 2:</p>
<p>[-2, 0, 1]<br>[-2, 0, 3]</p>
<p>大致分析一下，要求多组解，大致框架应该与上面的相同，先排序，再遍历（主要目的是固定一个数），再两指针选择。关键是两指针选择时候的技巧性：</p>
<ul>
<li>while (i&lt;j)</li>
<li>sum3&#x3D;nums[i]+nums[j]+num[now]</li>
<li>if (sum3&lt;target) ，由于序列已经是有序的，这个时候 nums[now]+nums[i]+nuns[j-1] 、nums[now]+nums[i]+nuns[j-2]… nums[now]+nums[i]+nums[i+1]这些组合都是符合要求的，所以符合要求的组合数目要加上 j-i 。相加之后让i后移一位。</li>
<li>if (sum3&gt;&#x3D;target) 这个时候就是往小移动，即 j–- 还要处理下重复的情况 如果 num[j]&#x3D;nums[j-1]的时候 也前移一下 放在一个while循环中 始终保持 i&lt;j</li>
</ul>
<h4 id="4-Sum"><a href="#4-Sum" class="headerlink" title="4 Sum"></a>4 Sum</h4><p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d &#x3D; target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p>Note:<br>Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)<br>The solution set must not contain duplicate quadruplets.<br>For example, given array S &#x3D; {1 0 -1 0 -2 2}, and target &#x3D; 0.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A solution set is:</span><br><span class="line">(-1,  0, 0, 1)</span><br><span class="line">(-2, -1, 1, 2)</span><br><span class="line">(-2,  0, 0, 2)</span><br></pre></td></tr></table></figure>
<p>背景与2Sum的形式一样，只不过由两个数变为4个数。最容易想到的一种就是转化为3Sum最后再转化为2Sum来解决。就是把外面的一重循环变成了两重循环。其实就是注意几个核心的操作，基本的框架是两指针，去重的操作怎么来，第一次循环的时候去重，用两指针寻找的时候也去重，一组解的时候怎么弄，多组解的时候怎么弄，还有vector的基本操作，比如排序这些，这些都弄好了，解决起来就比较容易了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	void findsolution(int left,int right,int index1,int index2,vector&lt;int&gt; &amp;v, int target,vector&lt;vector&lt;int&gt; &gt; &amp;solution)&#123;</span><br><span class="line">        int i=left;</span><br><span class="line">		int j=right;		</span><br><span class="line">		vector&lt;int&gt; temp;</span><br><span class="line">		int sum;</span><br><span class="line">		while(i&lt;j)&#123;</span><br><span class="line">			sum=v[index1]+v[index2]+v[i]+v[j];</span><br><span class="line">			if (sum==target)&#123;</span><br><span class="line">				temp.clear();</span><br><span class="line">				temp.push_back(v[index1]);</span><br><span class="line">				temp.push_back(v[index2]);</span><br><span class="line">				temp.push_back(v[i]);</span><br><span class="line">				temp.push_back(v[j]);</span><br><span class="line">				solution.push_back(temp);</span><br><span class="line">				while(i&lt;j&amp;&amp;v[i]==v[i+1])&#123;</span><br><span class="line">					i++;</span><br><span class="line">				&#125;</span><br><span class="line">				while(i&lt;j&amp;&amp;v[j]==v[j-1])&#123;</span><br><span class="line">					j--;</span><br><span class="line">				&#125;</span><br><span class="line">				i++;</span><br><span class="line">				j--;</span><br><span class="line">			&#125;else if(sum&lt;target)&#123;</span><br><span class="line">				i++;</span><br><span class="line">				</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">                j--;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt; &amp;nums, int target) &#123;</span><br><span class="line">		vector&lt;vector&lt;int&gt; &gt; solution;</span><br><span class="line">        int i=0,j=0;</span><br><span class="line">		int len=nums.size();</span><br><span class="line">		sort(nums.begin(),nums.end());</span><br><span class="line">        </span><br><span class="line">		//注意循环的时候两次去重</span><br><span class="line">		for(i=0;i&lt;len-3;i++)&#123;</span><br><span class="line">		    if (i!=0&amp;&amp;nums[i]==nums[i-1])&#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">		    </span><br><span class="line">			for(j=i+1;j&lt;len-2;j++)&#123;</span><br><span class="line">				if(j!=i+1&amp;&amp;nums[j]==nums[j-1])&#123;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;				</span><br><span class="line">				findsolution(j+1,len-1,i,j,nums,target,solution);</span><br><span class="line">			&#125;		</span><br><span class="line">		&#125;</span><br><span class="line">		return solution;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Substr-x2F-sub-sequence-related-questions"><a href="#Substr-x2F-sub-sequence-related-questions" class="headerlink" title="Substr&#x2F;sub sequence related questions"></a>Substr&#x2F;sub sequence related questions</h3><p>这个类型的问题的关键有两个一个是使用two pointer start from the same position, 另外一个就是using other metadata wisely. </p>
<p>metadata可能是map或者是其他的数组(比如Leetcode 3)</p>
<p>因为涉及到distinct element的问题，如果map中对应元素出现的frequency为1，那就是distinct的。map中的元素的个数可以用来判断subarray的长度，掌握好这些要点再解决起来这一类问题就会容易一些。关键是掌握如何描述对应subarray的性质。</p>
<h4 id="674-Longest-Continuous-Increasing-Subsequence"><a href="#674-Longest-Continuous-Increasing-Subsequence" class="headerlink" title="674. Longest Continuous Increasing Subsequence"></a>674. Longest Continuous Increasing Subsequence</h4><p>This is comparatively simple, the subsequence is continuous, we just check it gradually, if the subsequence continue increase, we increase the subsequence len, otherwise, we set it back to 1, and the subsequence then start from new value. We keep monitor the length of subsequnece and remember the largest one.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int maxLen = 0;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        if(size==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(size==1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int currLen = 1;</span><br><span class="line">        for(int i=1;i&lt;size;i++)&#123;</span><br><span class="line">            //if increasing</span><br><span class="line">            if(nums[i]&gt;nums[i-1])&#123;</span><br><span class="line">                currLen+=1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //the end of increase seq, reset</span><br><span class="line">                maxLen = max(maxLen, currLen); </span><br><span class="line">                //the new element is the start of the new substr</span><br><span class="line">                currLen = 1;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        //for the substr that ends at last position</span><br><span class="line">        maxLen = max(maxLen, currLen);</span><br><span class="line">        return maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a>300. Longest Increasing Subsequence</h4><p>Compared with previous one, this subsequence can be discontinuous. But the order of element is not changed, which means if element b is at the right side of the element a, element b continuous stay at the right side of element a.</p>
<p>This can be a classical one, it might be easier to come up with the dp based solution, and consider which element can contribute to the current answer. So for each new element, we might need to check all existing history before it to see the previous records that end with that. In that case, we can use the key of map as the value of the previous element, and the value of the map is the length of subsequence end with corresponding element. After finding a largest one, we can than add 1 based on that</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        //edge case</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        if(size==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(size==1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;int,int&gt; m;</span><br><span class="line">        int maxCount = 0;</span><br><span class="line">        for(int i=0;i&lt;size;i++)&#123;</span><br><span class="line">            //compare with each previous element</span><br><span class="line">            int maxCurrLen=1;</span><br><span class="line">            for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">                int currLen=1;</span><br><span class="line">                if(nums[j]&lt;nums[i])&#123;</span><br><span class="line">                    currLen=m[nums[j]]+1;</span><br><span class="line">                &#125;</span><br><span class="line">                maxCurrLen=max(maxCurrLen,currLen);</span><br><span class="line">            &#125;</span><br><span class="line">            //remember largest currLen</span><br><span class="line">            m[nums[i]]=maxCurrLen;</span><br><span class="line">            //keep track</span><br><span class="line">            maxCount=max(maxCount,maxCurrLen);</span><br><span class="line">        &#125;</span><br><span class="line">        //After going through all elements</span><br><span class="line">        return maxCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>However, it might be convenient to use a dp array to replace the map, the key of the map can be the index of the dp array. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        if(size==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(size==1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int rev = 0;</span><br><span class="line">        vector&lt;int&gt; dp(size,1);</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        for(int i=1;i&lt;size;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;=i-1;j++)&#123;</span><br><span class="line">                if(nums[i]&gt;nums[j])&#123;</span><br><span class="line">                    dp[i]=max(dp[i],dp[j]+1);    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rev = max(rev,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The next level of optimization is not easy to come up with. Instead of using linear searching in the second loop, we can try to find the associated element by binary search. Using divide and conqure to find element that is less than the current value. We need to dynamically update the dp array (The reason we can do this is that current solution is the sub structure of the end solution).</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        //edge case</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        if(size==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(size==1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; dp;</span><br><span class="line">        //push first element into array</span><br><span class="line">        dp.push_back(nums[0]);</span><br><span class="line">        //go through each subsequent array element</span><br><span class="line">        for(int i=1;i&lt;size;i++)&#123;</span><br><span class="line">            int L = 0;</span><br><span class="line">            int R = dp.size();</span><br><span class="line">            // for each new element, find one that is </span><br><span class="line">            // in the dp array and is close to mid from right side</span><br><span class="line">            while(L&lt;R)&#123;</span><br><span class="line">                int mid = (R+L)/2;</span><br><span class="line">                if(dp[mid]&lt;nums[i])&#123;</span><br><span class="line">                    L = mid+1;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    R = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //if not find, all existing elements is less than current one</span><br><span class="line">            //just put current one into array</span><br><span class="line">            if(R&gt;=dp.size())&#123;</span><br><span class="line">                dp.push_back(nums[i]);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                // otherwise, we find ont that is larger than current one</span><br><span class="line">                // from right side, we replace that element</span><br><span class="line">                // this is important, we might adding more possibilites by decreasing this value</span><br><span class="line">                dp[R] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="128-Longest-Consecutive-Sequence"><a href="#128-Longest-Consecutive-Sequence" class="headerlink" title="128. Longest Consecutive Sequence"></a>128. Longest Consecutive Sequence</h4><p>Be careful about the subset, substr or sub sequence. Understanding this question is a little bit tricky, we actually get a subset from the original sequence, the element in that subset can construct the increasing sequence, in the constructed sequence, the difference between each element is 1.</p>
<p>The original way is sorting and then ofter sorting, we basically change it to 674, but sorting need O(NlogN) time. The question requres O(N) time</p>
<p>This is a solution based on set, check this <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=P6RZZMu_maU">video</a> to get more ideas, the key point is to find the element which can be the start position of a new array and try to explore the maximal length it can reach by adding one gradually. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        //edge case</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        if(size==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(size==1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_set&lt;int&gt; s(nums.begin(),nums.end());</span><br><span class="line">        int maxCount= 0;</span><br><span class="line">        for(int i=0;i&lt;size;i++)&#123;</span><br><span class="line">            //if it is start of a sequence</span><br><span class="line">            if(s.find(nums[i]-1)==s.end())&#123;</span><br><span class="line">                int offset = 0;</span><br><span class="line">                //check next element</span><br><span class="line">                while (s.find(nums[i]+offset)!=s.end())&#123;</span><br><span class="line">                    //if next element is in</span><br><span class="line">                    offset=offset+1;</span><br><span class="line">                &#125;</span><br><span class="line">                //record offset</span><br><span class="line">                maxCount=max(maxCount,offset);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //After going through all elements</span><br><span class="line">        return maxCount;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Another approach is firstly use the previous subroutine (300) and then merge the results. If value map[nums[i]] exist, and its assocaited value is len1 &#x3D; map[nums[i]], then we try to look at if nums[i]-len also exist in map, if it exist, and the value is len2, then the element end with nums[i] is len1+len2, then we also move to the next element in map that is larger than nums[i]. Similarly, we can continue merge and find the largest one. By this way, we actually look at the ending of the subsequence and check the largest length it could be.</p>
<h4 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h4><p>Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1.</p>
<p>根本上讲还是两指针的问题，只不过两个指针在开始的时候是在同一个位置上的。需要额外的空间就是exist数组，用来存储该元素是否存在过。以及position，用来存储上一次出现的位置。注意还有可能是其他的字符，所以要0-128的存储空间，主要流程如下：</p>
<ul>
<li>一个while循环中 两个指针l,r初始位置都是0，或者用一个for loop 遍历right指针</li>
<li>当前字符没有出现过 ，r指针右移，更新position。</li>
<li>当前字符已经出现过 ，更新长度 ，记录position的位置，l指针移动到上次出现位置的下一个。注意限制条件，要上次的位置大于l的位置才能更新，比如 “eccebaad” 当遍历到第二个e的时候，position中记录的last位置为1，但是这个时候left指针已经移动到了c的位置，这个时候就不要更新了，不需要让left指针再往回退了。</li>
<li>最后r指针都向后移动一位。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        int l=0,r=0;</span><br><span class="line">        int len=s.length();</span><br><span class="line">        int exist[130];</span><br><span class="line">        int pos[130];</span><br><span class="line">        memset(exist,0,130*sizeof(int));</span><br><span class="line">        memset(pos,0,130*sizeof(int));</span><br><span class="line">        int maxlen=0;</span><br><span class="line">        for(int r=0;r&lt;len;r++)&#123;</span><br><span class="line">            //get curr elem</span><br><span class="line">            char curr = s[r];</span><br><span class="line">            //check metadata, to see if there is new substr len</span><br><span class="line">            //for the first time, last is 1</span><br><span class="line">            int lastPos = pos[curr];</span><br><span class="line">            if(exist[curr]==1 &amp;&amp; lastPos &gt;= l)&#123;</span><br><span class="line">                //left jump to the next pos of existing elements</span><br><span class="line">                //only when lastPos is larger than left</span><br><span class="line">                l=lastPos+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //not exist</span><br><span class="line">                int currlen = r-l+1;</span><br><span class="line">                maxlen=max(maxlen,currlen);</span><br><span class="line">            &#125;</span><br><span class="line">            //update meta</span><br><span class="line">            pos[curr]=r;</span><br><span class="line">            exist[curr]=1;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Longest-Substring-with-At-Most-Two-Distinct-Characters"><a href="#Longest-Substring-with-At-Most-Two-Distinct-Characters" class="headerlink" title="Longest Substring with At Most Two Distinct Characters"></a>Longest Substring with At Most Two Distinct Characters</h4><p>Given a string, find the length of the longest substring T that contains at most 2 distinct characters.<br>For example, Given s &#x3D; “eceba”,<br>T is “ece” which its length is 3.</p>
<p>注意与上一个题目的区别，上一个题目是没有一个重复的元素的最长序列，这个是说最长序列中允许有两个重复元素，注意对两种序列描述的时候的区别。</p>
<p>这个题目改收费的了，从网上看到了别人的解答，这个问题最一般的情况是 at most K Distinct Characters。整个框架还是一样的，说白了就是，两指针从头遍历，有点滑动窗口的意思，不断调整两个窗口的边界。此外还需要一个存储出现次数的count数组，关键是存储position的策略，比如 “ececebad” 这种，当k&#x3D;2的时候，当第三次到e的时候，l指针应该到第一个e后面的一个位置。这里就不太好存储位置了，因为如果有第四个e的时候，此时l要到第二个e的后一个位置，所以可以参考<a target="_blank" rel="noopener" href="http://www.cnblogs.com/x1957/p/4123301.html">这个</a>，对于k个位置的时候，要注意对k进行适当的分类。比如比如k&lt;0，以及s.size()&lt;k 这些情况要怎么处理。具体可以参考这个(<a target="_blank" rel="noopener" href="http://blog.csdn.net/martin_liang/article/details/45648985">http://blog.csdn.net/martin_liang/article/details/45648985</a>)</p>
<p>当count数目大于K的时候，l就向右移动，一直到对应的元素出现位置，之后count-1,之后l移动到这个元素的下一个位置就更新完成了，不用一个专门的position来存储位置信息。</p>
<p>或者用一个map来存储，key是对应的元素值，value是这个元素出现的次数。简化之后可以使用string来存储。The index of this question is lintcode 928. Be careful of processing the deletion of the map. If the current element does not exist after moving the left pointer, then removing it from the map. Using the size of the map to adjust the number of distinguished elements in the substr.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; exist;</span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> strLen = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;strLen;j++)&#123;</span><br><span class="line">            <span class="comment">//for each new position j</span></span><br><span class="line">            exist[s[j]]++;</span><br><span class="line">            <span class="keyword">while</span>(exist.<span class="built_in">size</span>()&gt;<span class="number">2</span> &amp;&amp; i&lt;j)&#123;</span><br><span class="line">                <span class="comment">//move i</span></span><br><span class="line">                <span class="keyword">if</span>(exist[s[i]]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    exist[s[i]]--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//when frequency of s[i] is 0, after decreasing the key value</span></span><br><span class="line">                <span class="keyword">if</span> (exist[s[i]]==<span class="number">0</span>)&#123;</span><br><span class="line">                    exist.<span class="built_in">erase</span>(s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLen=<span class="built_in">max</span>(maxLen,j-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Longest-Substring-with-At-Most-K-Distinct-Characters"><a href="#Longest-Substring-with-At-Most-K-Distinct-Characters" class="headerlink" title="Longest Substring with At Most K Distinct Characters"></a>Longest Substring with At Most K Distinct Characters</h4><p>Lintcode 386, the general case for the previous one.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(string &amp;s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; exist;</span><br><span class="line">        <span class="comment">//some edge cases</span></span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span> || k&lt;<span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span> &amp;&amp; k==<span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">        <span class="type">int</span> maxc=<span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;len; j++)&#123; </span><br><span class="line">            exist[s[j]]++;</span><br><span class="line">            <span class="comment">//when pointer position is valid</span></span><br><span class="line">            <span class="comment">//or at the last position, k can be a large number</span></span><br><span class="line">            <span class="keyword">while</span>(exist.<span class="built_in">size</span>()&gt;k &amp;&amp; i&lt;j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(exist[s[i]]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    exist[s[i]]--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//after map value decrease to zero</span></span><br><span class="line">                <span class="keyword">if</span>(exist[s[i]]==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//the key still exist if we do not remove </span></span><br><span class="line">                    <span class="comment">//the map size will be wrong</span></span><br><span class="line">                    exist.<span class="built_in">erase</span>(s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//update max count</span></span><br><span class="line">            <span class="keyword">if</span>(j-i + <span class="number">1</span>&gt; maxc)&#123;maxc=j-i + <span class="number">1</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="992-Number-of-subarray-with-exact-K-different-elements"><a href="#992-Number-of-subarray-with-exact-K-different-elements" class="headerlink" title="992. Number of subarray with exact K different elements"></a>992. Number of subarray with exact K different elements</h4><p>This is a really tricky one, instead of computing the substr with k different elements direactly, we use another subroutine. The number of substr that have most k distinct elements. If we call this substr as AtMost(k), then the number of subarray with exact k different element equals to AtMostK(k)-AtMost(k-1)</p>
<p>One easy task for this question is to consider how many subarray is added once we add a new element. From right side to left side, assuming left pointer is i and right pointer is j, assuming element at j is new added one and satisfy the condition of subarray, the new added number of subarry is j-i+1.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findAtMostK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; exist;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span> &amp;&amp; k==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> maxlen=<span class="number">0</span>; </span><br><span class="line">        <span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;len; j++)&#123; </span><br><span class="line">            exist[nums[j]]++;</span><br><span class="line">            <span class="comment">//when pointer position is valid</span></span><br><span class="line">            <span class="comment">//or at the last position, k can be a large number</span></span><br><span class="line">            <span class="comment">//maybe after moving right multiple times</span></span><br><span class="line">            <span class="comment">//the condition can be satisfied</span></span><br><span class="line">            <span class="comment">//we move right when the left can not move further</span></span><br><span class="line">            <span class="keyword">while</span>(exist.<span class="built_in">size</span>()&gt;k &amp;&amp; i&lt;j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(exist[nums[i]]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    exist[nums[i]]--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(exist[nums[i]]==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//the key still exist if we do not remove </span></span><br><span class="line">                    <span class="comment">//the map size will be wrong</span></span><br><span class="line">                    exist.<span class="built_in">erase</span>(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//at this point the map size is equal or less than k</span></span><br><span class="line">            <span class="comment">//when not across the threshold, we add elements</span></span><br><span class="line">            c=c+j-i+<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> c1 = <span class="built_in">findAtMostK</span>(nums,k);</span><br><span class="line">        <span class="type">int</span> c2 = <span class="built_in">findAtMostK</span>(nums,k<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//printf(&quot;c1 c2 %d %d\n&quot;,c1,c2);</span></span><br><span class="line">        <span class="keyword">return</span> c1-c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This is a good explanation about this question<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=akwRFY2eyXs&amp;t=2s">https://www.youtube.com/watch?v=akwRFY2eyXs&amp;t=2s</a></p>
<h4 id="560-Number-of-subarray-with-sum-equals-to-K"><a href="#560-Number-of-subarray-with-sum-equals-to-K" class="headerlink" title="560 Number of subarray with sum equals to K"></a>560 Number of subarray with sum equals to K</h4><p>This is a good explanation, this is a good question<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=HbbYPQc-Oo4">https://www.youtube.com/watch?v=HbbYPQc-Oo4</a></p>
<p>The naive strategy is to go through all possibilites of the array, there is O(N^2) combinations, for each combination, then accumulate the element from i to j which need O(N), so the total time complexity is O(N^3)</p>
<p>When there are reqquirements for computing the sum of a subarray, an important trick is to use the prefix sum, which decrease the O(N) to O(1) for computing the subarray, subarraySum(i,j)&#x3D;PrefixSum(j)-PrefixSum(i-1). By this way, we can decrease the time complexity to O(N^2) based on prefix  sum.</p>
<p>It is easy to figure out this is the 2 sum question based on the prefixsum, if T &#x3D; subArraySum(i,j) &#x3D; PreSum(j)-PreSum(i-1), we can use a frequency map. For each time we go through an element, we want to find T&#x3D; x - Psum(curr), x is an unknown variable (we need to store this as key value of the map), if the current position is the left start of an array that satisfies requirements, we can definately find an Psum(i) &#x3D; x in the subsequent iteration of the array. Then we can use a frequency map to store this relationship, let map(x) &#x3D; map(x)+1. (map(x) is zero if the x is not exist previously.) So each time we find a new go to a new element, we can get the PreSum for current position and look at this frequency map, if there is specific key, it means that current element can be the right side of specific subarray. The key in the map represent the required a PreSumValue to construct a subarray that satisfies condition, the value in the map represent the number of element that require this type of PrefixSum. This question only ask us to return the number of subarrya, if it ask as to return specific i and j position, the value of map should be a vector since there might be multiple elements require same PrefixSum.</p>
<p>The code is simple, but the ideas behind it is definately not simple.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; freq;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//init first one</span></span><br><span class="line">        <span class="type">int</span> psum=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//start from zero position</span></span><br><span class="line">        freq[k]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len;j++)&#123;</span><br><span class="line">            <span class="comment">//for each new j, update psum</span></span><br><span class="line">            psum=psum+nums[j];</span><br><span class="line">            <span class="keyword">if</span>(freq.<span class="built_in">count</span>(psum)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                count=count+freq[psum];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//update freq map</span></span><br><span class="line">            <span class="type">int</span> need=k+psum;</span><br><span class="line">            freq[need]=(freq[need]+<span class="number">1</span>);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/images/DebugExample.png" width="600"/>

<p>This figure illustrates a good habits to debug and analysis how the algorithm work in mind. The vertical line represents the stack from the bottom to top, the horizental line represents the steps, such as before while loop and after while loop, this framework can clearly list value of key elements at each step, and help us to debug code easily.</p>
<p>For example, by analysing the depedency, we can see that we only use one variable to keep the prefixsum. </p>
<h4 id="53-Maximum-continuous-Subarray"><a href="#53-Maximum-continuous-Subarray" class="headerlink" title="53. Maximum continuous Subarray"></a>53. Maximum continuous Subarray</h4><p>The idea is to maintain the left side pointer and right side pointer to make sure there sum is the largest one. The O(N) idea is not easy to come up with (but it is actually a pretty straightforward one). We just need to figure out the principle to update the left and right pointer. For updaing the right pointer, for a new element, we may try to add it to our subarray, when the current sum is larger than record, we update right side index. If we find that after adding the value to the array is not good compared with using current value as a new subarray its self, namely the currSum&lt;num[i], we can update the left side pointer and let it starts from the element of the position i.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> updatedLeft=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> updatedRight=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//if adding current element</span></span><br><span class="line">            curSum=curSum+nums[i];</span><br><span class="line">            <span class="comment">//using the current value as a start position</span></span><br><span class="line">            <span class="comment">//have more benifits than previous substr sum plus current element</span></span><br><span class="line">            <span class="comment">//then update the left side window</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;curSum)&#123;</span><br><span class="line">                curSum=nums[i];</span><br><span class="line">                updatedLeft=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//if new result is larger than existing maximal position</span></span><br><span class="line">            <span class="comment">//update right side</span></span><br><span class="line">            <span class="keyword">if</span>(curSum&gt;=maxSum)&#123;</span><br><span class="line">                maxSum=curSum;</span><br><span class="line">                updatedRight=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;updatedLeft %d updatedRight %d\n&quot;</span>,updatedLeft,updatedRight);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>It might interesting to go from scratch to see what if we can not come up with previous solutions and how we go from simple to compilated case. (This is a sample question in 计算之魂)</p>
<p>Naive solution, how many combination of left pointer and right pointer, then computing each sub sum and find one that is largest. O(N^3)</p>
<p>We may come up with a prefix sum data structure to help to find the subrange between i and j, by this case, we can decrease time complaxity to O(N^2)</p>
<p>The binary search solution is actually easy to come up with but hard to implement and thinking clearly. The correct solution can be at the left side of the middle, right side of middle position or the middle is in that range. The clever part is that if we know the middle element is in the range, then we go through from mid-1 to l and mid+1 to r, and keep updating the l label and right label when the the sum is updaetd, then we can get the correct new range. The time complexity becomes O(NlogN) in this case.</p>
<p>This is one sample answer</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;l &quot; &lt;&lt; l &lt;&lt; &quot; r &quot; &lt;&lt; r &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// edge case</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// mid in solution</span></span><br><span class="line">    <span class="type">int</span> maxmidSum = nums[mid];</span><br><span class="line">    <span class="type">int</span> tempSum = maxmidSum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range left</span></span><br><span class="line">    <span class="keyword">if</span> (mid - <span class="number">1</span> &gt;= l) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = mid - <span class="number">1</span>; i &gt;= l; i--) &#123;</span><br><span class="line">        tempSum = tempSum + nums[i];</span><br><span class="line">        maxmidSum = <span class="built_in">max</span>(tempSum, maxmidSum);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range right</span></span><br><span class="line">    <span class="keyword">if</span> (mid + <span class="number">1</span> &lt;= r) &#123;</span><br><span class="line">      tempSum = maxmidSum;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        tempSum = tempSum + nums[i];</span><br><span class="line">        maxmidSum = <span class="built_in">max</span>(tempSum, maxmidSum);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mid element not in solution</span></span><br><span class="line">    <span class="type">int</span> maxLspan = INT_MIN, maxRspan = INT_MIN;</span><br><span class="line">    <span class="keyword">if</span> (mid - <span class="number">1</span> &gt;= l) &#123;</span><br><span class="line">      maxLspan = <span class="built_in">helper</span>(l, mid - <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid + <span class="number">1</span> &lt;= r) &#123;</span><br><span class="line">      maxRspan = <span class="built_in">helper</span>(mid + <span class="number">1</span>, r, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(maxLspan, maxRspan), maxmidSum);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(<span class="number">0</span>, size - <span class="number">1</span>, nums);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The linear based algorithm is based on greedy strategy(<a target="_blank" rel="noopener" href="https://blog.csdn.net/Fuyuan2022/article/details/125664402">https://blog.csdn.net/Fuyuan2022/article/details/125664402</a>)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/15/Algorithm-7-hash-table-and-two-pointers-1/" data-id="clqelxoyz0007mzjrgg0m0kab" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
 
<script src="/jquery/jquery.min.js"></script>

  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2019/06/15/golang-struct-using-tips/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          Golang struct using tips
        
      </div>
    </a>
  
  
    <a href="/2019/06/15/algorithm-6-two-numbers-sum-and-multiply/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Algorithm(6) two numbers sum and multiply(By solution)</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pointer-from-two-sides"><span class="toc-number">1.</span> <span class="toc-text">Pointer from two sides</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-Container-With-Most-Water"><span class="toc-number">1.1.</span> <span class="toc-text">11 Container With Most Water</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42-Trapping-Rain-Water"><span class="toc-number">1.2.</span> <span class="toc-text">42 Trapping Rain Water</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#125-Valid-Palindrome"><span class="toc-number">1.3.</span> <span class="toc-text">125. Valid Palindrome</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#917-Reverse-Only-Letters"><span class="toc-number">1.4.</span> <span class="toc-text">917. Reverse Only Letters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Other-simple-cases"><span class="toc-number">1.5.</span> <span class="toc-text">Other simple cases</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pointer-of-two-arrays"><span class="toc-number">2.</span> <span class="toc-text">Pointer of two arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#455-Assign-Cookies"><span class="toc-number">2.1.</span> <span class="toc-text">455. Assign Cookies</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#925-Long-Pressed-Name"><span class="toc-number">2.2.</span> <span class="toc-text">925. Long Pressed Name</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#986-Interval-List-Intersections"><span class="toc-number">2.3.</span> <span class="toc-text">986. Interval List Intersections</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K-sum"><span class="toc-number">3.</span> <span class="toc-text">K sum</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#two-sum-1"><span class="toc-number">3.1.</span> <span class="toc-text">two sum (1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#167-Two-Sum-II-Input-Array-Is-Sorted"><span class="toc-number">3.2.</span> <span class="toc-text">167. Two Sum II - Input Array Is Sorted</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3Sum-15"><span class="toc-number">3.3.</span> <span class="toc-text">3Sum(15)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3Sum-closest"><span class="toc-number">3.4.</span> <span class="toc-text">3Sum closest</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3Sum-smaller"><span class="toc-number">3.5.</span> <span class="toc-text">3Sum smaller</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Sum"><span class="toc-number">3.6.</span> <span class="toc-text">4 Sum</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Substr-x2F-sub-sequence-related-questions"><span class="toc-number">4.</span> <span class="toc-text">Substr&#x2F;sub sequence related questions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#674-Longest-Continuous-Increasing-Subsequence"><span class="toc-number">4.1.</span> <span class="toc-text">674. Longest Continuous Increasing Subsequence</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#300-Longest-Increasing-Subsequence"><span class="toc-number">4.2.</span> <span class="toc-text">300. Longest Increasing Subsequence</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#128-Longest-Consecutive-Sequence"><span class="toc-number">4.3.</span> <span class="toc-text">128. Longest Consecutive Sequence</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Longest-Substring-Without-Repeating-Characters"><span class="toc-number">4.4.</span> <span class="toc-text">3. Longest Substring Without Repeating Characters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Longest-Substring-with-At-Most-Two-Distinct-Characters"><span class="toc-number">4.5.</span> <span class="toc-text">Longest Substring with At Most Two Distinct Characters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Longest-Substring-with-At-Most-K-Distinct-Characters"><span class="toc-number">4.6.</span> <span class="toc-text">Longest Substring with At Most K Distinct Characters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#992-Number-of-subarray-with-exact-K-different-elements"><span class="toc-number">4.7.</span> <span class="toc-text">992. Number of subarray with exact K different elements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#560-Number-of-subarray-with-sum-equals-to-K"><span class="toc-number">4.8.</span> <span class="toc-text">560 Number of subarray with sum equals to K</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#53-Maximum-continuous-Subarray"><span class="toc-number">4.9.</span> <span class="toc-text">53. Maximum continuous Subarray</span></a></li></ol></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2023 zhe&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;godenwangzhe@gmail.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  



 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>