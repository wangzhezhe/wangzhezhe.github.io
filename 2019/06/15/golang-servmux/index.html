<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>golang servmux | AverageMind</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="主要是介绍golang中servermux的相关内容，还有一些在golang中的http的基本知识，最后还大致介绍了go-restful的库。整体上想的话，步骤应该是比较简单的，首先写好对应的路由要执行的函数，之后就是把路由信息注册到某个地方，信息过来再分发给对应的路由。">
<meta property="og:type" content="article">
<meta property="og:title" content="golang servmux">
<meta property="og:url" content="http://yoursite.com/2019/06/15/golang-servmux/index.html">
<meta property="og:site_name" content="AverageMind">
<meta property="og:description" content="主要是介绍golang中servermux的相关内容，还有一些在golang中的http的基本知识，最后还大致介绍了go-restful的库。整体上想的话，步骤应该是比较简单的，首先写好对应的路由要执行的函数，之后就是把路由信息注册到某个地方，信息过来再分发给对应的路由。">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-06-15T16:22:00.528Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="golang servmux">
<meta name="twitter:description" content="主要是介绍golang中servermux的相关内容，还有一些在golang中的http的基本知识，最后还大致介绍了go-restful的库。整体上想的话，步骤应该是比较简单的，首先写好对应的路由要执行的函数，之后就是把路由信息注册到某个地方，信息过来再分发给对应的路由。">
  
    <link rel="alternate" href="/atom.xml" title="AverageMind" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-165927341-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AverageMind</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Writing is nature&#39;s way of letting you know how sloppy your thinking is.</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-golang-servmux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/15/golang-servmux/" class="article-date">
  <time datetime="2019-06-15T16:14:52.000Z" itemprop="datePublished">2019-06-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/golang/">golang</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      golang servmux
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>主要是介绍golang中servermux的相关内容，还有一些在golang中的http的基本知识，最后还大致介绍了go-restful的库。整体上想的话，步骤应该是比较简单的，首先写好对应的路由要执行的函数，之后就是把路由信息注册到某个地方，信息过来再分发给对应的路由。</p>
<a id="more"></a>
<p>其实本质上了解就是很简单的，当代码结构变得复杂的时候，转发的工作就变得复杂了，这一部分的工作就要单独提取出来做了，这个功能就是由servermux来完成的。</p>
<p>这大概就是项目中的分层的思想，就像社会分工一样，只有术业专攻，各尽其职，整个系统才能正常运行，感觉算是某种系统观吧，当系统足够复杂的时候，就需要将单独的某一层拆分出来。</p>
<p>主要是围绕golang的net/http包来进行分析。</p>
<h3 id="简易的http服务"><a href="#简易的http服务" class="headerlink" title="简易的http服务"></a>简易的http服务</h3><p>首先让我们从一个最基本的http服务来入手，之后顺藤摸瓜，看看各个关键结构的定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">	&quot;io&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line">type a struct&#123;&#125;</span><br><span class="line">func (*a) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	io.WriteString(w, &quot;hello world version 1.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	err := http.ListenAndServe(&quot;:8080&quot;, &amp;a&#123;&#125;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信这个例子基本上一看就懂了，这个服务监听8080端口，之后在main函数中，调用http.ListenAndServer函数，监听8080端口。第二个参数是一个自定义的结构 a 的实例，我们进入ListenAndServer中来看一下其定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func ListenAndServe(addr string, handler Handler) error &#123;</span><br><span class="line">	server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">	return server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，第一个参数addr是一个string，第二个参数handler是一个Handler结构，之后把这两个参数分别传入到Server结构中，再调用这个Server结构的ListenAndServe()方法。</p>
<p>接着我们看一下Handler接口的的定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Handler interface &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>明白的看到，只要是实现了ServeHTTP方法的实例就实现了Handler接口，可以作为ListenAndServer的第二个参数传入。这个ServeHTTP的两个参数就是web服务中典型的request以及response的那种形式。其中request是一个实际的结构，而response是一个接口。</p>
<p>之后我们来看一下Server结构，这个结构定义了运行一个Http服务的相关的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">type Server struct &#123;</span><br><span class="line">	Addr           string        // TCP address to listen on, &quot;:http&quot; if empty</span><br><span class="line">	Handler        Handler       // handler to invoke, http.DefaultServeMux if nil</span><br><span class="line">	ReadTimeout    time.Duration // maximum duration before timing out read of the request</span><br><span class="line">	WriteTimeout   time.Duration // maximum duration before timing out write of the response</span><br><span class="line">	MaxHeaderBytes int           // maximum size of request headers, DefaultMaxHeaderBytes if 0</span><br><span class="line">	TLSConfig      *tls.Config   // optional TLS config, used by ListenAndServeTLS</span><br><span class="line">	// TLSNextProto optionally specifies a function to take over</span><br><span class="line">	// ownership of the provided TLS connection when an NPN</span><br><span class="line">	// protocol upgrade has occurred.  The map key is the protocol</span><br><span class="line">	// name negotiated. The Handler argument should be used to</span><br><span class="line">	// handle HTTP requests and will initialize the Request&apos;s TLS</span><br><span class="line">	// and RemoteAddr if not already set.  The connection is</span><br><span class="line">	// automatically closed when the function returns.</span><br><span class="line">	TLSNextProto map[string]func(*Server, *tls.Conn, Handler)</span><br><span class="line">	// ConnState specifies an optional callback function that is</span><br><span class="line">	// called when a client connection changes state. See the</span><br><span class="line">	// ConnState type and associated constants for details.</span><br><span class="line">	ConnState func(net.Conn, ConnState)</span><br><span class="line">	// ErrorLog specifies an optional logger for errors accepting</span><br><span class="line">	// connections and unexpected behavior from handlers.</span><br><span class="line">	// If nil, logging goes to os.Stderr via the log package&apos;s</span><br><span class="line">	// standard logger.</span><br><span class="line">	ErrorLog *log.Logger</span><br><span class="line">	disableKeepAlives int32 // accessed atomically.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前在这个例子中，我们就先深入到这个程度，只要知道在最后的server.ListenAndServe()中，server的Handler参数的serverHTTP方法会被调用就可以了，当然还做了许多额外的操作，具体细节先不做分析，。就是从server.ListenAndServer到handler的ServerHTTP方法被调用的这个过程暂不分析。只需要知道ServerHTTP方法被调用了就好。</p>
<h3 id="使用serverMux"><a href="#使用serverMux" class="headerlink" title="使用serverMux"></a>使用serverMux</h3><p>之前的那个例子就像是学会了1+1=2一样，但是实际情况并没有那么简单，要是100个1相加该怎么办？还用之前的套路未免就太过原始了。越深入思考就越离本质更靠近一些。之前的思路，用一个函数来处理所有的路由情况。不论什么样的路由请求过来之后，都要去执行实例a的ServeHTTP方法，这样，实际情况下，要处理多路由的时候，ServeHTTP就要写成类似下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func (*a) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    path := r.URL.String()</span><br><span class="line">    switch path &#123;</span><br><span class="line">    case &quot;/&quot;:</span><br><span class="line">        io.WriteString(w, &quot;&lt;h1&gt;root&lt;/h1&gt;&lt;a href=\&quot;abc\&quot;&gt;abc&lt;/a&gt;&quot;)</span><br><span class="line">    case &quot;/abc&quot;:</span><br><span class="line">        io.WriteString(w, &quot;&lt;h1&gt;abc&lt;/h1&gt;&lt;a href=\&quot;/\&quot;&gt;root&lt;/a&gt;&quot;)</span><br><span class="line">    case &quot;/def&quot;:</span><br><span class="line">        io.WriteString(w, &quot;&lt;h1&gt;abc&lt;/h1&gt;&lt;a href=\&quot;/\&quot;&gt;root&lt;/a&gt;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的情况下。看起来这样是可以的，如果路由很复杂呢，甚至还要分层呢？很容易想到空间换时间的思路，肯定需要一个结构把路由和对应的应该执行的函数的映射关系存起来，然后每有一个路由过来，就由一个服务去在映射关系中进行匹配，找到对应的函数去执行，再返回结果。这就用到了serverMux结构。</p>
<p>serverMux的主要功能就是对发送过来的http请求进行分发，之后调用对应的handler来处理请求。</p>
<p>可以看一下serverMux以及其中的muxEntry的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type ServeMux struct &#123;</span><br><span class="line">	mu    sync.RWMutex</span><br><span class="line">	m     map[string]muxEntry</span><br><span class="line">	hosts bool // whether any patterns contain hostnames</span><br><span class="line">&#125;</span><br><span class="line">type muxEntry struct &#123;</span><br><span class="line">	explicit bool</span><br><span class="line">	h        Handler</span><br><span class="line">	pattern  string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，ServeMux中的m用于存储映射关系，key值为一个string，value值为一个muxEntry结构，其中包含Handler对象。</p>
<p>之后我们为之前的server加上新的ServeMux的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">	&quot;io&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line">type a struct&#123;&#125;</span><br><span class="line">type b struct&#123;&#125;</span><br><span class="line">func (*a) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	//log.Println(&quot;the request url&quot;, r.RequestURI)</span><br><span class="line">	//log.Println(&quot;r.Method&quot;, r.Method)</span><br><span class="line">	io.WriteString(w, &quot;hello world by mux the route is /a.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func (*b) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	io.WriteString(w, &quot;hello world by mux the route is /b.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	//往mux中注册新的路由</span><br><span class="line">	mux.Handle(&quot;/a&quot;, &amp;a&#123;&#125;)</span><br><span class="line">	mux.Handle(&quot;/b&quot;, &amp;b&#123;&#125;)</span><br><span class="line">	//开启服务 具体的路由操作由 新生成的mux来负责</span><br><span class="line">	err := http.ListenAndServe(&quot;:8080&quot;, mux)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照之前的分析，首先应该通过mux.Handler方法把路由注册进来，还可以看到，ListenAndServer之前填入Handler实例的地方现在变成了mux实例，说明mux应该也实现了Handler接口的serverHTTP方法。首先来看一下mux.Handle方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func (mux *ServeMux) Handle(pattern string, handler Handler) &#123;</span><br><span class="line">	mux.mu.Lock()</span><br><span class="line">	defer mux.mu.Unlock()</span><br><span class="line">	if pattern == &quot;&quot; &#123;</span><br><span class="line">		panic(&quot;http: invalid pattern &quot; + pattern)</span><br><span class="line">	&#125;</span><br><span class="line">	if handler == nil &#123;</span><br><span class="line">		panic(&quot;http: nil handler&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if mux.m[pattern].explicit &#123;</span><br><span class="line">		panic(&quot;http: multiple registrations for &quot; + pattern)</span><br><span class="line">	&#125;</span><br><span class="line">	mux.m[pattern] = muxEntry&#123;explicit: true, h: handler, pattern: pattern&#125;</span><br><span class="line">	if pattern[0] != &apos;/&apos; &#123;</span><br><span class="line">		mux.hosts = true</span><br><span class="line">	&#125;</span><br><span class="line">	// Helpful behavior:</span><br><span class="line">	// If pattern is /tree/, insert an implicit permanent redirect for /tree.</span><br><span class="line">	// It can be overridden by an explicit registration.</span><br><span class="line">	n := len(pattern)</span><br><span class="line">	if n &gt; 0 &amp;&amp; pattern[n-1] == &apos;/&apos; &amp;&amp; !mux.m[pattern[0:n-1]].explicit &#123;</span><br><span class="line">		// If pattern contains a host name, strip it and use remaining</span><br><span class="line">		// path for redirect.</span><br><span class="line">		path := pattern</span><br><span class="line">		if pattern[0] != &apos;/&apos; &#123;</span><br><span class="line">			// In pattern, at least the last character is a &apos;/&apos;, so</span><br><span class="line">			// strings.Index can&apos;t be -1.</span><br><span class="line">			path = pattern[strings.Index(pattern, &quot;/&quot;):]</span><br><span class="line">		&#125;</span><br><span class="line">		mux.m[pattern[0:n-1]] = muxEntry&#123;h: RedirectHandler(path, StatusMovedPermanently), pattern: pattern&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，Handle方法首先会把传入的pattern参数以及Handler接口存入到mux的map中，并且进行一些检测，比如该路由是否已经注册进来（explicit参数），handle是否为空等等。之后会判断pattern[0]是否为’/‘，如果不是的话，说明传过来的pattern可能有包含了主机的名称（这个还是不太明确，不知道什么时候会出现这种请情况）。此外还进行了一些额外的操作，比如把名称为 /path/ 的路由重定向到 /path 上面 。</p>
<p>之后再来看一下http.ListenAndServer的时候，mux的ServerHTTP方法是如何进行操作的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">	if r.RequestURI == &quot;*&quot; &#123;</span><br><span class="line">		if r.ProtoAtLeast(1, 1) &#123;</span><br><span class="line">			w.Header().Set(&quot;Connection&quot;, &quot;close&quot;)</span><br><span class="line">		&#125;</span><br><span class="line">		w.WriteHeader(StatusBadRequest)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	h, _ := mux.Handler(r)</span><br><span class="line">	h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line">func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) &#123;</span><br><span class="line">	if r.Method != &quot;CONNECT&quot; &#123;</span><br><span class="line">		if p := cleanPath(r.URL.Path); p != r.URL.Path &#123;</span><br><span class="line">			_, pattern = mux.handler(r.Host, p)</span><br><span class="line">			url := *r.URL</span><br><span class="line">			url.Path = p</span><br><span class="line">			return RedirectHandler(url.String(), StatusMovedPermanently), pattern</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return mux.handler(r.Host, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line">// handler is the main implementation of Handler.</span><br><span class="line">// The path is known to be in canonical form, except for CONNECT methods.</span><br><span class="line">func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) &#123;</span><br><span class="line">	mux.mu.RLock()</span><br><span class="line">	defer mux.mu.RUnlock()</span><br><span class="line">	// Host-specific pattern takes precedence over generic ones</span><br><span class="line">	if mux.hosts &#123;</span><br><span class="line">		h, pattern = mux.match(host + path)</span><br><span class="line">	&#125;</span><br><span class="line">	if h == nil &#123;</span><br><span class="line">		h, pattern = mux.match(path)</span><br><span class="line">	&#125;</span><br><span class="line">	if h == nil &#123;</span><br><span class="line">		h, pattern = NotFoundHandler(), &quot;&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到比较关键的两句:<code>h,_:=mux.Handler(r)</code>会根据request来返回一个合适的handler，之后调用这个返回回来的handler的ServerHTTP方法，进行具体的执行，这一段就相当于是一个分发request请求的作用了。再看一下后面的Handler的方法，如果r.Method不是<code>CONNECT</code>的时候，就调用mux.handler函数，这个函数会去具体执行匹配操作，最后返回对应的handler实例。之后会调用这个实例的ServeHTTP方法，执行真正的对应的最底层的操作。举一个极端的例子，比如有好多组件都声称自己执行的是调用数据库的操作，实际真正的操作可能是最后一个组件执行，前面几个组件只是负责转发，由于项目很大，并且为了方便扩展，就需要分层，分层之后必然虽然顶层结构清晰了，但一层一层包装下来，请求转发的工作也需要专门有组件来负责，就是将请求转到合适的下一个组件去执行。</p>
<h3 id="serverMux中的HandleFunc方法"><a href="#serverMux中的HandleFunc方法" class="headerlink" title="serverMux中的HandleFunc方法"></a>serverMux中的HandleFunc方法</h3><p>在上面的几个基本例子中，虽然我们自定义了结构体，但是只为了实现Handler接口，并没有添加什么个性化的操作，当然实际情况中并不总是像这样简单，但是从框架的角度讲，我们最终希望实现的是，能直接把一个方法注册给一个接口。实时上这就是HandleFunc方法所做的，看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">	&quot;io&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">	http.HandleFunc(&quot;/&quot;, sayhello)</span><br><span class="line">	http.ListenAndServe(&quot;:8080&quot;, nil)</span><br><span class="line">&#125;</span><br><span class="line">func sayhello(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	io.WriteString(w, &quot;hello world by handlefunc&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们直接通过HandleFunc方法把自己写的sayhello方法注册到了”/“的路由下，内部实现起来，无非就是程序自己帮我们生成了一个ServMux实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) &#123;</span><br><span class="line">	DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的DefaultServeMux是系统帮我们默认生成的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// DefaultServeMux is the default ServeMux used by Serve.</span><br><span class="line">var DefaultServeMux = NewServeMux()</span><br></pre></td></tr></table></figure>
<p>之后按照上面的分析，还会执行mux.Handler方法，只不过此时的Mux是系统自动帮我们new出来的，本质上和之前的是一样的。</p>
<h3 id="项目中的例子-关于go-rest"><a href="#项目中的例子-关于go-rest" class="headerlink" title="项目中的例子 关于go-rest"></a>项目中的例子 关于go-rest</h3><p>其他还用到比较流行的golang 中的 router 或者 api dispatcher的库比如gorilla/mux也都比较容易上手，这里就不再赘述。</p>
<p>在实际项目中，比如k8s的apiserver中，并没有像上面介绍的那么简单，为了实现路由注册时候的分层，还是有一些额外的工作要坐的，因此常常会用到各种框架，k8s的apiserver中用到的是go-restful的工具。</p>
<p>go-restful本质上来说就是对上面提到的serverMux的进一步封装，再起基础上又做了许多额外的工作。相当于对路由进行了分类，每次往HandleFunc中注册过去的路由都是一个新的类别，里面可能包含许多具体的CURD子路由。</p>
<p>比如下面这个例子(<a href="https://github.com/emicklei/go-restful/blob/master/examples/restful-user-resource.go)：" target="_blank" rel="noopener">https://github.com/emicklei/go-restful/blob/master/examples/restful-user-resource.go)：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">	&quot;strconv&quot;</span><br><span class="line">	&quot;github.com/emicklei/go-restful&quot;</span><br><span class="line">	&quot;github.com/emicklei/go-restful/swagger&quot;</span><br><span class="line">)</span><br><span class="line">type User struct &#123;</span><br><span class="line">	Id, Name string</span><br><span class="line">&#125;</span><br><span class="line">type UserResource struct &#123;</span><br><span class="line">	// normally one would use DAO (data access object)</span><br><span class="line">	users map[string]User</span><br><span class="line">&#125;</span><br><span class="line">//将路由以webservice的方式注册到container中</span><br><span class="line">func (u UserResource) Register(container *restful.Container) &#123;</span><br><span class="line">	ws := new(restful.WebService)</span><br><span class="line">	//这个是根路径</span><br><span class="line">	ws.</span><br><span class="line">		Path(&quot;/users&quot;).</span><br><span class="line">		Doc(&quot;Manage Users&quot;).</span><br><span class="line">		Consumes(restful.MIME_XML, restful.MIME_JSON).</span><br><span class="line">		Produces(restful.MIME_JSON, restful.MIME_XML) // you can specify this per route as well</span><br><span class="line">   //后面是根路径之后的每个具体的方法</span><br><span class="line">	ws.Route(ws.GET(&quot;/&#123;user-id&#125;&quot;).To(u.findUser).</span><br><span class="line">		// docs</span><br><span class="line">		Doc(&quot;get a user&quot;).</span><br><span class="line">		Operation(&quot;findUser&quot;).</span><br><span class="line">		Param(ws.PathParameter(&quot;user-id&quot;, &quot;identifier of the user&quot;).DataType(&quot;string&quot;)).</span><br><span class="line">		Writes(User&#123;&#125;)) // on the response</span><br><span class="line">	ws.Route(ws.PUT(&quot;/&#123;user-id&#125;&quot;).To(u.updateUser).</span><br><span class="line">		// docs</span><br><span class="line">		Doc(&quot;update a user&quot;).</span><br><span class="line">		Operation(&quot;updateUser&quot;).</span><br><span class="line">		Param(ws.PathParameter(&quot;user-id&quot;, &quot;identifier of the user&quot;).DataType(&quot;string&quot;)).</span><br><span class="line">		ReturnsError(409, &quot;duplicate user-id&quot;, nil).</span><br><span class="line">		Reads(User&#123;&#125;)) // from the request</span><br><span class="line">	ws.Route(ws.POST(&quot;&quot;).To(u.createUser).</span><br><span class="line">		// docs</span><br><span class="line">		Doc(&quot;create a user&quot;).</span><br><span class="line">		Operation(&quot;createUser&quot;).</span><br><span class="line">		Reads(User&#123;&#125;)) // from the request</span><br><span class="line">	ws.Route(ws.DELETE(&quot;/&#123;user-id&#125;&quot;).To(u.removeUser).</span><br><span class="line">		// docs</span><br><span class="line">		Doc(&quot;delete a user&quot;).</span><br><span class="line">		Operation(&quot;removeUser&quot;).</span><br><span class="line">		Param(ws.PathParameter(&quot;user-id&quot;, &quot;identifier of the user&quot;).DataType(&quot;string&quot;)))</span><br><span class="line">	container.Add(ws)</span><br><span class="line">&#125;</span><br><span class="line">// GET http://localhost:8080/users/1</span><br><span class="line">//</span><br><span class="line">func (u UserResource) findUser(request *restful.Request, response *restful.Response) &#123;</span><br><span class="line">             ...</span><br><span class="line">&#125;</span><br><span class="line">// POST http://localhost:8080/users</span><br><span class="line">// &lt;User&gt;&lt;Name&gt;Melissa&lt;/Name&gt;&lt;/User&gt;</span><br><span class="line">//</span><br><span class="line">func (u *UserResource) createUser(request *restful.Request, response *restful.Response) &#123;</span><br><span class="line">             ...</span><br><span class="line">&#125;</span><br><span class="line">// PUT http://localhost:8080/users/1</span><br><span class="line">// &lt;User&gt;&lt;Id&gt;1&lt;/Id&gt;&lt;Name&gt;Melissa Raspberry&lt;/Name&gt;&lt;/User&gt;</span><br><span class="line">//</span><br><span class="line">func (u *UserResource) updateUser(request *restful.Request, response *restful.Response) &#123;</span><br><span class="line">             ...</span><br><span class="line">&#125;</span><br><span class="line">// DELETE http://localhost:8080/users/1</span><br><span class="line">//</span><br><span class="line">func (u *UserResource) removeUser(request *restful.Request, response *restful.Response) &#123;</span><br><span class="line">             ...</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">   //创建一个新的container 将user的路由放到container当中</span><br><span class="line">	wsContainer := restful.NewContainer()</span><br><span class="line">	u := UserResource&#123;map[string]User&#123;&#125;&#125;</span><br><span class="line">	u.Register(wsContainer)</span><br><span class="line">	//配置swagger</span><br><span class="line">	config := swagger.Config&#123;</span><br><span class="line">		WebServices:    wsContainer.RegisteredWebServices(), // you control what services are visible</span><br><span class="line">		WebServicesUrl: &quot;http://localhost:8080&quot;,</span><br><span class="line">		ApiPath:        &quot;/apidocs.json&quot;,</span><br><span class="line">		// Optionally, specifiy where the UI is located</span><br><span class="line">		SwaggerPath:     &quot;/apidocs/&quot;,</span><br><span class="line">		SwaggerFilePath: &quot;/Users/emicklei/xProjects/swagger-ui/dist&quot;&#125;</span><br><span class="line">	swagger.RegisterSwaggerService(config, wsContainer)</span><br><span class="line">    //开启服务 监听8080端口</span><br><span class="line">	log.Printf(&quot;start listening on localhost:8080&quot;)</span><br><span class="line">	server := &amp;http.Server&#123;Addr: &quot;:8080&quot;, Handler: wsContainer&#125;</span><br><span class="line">	log.Fatal(server.ListenAndServe())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合之前的分析，可以看到<code>server := &amp;http.Server{Addr: &quot;:8080&quot;, Handler: wsContainer}</code>传入的Handler实例是一个wsContainer，说明wsContainer也是Handler接口的一个实现，我们来看一下它的具体结构及其ServerHTTP方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type Container struct &#123;</span><br><span class="line">	webServices            []*WebService</span><br><span class="line">	ServeMux               *http.ServeMux</span><br><span class="line">	isRegisteredOnRoot     bool</span><br><span class="line">	containerFilters       []FilterFunction</span><br><span class="line">	doNotRecover           bool // default is false</span><br><span class="line">	recoverHandleFunc      RecoverHandleFunction</span><br><span class="line">	serviceErrorHandleFunc ServiceErrorHandleFunction</span><br><span class="line">	router                 RouteSelector // default is a RouterJSR311, CurlyRouter is the faster alternative</span><br><span class="line">	contentEncodingEnabled bool          // default is false</span><br><span class="line">&#125;</span><br><span class="line">func (c Container) ServeHTTP(httpwriter http.ResponseWriter, httpRequest *http.Request) &#123;</span><br><span class="line">	c.ServeMux.ServeHTTP(httpwriter, httpRequest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，container结构中包含了我们之前提到的ServeMux路由分发器，其ServerHTTP方法就是直接调用的ServeMux实例的ServerHTTP方法。从这里也可以明显看出来，container实例是对golang中的ServeMux实例的进一步封装。</p>
<p>结合最初的user的例子大致看一下go-restful的使用，首先是生成一个container实例，此时其中的路由是空的，之后在具体注册路由的时候，由于要进行分层的处理，每一类路由会被封装成为一个webservice实例，其中的route实例是可以替换的，默认是按照jsr311标准实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type WebService struct &#123;</span><br><span class="line">	rootPath       string</span><br><span class="line">	pathExpr       *pathExpression // cached compilation of rootPath as RegExp</span><br><span class="line">	routes         []Route</span><br><span class="line">	produces       []string</span><br><span class="line">	consumes       []string</span><br><span class="line">	pathParameters []*Parameter</span><br><span class="line">	filters        []FilterFunction</span><br><span class="line">	documentation  string</span><br><span class="line">	apiVersion     string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个webservice实例包含一系列的 routes ， 每个route实例都有对应的执行方法，参数以及url，以及执行额外操作时候所需要的一些参数比如filter的相关函数对象。</p>
<p>可以看到，go-restful涉及到的对象主要分为以下几个层次：</p>
<ul>
<li>Container</li>
<li>webService</li>
<li>Route<br>其中container是最上层的对象，相当于是对serveMux实例的一个封装，其中有多个webService，每个webService相当于是包含了一类api请求，里面包含了多个Route。</li>
</ul>
<p>每次把router注册(对应的路由及函数)到webservice中后，还要通过container.Add(ws)将这一类的webservice加入到对应的container当中。</p>
<p>在add方法中，会对container中的serverMux进行处理(就是按照上面介绍的 根据HandFunc往进去注册一些路由和方法的映射关系)调用上面所介绍的<code>ServeMux.HandleFunc</code>方法，将对应的pattern注册给serverMux，container对路由信息进行一些处理之后，serverMux就只进行第一层的请求分发：<code>c.ServeMux.HandleFunc(pattern+&quot;/&quot;, c.dispatch)</code>，第二层的请求分发由<code>c.dispatch</code>函数来完成。这个函数主要是将过来的子类别的请求再次分发给对应的route来处理，默认情况下，会按照jsr311的标准，选择出对应的webservice中的对应的路由，并且执行路由的对应方法。此外，还会处理filter函数并且进行一些额外操作，具体可参考源码。</p>
<p>go-restful还支持对每一层对象添加对应的fliter方法，用于对方法进行一层封装，用于进行 pre function以及after function操作，使用起来也很简单，比如像下面这个例子(<a href="https://github.com/emicklei/go-restful/blob/master/examples/restful-pre-post-filters.go)：" target="_blank" rel="noopener">https://github.com/emicklei/go-restful/blob/master/examples/restful-pre-post-filters.go)：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">	&quot;github.com/emicklei/go-restful&quot;</span><br><span class="line">	&quot;io&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line">// This example shows how the different types of filters are called in the request-response flow.</span><br><span class="line">// The call chain is logged on the console when sending an http request.</span><br><span class="line">//</span><br><span class="line">// GET http://localhost:8080/1</span><br><span class="line">// GET http://localhost:8080/2</span><br><span class="line">var indentLevel int</span><br><span class="line">func container_filter_A(req *restful.Request, resp *restful.Response, chain *restful.FilterChain) &#123;</span><br><span class="line">	log.Printf(&quot;url path:%v\n&quot;, req.Request.URL)</span><br><span class="line">	trace(&quot;container_filter_A: before&quot;, 1)</span><br><span class="line">	chain.ProcessFilter(req, resp)</span><br><span class="line">	trace(&quot;container_filter_A: after&quot;, -1)</span><br><span class="line">&#125;</span><br><span class="line">func container_filter_B(req *restful.Request, resp *restful.Response, chain *restful.FilterChain) &#123;</span><br><span class="line">	trace(&quot;container_filter_B: before&quot;, 1)</span><br><span class="line">	chain.ProcessFilter(req, resp)</span><br><span class="line">	trace(&quot;container_filter_B: after&quot;, -1)</span><br><span class="line">&#125;</span><br><span class="line">func service_filter_A(req *restful.Request, resp *restful.Response, chain *restful.FilterChain) &#123;</span><br><span class="line">	trace(&quot;service_filter_A: before&quot;, 1)</span><br><span class="line">	chain.ProcessFilter(req, resp)</span><br><span class="line">	trace(&quot;service_filter_A: after&quot;, -1)</span><br><span class="line">&#125;</span><br><span class="line">func service_filter_B(req *restful.Request, resp *restful.Response, chain *restful.FilterChain) &#123;</span><br><span class="line">	trace(&quot;service_filter_B: before&quot;, 1)</span><br><span class="line">	chain.ProcessFilter(req, resp)</span><br><span class="line">	trace(&quot;service_filter_B: after&quot;, -1)</span><br><span class="line">&#125;</span><br><span class="line">func route_filter_A(req *restful.Request, resp *restful.Response, chain *restful.FilterChain) &#123;</span><br><span class="line">	trace(&quot;route_filter_A: before&quot;, 1)</span><br><span class="line">	chain.ProcessFilter(req, resp)</span><br><span class="line">	trace(&quot;route_filter_A: after&quot;, -1)</span><br><span class="line">&#125;</span><br><span class="line">func route_filter_B(req *restful.Request, resp *restful.Response, chain *restful.FilterChain) &#123;</span><br><span class="line">	trace(&quot;route_filter_B: before&quot;, 1)</span><br><span class="line">	chain.ProcessFilter(req, resp)</span><br><span class="line">	trace(&quot;route_filter_B: after&quot;, -1)</span><br><span class="line">&#125;</span><br><span class="line">//用于定义输出结果中的层级关系 使得输出结果好看一些</span><br><span class="line">func trace(what string, delta int) &#123;</span><br><span class="line">	indented := what</span><br><span class="line">	if delta &lt; 0 &#123;</span><br><span class="line">		indentLevel += delta</span><br><span class="line">	&#125;</span><br><span class="line">	for t := 0; t &lt; indentLevel; t++ &#123;</span><br><span class="line">		indented = &quot;.&quot; + indented</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(&quot;%s&quot;, indented)</span><br><span class="line">	if delta &gt; 0 &#123;</span><br><span class="line">		indentLevel += delta</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">   //这里采用了默认自动生成的container实例</span><br><span class="line">   //当然也可以使用 新生成的container 来调用其Filter方法</span><br><span class="line">	restful.Filter(container_filter_A)</span><br><span class="line">	restful.Filter(container_filter_B)</span><br><span class="line">	ws1 := new(restful.WebService)</span><br><span class="line">	ws1.Path(&quot;/1&quot;)</span><br><span class="line">	ws1.Filter(service_filter_A)</span><br><span class="line">	ws1.Filter(service_filter_B)</span><br><span class="line">	ws1.Route(ws1.GET(&quot;&quot;).To(doit1).Filter(route_filter_A).Filter(route_filter_B))</span><br><span class="line">	ws2 := new(restful.WebService)</span><br><span class="line">	ws2.Path(&quot;/2&quot;)</span><br><span class="line">	ws2.Filter(service_filter_A)</span><br><span class="line">	ws2.Filter(service_filter_B)</span><br><span class="line">	ws2.Route(ws2.GET(&quot;&quot;).To(doit2).Filter(route_filter_A).Filter(route_filter_B))</span><br><span class="line">	restful.Add(ws1)</span><br><span class="line">	restful.Add(ws2)</span><br><span class="line">	log.Print(&quot;go-restful example listing on http://localhost:8080/1 and http://localhost:8080/2&quot;)</span><br><span class="line">	log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))</span><br><span class="line">&#125;</span><br><span class="line">func doit1(req *restful.Request, resp *restful.Response) &#123;</span><br><span class="line">	io.WriteString(resp, &quot;nothing to see in 1&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func doit2(req *restful.Request, resp *restful.Response) &#123;</span><br><span class="line">	io.WriteString(resp, &quot;nothing to see in 2&quot;)</span><br><span class="line">&#125;</span><br><span class="line">/*output</span><br><span class="line">2015/08/18 18:03:53 go-restful example listing on http://localhost:8080/1 and http://localhost:8080/2</span><br><span class="line">2015/08/18 18:04:10 url path:/1</span><br><span class="line">2015/08/18 18:04:10 container_filter_A: before</span><br><span class="line">2015/08/18 18:04:10 .container_filter_B: before</span><br><span class="line">2015/08/18 18:04:10 ..service_filter_A: before</span><br><span class="line">2015/08/18 18:04:10 ...service_filter_B: before</span><br><span class="line">2015/08/18 18:04:10 ....route_filter_A: before</span><br><span class="line">2015/08/18 18:04:10 .....route_filter_B: before</span><br><span class="line">2015/08/18 18:04:10 .....route_filter_B: after</span><br><span class="line">2015/08/18 18:04:10 ....route_filter_A: after</span><br><span class="line">2015/08/18 18:04:10 ...service_filter_B: after</span><br><span class="line">2015/08/18 18:04:10 ..service_filter_A: after</span><br><span class="line">2015/08/18 18:04:10 .container_filter_B: after</span><br><span class="line">2015/08/18 18:04:10 container_filter_A: after</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.cnblogs.com/yjf512/archive/2012/08/22/2650873.html" target="_blank" rel="noopener">http://www.cnblogs.com/yjf512/archive/2012/08/22/2650873.html</a></p>
<p><a href="http://my.oschina.net/u/943306/blog/151293#OSC_h2_6" target="_blank" rel="noopener">http://my.oschina.net/u/943306/blog/151293#OSC_h2_6</a></p>
<p><a href="https://github.com/emicklei/go-restful" target="_blank" rel="noopener">https://github.com/emicklei/go-restful</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/15/golang-servmux/" data-id="ckjtg0qco005m7zl04idyorkc" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
 <script src="/jquery/jquery.min.js"></script>
  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2019/06/15/blog-updating/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          blog updating
        
      </div>
    </a>
  
  
    <a href="/2019/06/15/golang-context-tips/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">golang context tips</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#简易的http服务"><span class="toc-number">1.</span> <span class="toc-text">简易的http服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用serverMux"><span class="toc-number">2.</span> <span class="toc-text">使用serverMux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#serverMux中的HandleFunc方法"><span class="toc-number">3.</span> <span class="toc-text">serverMux中的HandleFunc方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#项目中的例子-关于go-rest"><span class="toc-number">4.</span> <span class="toc-text">项目中的例子 关于go-rest</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考资料"><span class="toc-number">5.</span> <span class="toc-text">参考资料</span></a></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2021 zhe&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;godenwangzhe@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>