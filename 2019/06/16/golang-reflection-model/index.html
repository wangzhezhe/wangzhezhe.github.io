<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>golang reflection model | AverageMind</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="主要是介绍了golang中反射的基本工作原理以及基本的使用，其实关键还是要学会如何从interface实现的角度上去理解反射的流程，就很清晰了，当然这里只是介绍基本的使用方式，具体细节还有很多。">
<meta property="og:type" content="article">
<meta property="og:title" content="golang reflection model">
<meta property="og:url" content="http://yoursite.com/2019/06/16/golang-reflection-model/index.html">
<meta property="og:site_name" content="AverageMind">
<meta property="og:description" content="主要是介绍了golang中反射的基本工作原理以及基本的使用，其实关键还是要学会如何从interface实现的角度上去理解反射的流程，就很清晰了，当然这里只是介绍基本的使用方式，具体细节还有很多。">
<meta property="og:locale">
<meta property="article:published_time" content="2019-06-16T19:28:31.000Z">
<meta property="article:modified_time" content="2019-06-16T19:36:13.000Z">
<meta property="article:author" content="zhe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="AverageMind" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-165927341-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AverageMind</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-golang-reflection-model" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/16/golang-reflection-model/" class="article-date">
  <time datetime="2019-06-16T19:28:31.000Z" itemprop="datePublished">2019-06-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/golang/">golang</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      golang reflection model
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>主要是介绍了golang中反射的基本工作原理以及基本的使用，其实关键还是要学会如何从interface实现的角度上去理解反射的流程，就很清晰了，当然这里只是介绍基本的使用方式，具体细节还有很多。</p>
<a id="more"></a>
<h3 id="关于接口的实现原理"><a href="#关于接口的实现原理" class="headerlink" title="关于接口的实现原理"></a>关于接口的实现原理</h3><h4 id="编译期间检测"><a href="#编译期间检测" class="headerlink" title="编译期间检测"></a>编译期间检测</h4><p>虽然golang中实现了 ducktype,但是仍然会在编译期会进行检测，不像其他的动态语言比如python那样，如果传入的是一个错误的类型（没有实现这个接口），在编译期间就会报错。</p>
<p>比如下面的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">type Testinface interface &#123;</span><br><span class="line">	getLen(s string) (n int)</span><br><span class="line">&#125;</span><br><span class="line">func strLen(strutil Testinface, content string) int &#123;</span><br><span class="line">	str_len := strutil.getLen(content)</span><br><span class="line">	return str_len</span><br><span class="line">&#125;</span><br><span class="line">type Mystra struct &#123;</span><br><span class="line">	str string</span><br><span class="line">&#125;</span><br><span class="line">type Mystrb struct &#123;</span><br><span class="line">	num int</span><br><span class="line">&#125;</span><br><span class="line">func (s Mystra) getLen(str string) int &#123;</span><br><span class="line">	fmt.Printf(&quot;caculating the str of struct : %v\n&quot;, s)</span><br><span class="line">	return len(str)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	mystra := Mystra&#123;&quot;test the interface&quot;&#125;</span><br><span class="line">	mystrb := Mystrb&#123;100&#125;</span><br><span class="line">	value := strLen(mystra, mystra.str)</span><br><span class="line">	fmt.Println(value)</span><br><span class="line">	//check the first parameter if it realize the Testinface interface when compiling</span><br><span class="line">	value = strLen(mystrb, &quot;teststr&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码定义好一个接口Testinterface，并在interface中声明了一个方法，用于计算传入的字符串的长度。<br>之后分别定义了两个结构体，其中Mystra实现了Testinterface中的方法，而Mystrb没有实现，之后我们再调用getLen函数的时候（第一个参数要求是一个Testinface类型），如果传入的参数是Mastera的实例，就正常，如果传入的是Masterb的实例，在编译的时候，就会报如下的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./reflection.go:36: cannot use mystrb (type Mystrb) as type Testinface in argument to strLen:</span><br><span class="line">	Mystrb does not implement Testinface (missing getLen method)</span><br></pre></td></tr></table></figure>
<h4 id="interface类型动态检测"><a href="#interface类型动态检测" class="headerlink" title="interface类型动态检测"></a>interface类型动态检测</h4><p>不一定每次都使用静态的方法来检测接口的类型，也可以通过动态的方式进行检测，比如下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line">type Stringer interface &#123;</span><br><span class="line">	String() string</span><br><span class="line">&#125;</span><br><span class="line">func ToString(any interface&#123;&#125;) string &#123;</span><br><span class="line">	if v, ok := any.(Stringer); ok &#123;</span><br><span class="line">		return v.String()</span><br><span class="line">	&#125;</span><br><span class="line">	switch v := any.(type) &#123;</span><br><span class="line">	case int:</span><br><span class="line">		return strconv.Itoa(v)</span><br><span class="line">	case float64:</span><br><span class="line">		return strconv.FormatFloat(v, &apos;f&apos;, -1, 64)</span><br><span class="line">	&#125;</span><br><span class="line">	return &quot;???&quot;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	value := ToString(123.345)</span><br><span class="line">	fmt.Println(value)</span><br><span class="line">	value = ToString(123456)</span><br><span class="line">	fmt.Println(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上面的例子，函数的参数是一个interface{}类型，因此可以接受任意类型的传入参数，之后会使用“comma ok”的语法进行检验，看对应的类型是否可以通过断言的方式进行转化，fmt package的方式也使用了这种思路实现。</p>
<h4 id="接口的底层结构"><a href="#接口的底层结构" class="headerlink" title="接口的底层结构"></a>接口的底层结构</h4><p>感觉上就是接口对某个实例的引用，就是将某个结构体的实例赋值给一个接口，比如先声明以下结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">type Binary uint64</span><br><span class="line">type myInt int</span><br><span class="line">type Stringer interface &#123;</span><br><span class="line">	String() string</span><br><span class="line">&#125;</span><br><span class="line">func (i Binary) String() string &#123;</span><br><span class="line">	return strconv.Itoa(i.Get())</span><br><span class="line">&#125;</span><br><span class="line">func (i Binary) Get() int &#123;</span><br><span class="line">	return int(i)</span><br><span class="line">&#125;</span><br><span class="line">func (i myInt) Get() int &#123;</span><br><span class="line">	return int(i)</span><br><span class="line">&#125;</span><br><span class="line">func (i myInt) String() string &#123;</span><br><span class="line">	return strconv.Itoa(i.Get())</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	b := Binary(20)</span><br><span class="line">	s := Stringer(b)</span><br><span class="line">	fmt.Println(reflect.TypeOf(s))</span><br><span class="line">	fmt.Println(reflect.TypeOf(s))</span><br><span class="line">	fmt.Println(reflect.TypeOf(new(Stringer)))</span><br><span class="line">	fmt.Println(reflect.ValueOf(s))</span><br><span class="line">	var i interface&#123;&#125;</span><br><span class="line">	fmt.Println(reflect.TypeOf(i))</span><br><span class="line">	i = b</span><br><span class="line">	fmt.Println(reflect.TypeOf(i))</span><br><span class="line">	fmt.Println(reflect.ValueOf(i))</span><br><span class="line">	m := myInt(30)</span><br><span class="line">	i = m</span><br><span class="line">	fmt.Println(reflect.TypeOf(i))</span><br><span class="line">	fmt.Println(reflect.ValueOf(i))</span><br><span class="line">	fmt.Println(reflect.ValueOf(interface&#123;&#125;(s)))</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">output</span><br><span class="line">main.Binary</span><br><span class="line">main.Binary</span><br><span class="line">*main.Stringer</span><br><span class="line">20</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">main.Binary</span><br><span class="line">20</span><br><span class="line">main.myInt</span><br><span class="line">30</span><br><span class="line">20</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>以上的例子中，首先生成了一个Binary类型的对象，由于这个Binary类型实现了interface中定义的方法，因此可以转化为一个interface实例，如代码中所示，那么这个s中存储的内容到底是什么，为何可以直接通过s来对具体实例所实现的方法进行调用？从理解上进行一些粗略分析，大致理解一下，主要内容来源于这个：</p>
<p>大部分语言都通过以下两种方式处理引用（或者说是说是所谓的多态）</p>
<ul>
<li><p>静态的方式在编译的时候就生成tables用于存储所有的调用方法（c++，java）</p>
</li>
<li><p>动态的方式，就是在runtime的时候，在每次进行方法调用的时候 寻找实际要去调用的method （smalltalk，javascript，python）</p>
</li>
<li><p>go语言interface的处理方式是将两者结合起来，它也有对应的method table，在实际运行的时候才会计算method table中的内容。</p>
</li>
</ul>
<p>具体的图片可以参考原文，通过s:=Stringer(b)生成一个interface的实例之后，其中包含两个指针（仅仅是从理解的角度上，实际代码的实现可能并没有这样直接），整个Stringer实例所在的地址空间主要包括两个指针:tab于data。</p>
<ul>
<li><p>其中data指针指向的是一个实际的值，在上面的例子中就是指向的b，就是通过reflect.ValueOf得到的那个值，只不过返回的结果被包装成了reflect.Value类型。</p>
</li>
<li><p>tab部分就是一个指向 interface table(itable)的指针，itable的开始是一些包括了type（这个type是存储在第一部分的那个data的类型）的元信息，之后是指向实际要调用的函数的指针（就是b的method），注意每一个interface实例中的itable实际指向的函数地址就是具体所存储的实例所声名的那些函数，比如图中的(*Binary).String。也就是说，每一个interface实例中都有一个与之相对应的底层类型，最特殊的一种情况是interface{},此时底层类型为nil。</p>
</li>
</ul>
<p>上面例子中的最后部分，即使reflect.typeof中的参数是一个接口类型的对象，最后打印出来的也是它的table中的type类型。</p>
<p><strong>具体调用一个方法的时候，比如s.String(),实际上相当于C中的如下操作：s.tab-&gt;fun<a href="s.data">0</a>调用了指针所指向的函数，同时将本身存储的那个data传递进去，作为函数的第一个参数。</strong></p>
<h4 id="itable的计算"><a href="#itable的计算" class="headerlink" title="itable的计算"></a>itable的计算</h4><p>itable是如何计算的呢？由于go语言可以进行动态的类型转化，这说明在编译期间，编译器没有将itable全部准备好。interface中的method与concret type中的method,这些内容合并在一起有太多的pairs需要对比，而其中许多是不需要的。编译器会为每一个concret type生成一个类型表述结构（type description）,在元信息中，类型描述结构包含了一系列这个concret type所实现的method。同理，编译器也会为interface 生成一个类型描述结构记录interface在声明的时候都包括了哪些方法，在具体计算compute的时候，只需要找到在两个list中同时出现的那些函数即可，在实际计算过程中，用到了排序再两指针遍历的思想进行了优化，并且还进行了缓存。在实际处理中还有一些地方进行了优化，具体见原文。</p>
<p>注意以下几点：</p>
<p>Go的接口静态类型化的，所谓的动态类型是一种误导，一个接口类型变量总是保持同一个静态类型，就是上面说的写进去的data是不变的，即使在运行时通过断言表达式，值的类型发生变化，interface存储的两个结构中，data是不变的，只是把 itable中的函数指针重新计算了一遍,具体看上面的例子，再最后一部分，通过断言的方式对原先的Binary类型的实例进行转化，输出的底层的data的值仍然是20，底层的类型值仍然是Binary,并未发生变化。除非新new一个Srringer类型的变量，</p>
<p>接口中所声明的方法一定要是类型所实现了的方法的一个子集，通过接口变量也仅仅只能调用这个接口变量所对应的方法</p>
<p>对于空接口声明 interface{} 由于里面没有声明其他的方法，可以把任意的实际变量。有一个重要的细节：</p>
<p>接口中不可以保存接口类型，接口的结构只能是（值，具体类型）而不能是（值，接口类型）这样。只能把具体类型的变量值存入到一个接口中，而不能把一个接口变量再存入到一个接口中。</p>
<h3 id="反射三定律"><a href="#反射三定律" class="headerlink" title="反射三定律"></a>反射三定律</h3><h4 id="从接口值到反射对象"><a href="#从接口值到反射对象" class="headerlink" title="从接口值到反射对象"></a>从接口值到反射对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//show the basic function of type and value</span><br><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">	var x string = &quot;abc&quot;</span><br><span class="line">	fmt.Println(&quot;type:&quot;, reflect.TypeOf(x))</span><br><span class="line">	fmt.Println(&quot;value:&quot;, reflect.ValueOf(x))</span><br><span class="line">	fmt.Printf(&quot;value: %#v&quot;, reflect.ValueOf(x))</span><br><span class="line">&#125;</span><br><span class="line">/*output:</span><br><span class="line">type: string</span><br><span class="line">type: abc</span><br><span class="line">value: reflect.Value&#123;typ:(*reflect.rtype)(0xa0820), ptr:(unsafe.Pointer)(0x20818a2c0), flag:0x58&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>从本质上理解，反射就是<strong>检查存储在接口变量中的（value,type）的对应的机制</strong>。reflect包中存在两个基本的类型，即Value与Type，这个与之前说的接口类型中所存储的信息是对应的。采用两个函数reflect.Typeof以及reflect.Valueof可以返回接口值的对应的Type和Value的两个部分，从下面的接口定义可以看到我们之前所讨论过的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// emptyInterface is the header for an interface&#123;&#125; value.</span><br><span class="line">type emptyInterface struct &#123;</span><br><span class="line">	typ  *rtype</span><br><span class="line">	word unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line">// nonEmptyInterface is the header for a interface value with methods.</span><br><span class="line">type nonEmptyInterface struct &#123;</span><br><span class="line">	// see ../runtime/iface.c:/Itab</span><br><span class="line">	itab *struct &#123;</span><br><span class="line">		ityp   *rtype // static interface type</span><br><span class="line">		typ    *rtype // dynamic concrete type</span><br><span class="line">		link   unsafe.Pointer</span><br><span class="line">		bad    int32</span><br><span class="line">		unused int32</span><br><span class="line">		fun    [100000]unsafe.Pointer // method table</span><br><span class="line">	&#125;</span><br><span class="line">	word unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用reflect.Typeof(x)的时候，首先会把这个x的值赋值给一个新的interface，这个interface是一个空接口，这个空接口会被作为一个参数传递，之后reflect.Typeof会把这个接口再unpack出来，恢复出类型的信息。之后会返回interface的type字段，这里就体现出了Golang反射的本质，再重申一下就是：检查存储在对应接口中的（value，type）的对应的机制。</p>
<p>看一下reflect.Valueof以及reflect.Typeof的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func TypeOf(i interface&#123;&#125;) Type &#123;</span><br><span class="line">	eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">	return toType(eface.typ)</span><br><span class="line">&#125;</span><br><span class="line">func ValueOf(i interface&#123;&#125;) Value &#123;</span><br><span class="line">	if i == nil &#123;</span><br><span class="line">		return Value&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// TODO(rsc): Eliminate this terrible hack.</span><br><span class="line">	// In the call to unpackEface, i.typ doesn&apos;t escape,</span><br><span class="line">	// and i.word is an integer.  So it looks like</span><br><span class="line">	// i doesn&apos;t escape.  But really it does,</span><br><span class="line">	// because i.word is actually a pointer.</span><br><span class="line">	escapes(i)</span><br><span class="line">	return unpackEface(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里暂时不细致探究具体指针转化的过程，从两个函数中可以看出来，就是分别从空inteface中提取出对应的字段。</p>
<p>reflect.Value以及reflect.Type两个类型本身实现了诸多方法，可以通过这些方法进一步操纵这两个对象。比如reflect.Value对象有一个Value方法，可以返回这个value的实际类型（与reflect.Valueof(x)一样？）这个Value方法返回的是值的静态类型就是最先定义好的那个类型。</p>
<p>这里要区别一下静态类型以及底层类型,比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type MyInt int</span><br><span class="line">var i int</span><br><span class="line">var j MyInt</span><br></pre></td></tr></table></figure>
<p>那么i的静态类型是int，j的静态类型是MyInt,这里的i与j是有不同的静态类型（static type）但是他们的底层类型（underlying type）是相同的。如果不进行强制准换的话，它们是不能互相赋值的。</p>
<p>如果想要知道一个Value的底层类型的具体类别，需要可以使用reflect.Value类型的kind()函数。</p>
<p>可以看看下面的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">	var x float64 = 3.4</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	fmt.Println(&quot;type1:&quot;, v.Type())</span><br><span class="line">	fmt.Println(&quot;type2:&quot;, reflect.TypeOf(x))</span><br><span class="line">	fmt.Println(&quot;kind of x:&quot;, v.Kind())</span><br><span class="line">	fmt.Println(&quot;value of x:&quot;, v.Float())</span><br><span class="line">	type MyInt int</span><br><span class="line">	var myint MyInt = 5</span><br><span class="line">	reflectv := reflect.ValueOf(myint)</span><br><span class="line">	fmt.Println(&quot;type of myint: &quot;, reflectv.Type())</span><br><span class="line">	fmt.Println(&quot;kind of myint: &quot;, reflectv.Kind())</span><br><span class="line">&#125;</span><br><span class="line">/*output</span><br><span class="line">type1: float64</span><br><span class="line">type2: float64</span><br><span class="line">kind of x: float64</span><br><span class="line">value of x: 3.4</span><br><span class="line">type of myint:  main.MyInt</span><br><span class="line">kind of myint:  int</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>可以看到，kind返回的类型是底层的int而Type函数返回的是静态类型main.Myint。reflect.Value类型中还实现了许多方法，比如Float、Int等等，会把原本的value结构通过各种对应的指针转换，得到不同的对应的结果。</p>
<p>最后再强调一下注意事项：</p>
<ul>
<li><p>value 的 kind 方法返回的是底层类型而不是静态类型,如果值本身是基本的类型的话，那底层类型和静态类型就是一致的。</p>
</li>
<li><p>为了保持API的简洁，通过 value的方法进一步返回实际的类型的时候，只设置了最大的类型转换，比如说想把reflect.Value转化为float32需要按照下面这样(直接使用Float返回的是float64类型)：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  package main</span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">	var x float32 = 32</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	fmt.Println(&quot;type:&quot;, v.Type())</span><br><span class="line">	fmt.Println(&quot;kind is uint8: &quot;, v.Kind()) </span><br><span class="line">	fmt.Println(&quot;the type:&quot;, reflect.TypeOf(v.Float()))</span><br><span class="line">	fmt.Println(&quot;the type:&quot;, reflect.TypeOf(float32(v.Float())))</span><br><span class="line">&#125;</span><br><span class="line">/*output</span><br><span class="line">type: float32</span><br><span class="line">kind is uint8:  float32</span><br><span class="line">the type: float64</span><br><span class="line">the type: float32</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>再补充一点,在golang中可以使用断言的方式将接口类型的变量转化为具体data的类型，具体的语法如value, ok := interfaceInstance.(string),如果转化成功,value值与类型变为了具体的data的值与类型，否则ok的值就为false。从具体的某个底层类型转化为接口类型的实例，直接 newinterface:=InterfaceType(instance)即可转化成功。</p>
<h4 id="从反射对象到接口值"><a href="#从反射对象到接口值" class="headerlink" title="从反射对象到接口值"></a>从反射对象到接口值</h4><p>可以把实际的类型通过reflecct.value的interface方法来打包成一个interface的形式，本质上相当于直接将这个值赋给一个interface{}类型的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Interface returns v&apos;s current value as an interface&#123;&#125;.</span><br><span class="line">// It is equivalent to:</span><br><span class="line">//	var i interface&#123;&#125; = (v&apos;s underlying value)</span><br><span class="line">// It panics if the Value was obtained by accessing</span><br><span class="line">// unexported struct fields.</span><br><span class="line">func (v Value) Interface() (i interface&#123;&#125;) &#123;</span><br><span class="line">	return valueInterface(v, true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可修改的反射对象值必须是settable的"><a href="#可修改的反射对象值必须是settable的" class="headerlink" title="可修改的反射对象值必须是settable的"></a>可修改的反射对象值必须是settable的</h4><p>如果想要通过反射来修改某个对象的值，需要这个值本身是setable的，这实际上是一个传值和传指针的问题，通过下面的例子就很明白了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">	var x float64 = 3.4</span><br><span class="line">	v1 := reflect.ValueOf(x)</span><br><span class="line">	fmt.Println(&quot;settability of v1:&quot;, v1.CanSet())</span><br><span class="line">	v2 := reflect.ValueOf(&amp;x)</span><br><span class="line">	fmt.Println(&quot;settability of v2:&quot;, v2.CanSet())</span><br><span class="line">	element := v2.Elem()</span><br><span class="line">	fmt.Println(&quot;settability of element:&quot;, element.CanSet())</span><br><span class="line">	element.SetFloat(5.5)</span><br><span class="line">	fmt.Println(&quot;the new value of v2:&quot;, element.Float())</span><br><span class="line">&#125;</span><br><span class="line">/*output</span><br><span class="line">settability of v1: false</span><br><span class="line">settability of v2: false</span><br><span class="line">settability of element: true</span><br><span class="line">the new value of v2: 5.5</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>通过以上代码我们可以看到输出情况，第一次传进去的是x的值，是通过值传递来进行的，这个时候setable是false的，因为是一个值传递，之后我们传入这个对象的引用，这个时候setable还是false的，但是我们可以通过指针的Elem值来取得实际的内容，这个值就是setable的，就可以通过反射来更新其值。<br>因此想要通过反射的方式来更新某些结构的值就必须要有这些实例对象的地址才可以。</p>
<p>可以再看一下value的Elem函数的声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Elem returns the value that the interface v contains</span><br><span class="line">// or that the pointer v points to.</span><br><span class="line">// It panics if v&apos;s Kind is not Interface or Ptr.</span><br><span class="line">// It returns the zero Value if v is nil.</span><br><span class="line">func (v Value) Elem() Value &#123;..&#125;</span><br></pre></td></tr></table></figure>
<p>仅仅当value是一个指针或者一个interface的时候，可以调用Elem方法返回对应所指向的值。注意这里返回的类型还是一个Value类型，还可以进一步进行调用，通常的使用场景就是指针类型的Value调用Elem返回实际的内容的Value，之后再调用Elem执行其他的操作。</p>
<p>当然关于反射还涉及许多内容，这里仅仅介绍了一些基本的使用。</p>
<h3 id="反射使用进阶（json-Marshal）"><a href="#反射使用进阶（json-Marshal）" class="headerlink" title="反射使用进阶（json.Marshal）"></a>反射使用进阶（json.Marshal）</h3><p>这一部分主要是分析golang源码中的json.Marshal函数，看看官方是如何灵活使用反射机制的。json.Marshal函数有这样的功能：</p>
<p><strong>如果传入的对象实现了Marshaler interface,并且不是一个空指针，代码执行的时候会自动调用接口中所规定的MarshalJSON方法，如果没有实现该接口，则采用默认的实现方式</strong></p>
<p>这个有点动态加载的感觉，这种运行时候的动态检测功能主要是依靠反射的方式实现的，先来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">type myJson struct&#123;&#125;</span><br><span class="line">func (m myJson) MarshalJSON() ([]byte, error) &#123;</span><br><span class="line">	fmt.Println(&quot;custom json marshal&quot;)</span><br><span class="line">	return json.Marshal(&quot;custome json test&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	str := &quot;original json test&quot;</span><br><span class="line">	s, _ := json.Marshal(str)</span><br><span class="line">	fmt.Println(string(s))</span><br><span class="line">	m := myJson&#123;&#125;</span><br><span class="line">	ms, err := json.Marshal(m)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		fmt.Println(string(ms))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">output:</span><br><span class="line">&quot;original json test&quot;</span><br><span class="line">custom json marshal</span><br><span class="line">&quot;custome json test&quot;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>如上代码所示,对于以上实现了接口中的MarshalJSON()函数的myJson类型的实例，如果使用json.Marshal方法对其进行操作，就会调用对应的MarshalJSON方法。先不看源码，大致推测以下思路：运行的时候使用反射的方式进行判断，可以根据反射类型进行进一步判断，如果实现了接口中的方法，就用对应的方法，如果没有实现，就用默认的。</p>
<p>marshal函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// An encodeState encodes JSON into a bytes.Buffer.</span><br><span class="line">type encodeState struct &#123;</span><br><span class="line">	bytes.Buffer // accumulated output</span><br><span class="line">	scratch      [64]byte</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">func Marshal(v interface&#123;&#125;) ([]byte, error) &#123;</span><br><span class="line">	e := &amp;encodeState&#123;&#125;</span><br><span class="line">	err := e.marshal(v)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return e.Bytes(), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点部分是<code>err := e.marshal(v)</code>主要是将内容marshal到buffer中再输出，跟着e.marshal函数往下看，细节性的内容不具体介绍，最后到了typeEncoder函数，这个函数的主要功能是一个缓存，操作的对象为<code>map[reflect.Type]encoderFunc</code>就是存储反射类型所对一个你的encoderFunc。已经存在map中，则从中取出，否则就另外生成一个。注意这个函数中对于map操作时候的两点 1 锁的使用 2 在递归情况下，结合wg操作，map的value值应该如何进行封装。之后看以下最核心的函数，如何返回一个encode函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">	marshalerType     = reflect.TypeOf(new(Marshaler)).Elem()</span><br><span class="line">	textMarshalerType = reflect.TypeOf(new(encoding.TextMarshaler)).Elem()</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">// newTypeEncoder constructs an encoderFunc for a type.</span><br><span class="line">// The returned encoder only checks CanAddr when allowAddr is true.</span><br><span class="line">func newTypeEncoder(t reflect.Type, allowAddr bool) encoderFunc &#123;</span><br><span class="line">	if t.Implements(marshalerType) &#123;</span><br><span class="line">		return marshalerEncoder</span><br><span class="line">	&#125;</span><br><span class="line">	if t.Kind() != reflect.Ptr &amp;&amp; allowAddr &#123;</span><br><span class="line">		if reflect.PtrTo(t).Implements(marshalerType) &#123;</span><br><span class="line">			return newCondAddrEncoder(addrMarshalerEncoder, newTypeEncoder(t, false))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if t.Implements(textMarshalerType) &#123;</span><br><span class="line">		return textMarshalerEncoder</span><br><span class="line">	&#125;</span><br><span class="line">	if t.Kind() != reflect.Ptr &amp;&amp; allowAddr &#123;</span><br><span class="line">		if reflect.PtrTo(t).Implements(textMarshalerType) &#123;</span><br><span class="line">			return newCondAddrEncoder(addrTextMarshalerEncoder, newTypeEncoder(t, false))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	switch t.Kind() &#123;</span><br><span class="line">	case reflect.Bool:</span><br><span class="line">		return boolEncoder</span><br><span class="line">	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</span><br><span class="line">		return intEncoder</span><br><span class="line">	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:</span><br><span class="line">		return uintEncoder</span><br><span class="line">	case reflect.Float32:</span><br><span class="line">		return float32Encoder</span><br><span class="line">	case reflect.Float64:</span><br><span class="line">		return float64Encoder</span><br><span class="line">	case reflect.String:</span><br><span class="line">		return stringEncoder</span><br><span class="line">	case reflect.Interface:</span><br><span class="line">		return interfaceEncoder</span><br><span class="line">	case reflect.Struct:</span><br><span class="line">		return newStructEncoder(t)</span><br><span class="line">	case reflect.Map:</span><br><span class="line">		return newMapEncoder(t)</span><br><span class="line">	case reflect.Slice:</span><br><span class="line">		return newSliceEncoder(t)</span><br><span class="line">	case reflect.Array:</span><br><span class="line">		return newArrayEncoder(t)</span><br><span class="line">	case reflect.Ptr:</span><br><span class="line">		return newPtrEncoder(t)</span><br><span class="line">	default:</span><br><span class="line">		return unsupportedTypeEncoder</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在var变量部分，现存储好了两个实际的用于比较的类型,根据前面部分的介绍，这个应该容易理解reflect.TypeOf(new(Marshaler)).Elem()表示先初始化一个Marshaler类型的实例，之后得到其Type信息，之后通过Elem()得到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">type Stringer interface &#123;</span><br><span class="line">	String() string</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	// Kind returns the specific kind of this type.</span><br><span class="line">	// Elem returns a type&apos;s element type.</span><br><span class="line">	// It panics if the type&apos;s Kind is not Array, Chan, Map, Ptr, or Slice.</span><br><span class="line">	fmt.Println(&quot;------------ptr------------&quot;)</span><br><span class="line">	fmt.Println(&quot;typeof:&quot;, reflect.TypeOf(new(Stringer)))</span><br><span class="line">	fmt.Println(&quot;kind:&quot;, reflect.TypeOf(new(Stringer)).Kind())</span><br><span class="line">	fmt.Println(&quot;elem:&quot;, reflect.TypeOf(new(Stringer)).Elem())</span><br><span class="line">	fmt.Println(&quot;------------map------------&quot;)</span><br><span class="line">	m := make(map[string]int)</span><br><span class="line">	fmt.Println(&quot;typeof:&quot;, reflect.TypeOf(m))</span><br><span class="line">	fmt.Println(&quot;kind:&quot;, reflect.TypeOf(m).Kind())</span><br><span class="line">	fmt.Println(&quot;elem:&quot;, reflect.TypeOf(m).Elem())</span><br><span class="line">	fmt.Println(&quot;------------slice------------&quot;)</span><br><span class="line">	s := make([]string, 3)</span><br><span class="line">	fmt.Println(&quot;typeof:&quot;, reflect.TypeOf(s))</span><br><span class="line">	fmt.Println(&quot;kind:&quot;, reflect.TypeOf(s).Kind())</span><br><span class="line">	fmt.Println(&quot;elem:&quot;, reflect.TypeOf(s).Elem())</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">output</span><br><span class="line">------------ptr------------</span><br><span class="line">typeof: *main.Stringer</span><br><span class="line">kind: ptr</span><br><span class="line">elem: main.Stringer</span><br><span class="line">------------map------------</span><br><span class="line">typeof: map[string]int</span><br><span class="line">kind: map</span><br><span class="line">elem: int</span><br><span class="line">------------slice------------</span><br><span class="line">typeof: []string</span><br><span class="line">kind: slice</span><br><span class="line">elem: string</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>上面的例子展示了type与kind函数的使用，type就是最”表层的分类”比如一个指针的type可以main.Stringer但是它的type是ptr指针类型。具体的elem函数会得到指针所指向的元素的Type比如第一个例子中的elem是main.Stringer，elem显示的是Type,而不是kind底层类型。再看之前reflect.TypeOf(new(Marshaler)).Elem()的定义，就容易理解了，得到的是指针所指向的实际内容的类型,newTypeEncoder函数中首先通过Implements函数判断了是否实现传入的接口类型，类似地在这一部分最开始的代码中，如果要判断自定义的struct是否实现了Stringer接口，需要进行如下操作fmt.Println(reflect.TypeOf(i).Implements(reflect.TypeOf(new(Stringer)).Elem()))，之后如果判断实现了这个接口，则执行marshalerEncoder函数，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func marshalerEncoder(e *encodeState, v reflect.Value, quoted bool) &#123;</span><br><span class="line">	if v.Kind() == reflect.Ptr &amp;&amp; v.IsNil() &#123;</span><br><span class="line">		e.WriteString(&quot;null&quot;)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	m := v.Interface().(Marshaler)</span><br><span class="line">	b, err := m.MarshalJSON()</span><br><span class="line">	if err == nil &#123;</span><br><span class="line">		// copy JSON into buffer, checking validity.</span><br><span class="line">		err = compact(&amp;e.Buffer, b, true)</span><br><span class="line">	&#125;</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		e.error(&amp;MarshalerError&#123;v.Type(), err&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键的一步是m := v.Interface().(Marshaler),首先把反射类型转化为接口类型，之后再讲接口类型通过断言的方式转化为存在其中的data值，即是Marshaler的interface实例。这里写完整是这样的表达reflect.Valueof(Instance).Interface().(Marshaler)其中Instance是最初的实现了Marshaler接口的结构体实例。这句话的作用就是将原先的实例转化为Marshaler的接口类型，此时生成的接口实例的itable中，函数的位置就是我们自己定义的MarshalJSON的实现。</p>
<p>这里仅仅分析了json.Marshal的一部分，主要的反射相关的要点也都有涉及到，其他的部分可以对比地进行分析。通过这个函数，也可以看到Golang中所支持的所有的底层类型(即是kind()函数所返回的值)，在检验完车，发现没有其他的实现，就使用Golang中每种类型对应的json解析方式,也就是newTypeEncoder函数的最后一段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">switch t.Kind() &#123;</span><br><span class="line">case reflect.Bool:</span><br><span class="line">	return boolEncoder</span><br><span class="line">case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</span><br><span class="line">	return intEncoder</span><br><span class="line">case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:</span><br><span class="line">	return uintEncoder</span><br><span class="line">case reflect.Float32:</span><br><span class="line">	return float32Encoder</span><br><span class="line">case reflect.Float64:</span><br><span class="line">	return float64Encoder</span><br><span class="line">case reflect.String:</span><br><span class="line">	return stringEncoder</span><br><span class="line">case reflect.Interface:</span><br><span class="line">	return interfaceEncoder</span><br><span class="line">case reflect.Struct:</span><br><span class="line">	return newStructEncoder(t)</span><br><span class="line">case reflect.Map:</span><br><span class="line">	return newMapEncoder(t)</span><br><span class="line">case reflect.Slice:</span><br><span class="line">	return newSliceEncoder(t)</span><br><span class="line">case reflect.Array:</span><br><span class="line">	return newArrayEncoder(t)</span><br><span class="line">case reflect.Ptr:</span><br><span class="line">	return newPtrEncoder(t)</span><br><span class="line">default:</span><br><span class="line">	return unsupportedTypeEncoder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>json使用相关注意<br><a href="https://blog.gopheracademy.com/advent-2016/advanced-encoding-decoding/?from=timeline" target="_blank" rel="noopener">https://blog.gopheracademy.com/advent-2016/advanced-encoding-decoding/?from=timeline</a></p>
<p>interface较深入了解：</p>
<p><a href="http://research.swtch.com/interfaces" target="_blank" rel="noopener">http://research.swtch.com/interfaces</a></p>
<p><a href="http://studygolang.com/articles/2157" target="_blank" rel="noopener">http://studygolang.com/articles/2157</a></p>
<p><a href="http://blog.golang.org/laws-of-reflection" target="_blank" rel="noopener">http://blog.golang.org/laws-of-reflection</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/16/golang-reflection-model/" data-id="cl49ds6oq004nuamcuraqkakf" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
 
<script src="/jquery/jquery.min.js"></script>

  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2019/06/16/bash-tips/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          bash tips
        
      </div>
    </a>
  
  
    <a href="/2019/06/16/golang-factory-pattern/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">golang factory pattern</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">关于接口的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%9C%9F%E9%97%B4%E6%A3%80%E6%B5%8B"><span class="toc-number">1.1.</span> <span class="toc-text">编译期间检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#interface%E7%B1%BB%E5%9E%8B%E5%8A%A8%E6%80%81%E6%A3%80%E6%B5%8B"><span class="toc-number">1.2.</span> <span class="toc-text">interface类型动态检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">接口的底层结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#itable%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">1.4.</span> <span class="toc-text">itable的计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%B8%89%E5%AE%9A%E5%BE%8B"><span class="toc-number">2.</span> <span class="toc-text">反射三定律</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E6%8E%A5%E5%8F%A3%E5%80%BC%E5%88%B0%E5%8F%8D%E5%B0%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">从接口值到反射对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%8F%8D%E5%B0%84%E5%AF%B9%E8%B1%A1%E5%88%B0%E6%8E%A5%E5%8F%A3%E5%80%BC"><span class="toc-number">2.2.</span> <span class="toc-text">从反射对象到接口值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%BF%AE%E6%94%B9%E7%9A%84%E5%8F%8D%E5%B0%84%E5%AF%B9%E8%B1%A1%E5%80%BC%E5%BF%85%E9%A1%BB%E6%98%AFsettable%E7%9A%84"><span class="toc-number">2.3.</span> <span class="toc-text">可修改的反射对象值必须是settable的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6%EF%BC%88json-Marshal%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">反射使用进阶（json.Marshal）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2022 zhe&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;godenwangzhe@gmail.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
    
 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>