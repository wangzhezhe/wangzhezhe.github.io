<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>rule of three/five | AverageMind</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="discuss the rule of three&#x2F;five in cpp.">
<meta property="og:type" content="article">
<meta property="og:title" content="rule of three&#x2F;five">
<meta property="og:url" content="http://yoursite.com/2020/05/28/rule-of-three-five/index.html">
<meta property="og:site_name" content="AverageMind">
<meta property="og:description" content="discuss the rule of three&#x2F;five in cpp.">
<meta property="og:locale">
<meta property="article:published_time" content="2020-05-28T15:53:38.000Z">
<meta property="article:modified_time" content="2020-07-16T07:47:37.000Z">
<meta property="article:author" content="zhe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="AverageMind" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-165927341-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AverageMind</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-rule-of-three-five" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/28/rule-of-three-five/" class="article-date">
  <time datetime="2020-05-28T15:53:38.000Z" itemprop="datePublished">2020-05-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c-c/">c/c++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      rule of three/five
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>discuss the rule of three/five in cpp.</p>
<a id="more"></a>
<p>When we start to define a class or a struct, if we do not follow the rule of three or rule of five, we might got some potential problems when the code becomes complicated.</p>
<p>For me, it seems that I would prefer to use the stack variable compared with the pointer to the class. Some times I may try to use <code>SomeClass *a =new SomeClass</code>, then I may forget to call the <code>delete a</code> sometimes. I would take some time to reorganize the code in order to avoid to use the class/struct pointer, unless it is necessary. I noticed that one reason that push me to use the poiter and the heap allocation to the class is that I may not need to follow the rule of three, for example, I could declare the dedicated struct or class instance in heap and acquire it by pointer, then I put these pointer into STL such as queue and map for further processing.</p>
<p>Although it works sometimes, but it is pretty like the c style. If the code gets comlicated, some memory problems appear and that make the code a little bit hard to maintain. Following the rule of three can avoid this issue and make the code looks more cleaning and tight.</p>
<h3 id="rule-of-three"><a href="#rule-of-three" class="headerlink" title="rule of three"></a>rule of three</h3><p>rule of three means that following three functions for struct or class must be provided: destructor, copy constructor, copy assignment operator. For copy constructor, it will be used when you init a struct/class instance by another class instance. For the copu assignmnet operator, it supports to the operation such as <code>SomeClass a = instanceOfA</code>. If one of these functions is used without first being declared by the programmer, it will be implicitly implemented by the compiler. Attention, the compiler generated version is based on the shadow copy, if there are some pointer value in the struct, you may need to set these special functions manually. Otherwise, it might cause the problem of the double free such like <a href="http://www.cplusplus.com/forum/general/29640/" target="_blank" rel="noopener">this case</a>. there is one block of the memory but there are two points, therefore, it might cause the double free problems. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">struct foo&#123;</span><br><span class="line">    std::string f1;</span><br><span class="line">    std::vector&lt;int&gt; v1;</span><br><span class="line">     foo()&#123;</span><br><span class="line">         std::cout&lt;&lt;&quot;foo is constructed&quot;&lt;&lt;std::endl;</span><br><span class="line">         f1=&quot;construct test&quot;;</span><br><span class="line">         v1.push_back(666);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     foo(const foo&amp; f)&#123;</span><br><span class="line">         std::cout&lt;&lt;&quot;copy constructor is called&quot;&lt;&lt;std::endl;</span><br><span class="line">         f1=&quot;copy test&quot;;</span><br><span class="line">         v1.push_back(888); </span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    foo&amp; operator = (const foo &amp;t) &#123;</span><br><span class="line">        std::cout&lt;&lt;&quot;assignment operator is called&quot;&lt;&lt;std::endl;</span><br><span class="line">        this-&gt;f1=&quot;assignment test &quot; + t.f1;</span><br><span class="line">        this-&gt;v1[0]=999; </span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~foo()&#123;std::cout&lt;&lt;&quot;foo is destructed automatically when foo is outof scope&quot;&lt;&lt;std::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test ()&#123;</span><br><span class="line">    foo f = foo();</span><br><span class="line"></span><br><span class="line">    //defualt copy operator</span><br><span class="line">    foo g = f;</span><br><span class="line">    //check the value of the g</span><br><span class="line">    std::cout &lt;&lt; &quot;check the value g: &quot;&lt;&lt; g.f1&lt;&lt; &quot;,&quot; &lt;&lt; g.v1[0] &lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    //copy constructor </span><br><span class="line">    foo i;</span><br><span class="line">    std::cout &lt;&lt; &quot;default constructor check the value i: &quot;&lt;&lt; i.f1&lt;&lt; &quot;,&quot; &lt;&lt; i.v1[0] &lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    //assignment constructor </span><br><span class="line">    i = f;</span><br><span class="line">    std::cout &lt;&lt; &quot;after copy check the value i: &quot;&lt;&lt; i.f1&lt;&lt; &quot;,&quot; &lt;&lt; i.v1[0] &lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    test();</span><br><span class="line">    std::cout&lt;&lt;&quot;main finish&quot;&lt;&lt;std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//////output//////</span><br><span class="line">foo is constructed</span><br><span class="line">copy constructor is called</span><br><span class="line">check the value g: copy test,888</span><br><span class="line">foo is constructed</span><br><span class="line">default constructor check the value i: construct test,666</span><br><span class="line">assignment operator is called</span><br><span class="line">after copy check the value i: assignment test construct test,999</span><br><span class="line">foo is destructed automatically when foo is outof scope</span><br><span class="line">foo is destructed automatically when foo is outof scope</span><br><span class="line">foo is destructed automatically when foo is outof scope</span><br><span class="line">main finish</span><br></pre></td></tr></table></figure>
<p>according to this case, when the class is initializsed, the default constructor or the copy constructor is called. When two instances are initialized and one instance could get value from another instance, the assignment constructor will be called. The destructor will be called when the instance is out of the scope.</p>
<p>If you want the struct as the key or value of specific STL such as the map, you also need to declare other operator such as “&lt;” operation.</p>
<h3 id="rule-of-five"><a href="#rule-of-five" class="headerlink" title="rule of five"></a>rule of five</h3><p>After the c++11, more rules are added into the class declaration, these rules are usually called rule of five.</p>
<p>This is a <a href="https://cpppatterns.com/patterns/rule-of-five.html" target="_blank" rel="noopener">good reference</a>. The main complicated part is the notation of the <code>&amp;&amp;</code>, two functions added here are <code>move constructor</code> and <code>move assignment operator</code>. </p>
<p>We need to figure out the lvalue and the rvalue before discussing more details. <a href="https://josephmansfield.uk/articles/lvalue-rvalue-metaphor.html" target="_blank" rel="noopener">this article</a> provides a good explanation.</p>
<p>So the <code>&amp;&amp;</code> represents the rvalue in cpp. and the last two rules are necessary if we use the move semantics. The original become unavalible after using the move related semantics.</p>
<p>This <a href="https://www.educative.io/edpresso/what-is-a-move-constructor-in-cpp" target="_blank" rel="noopener">article</a> provides a good explanation about why we need to use the rvalue and the move semantics. The main reason is to avoid the performance overhead, since the object is constructed for the orignal case when we execute the copy operation. Basically, there are two opeject, you assign values of one object two another, then both of them are deleted at last. But essentially, when you execute operations such as put a instance into a vector, you may want to provide a new view from the data structure’s view. The original instance might not useful anymore. In that case, in the move constructor, you just need to transfer the ownership of the data from the original instance to the new instance to avoid the extra data copy operation. Then the original instance become invalid. But the two destructors are also need to be called when the program is out of the scope. </p>
<p>Attention, the object that is moved out from the container might still hold the relevent resources, it is necessary to destroy objects that are moved out from the container when design the move constructor. refer to <a href="https://stackoverflow.com/questions/20589025/why-is-the-destructor-call-after-the-stdmove-necessary" target="_blank" rel="noopener">this answer</a>, or refer to this <a href="https://xgitlab.cels.anl.gov/sds/thallium/commit/1dcd8e1ec8e223d21f1c4c5796ba62ae35ee1bc1" target="_blank" rel="noopener">commit</a> to see how to correct a move constructor, originally, there is potential issue of the memory leak, but after the updates, the original object is deleted firstly to make the container empty, then the move operations are executed.</p>
<h3 id="practical-examples"><a href="#practical-examples" class="headerlink" title="practical examples"></a>practical examples</h3><p>this is the example for rule of three and rule of five, inpractical code, just remember there are thee types of constructor, two types of assignment operator and one destructor. When all of these things are considered, we could guarantee the class/struct is a secure one.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class foo &#123;</span><br><span class="line"> public:</span><br><span class="line">  // default constructor</span><br><span class="line">  foo() &#123; std::cout &lt;&lt; &quot;foo constructor is called&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">  // copy constructor</span><br><span class="line">  foo(const foo&amp; other) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;foo copy constructor is called&quot; &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  // move constructor</span><br><span class="line">  foo(foo&amp;&amp; other) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;foo move constructor is called&quot; &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // destructor</span><br><span class="line">  ~foo() &#123; std::cout &lt;&lt; &quot;foo destructor is called&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">  // assignment</span><br><span class="line">  foo&amp; operator=(const foo&amp; t) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;foo assignment operator is called&quot; &lt;&lt; std::endl;</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // move assignment</span><br><span class="line">  foo&amp; operator=(foo&amp;&amp; other) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;foo move assignment operator is called&quot; &lt;&lt; std::endl;</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="init-the-smart-ptr"><a href="#init-the-smart-ptr" class="headerlink" title="init the smart ptr"></a>init the smart ptr</h4><p>It is worth noting that when we use the shared pointer, we may use the <code>make_shared</code> function, this function will construct a new element by new operation, if we already create an class instance, the copy constructor will be called when we use the <code>make_shared</code>.</p>
<p>This is an exmaple:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">  std::shared_ptr&lt;foo&gt; footest1;</span><br><span class="line">  std::cout &lt;&lt; &quot;test1&quot; &lt;&lt; std::endl;</span><br><span class="line">  std::shared_ptr&lt;foo&gt; footest2(nullptr);</span><br><span class="line">  std::cout &lt;&lt; &quot;test2&quot; &lt;&lt; std::endl;</span><br><span class="line">  std::shared_ptr&lt;foo&gt; footest3(new foo());</span><br><span class="line">  std::cout &lt;&lt; &quot;test3&quot; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  foo f;</span><br><span class="line">  std::shared_ptr&lt;foo&gt; footest4 = std::make_shared&lt;foo&gt;(f);</span><br><span class="line">  std::cout &lt;&lt; &quot;test4&quot; &lt;&lt; std::endl;</span><br><span class="line">  //c++14 feature</span><br><span class="line">  std::unique_ptr&lt;foo&gt; footest5 = std::make_unique&lt;foo&gt;(f);</span><br><span class="line">  std::cout &lt;&lt; &quot;test5&quot; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  foo* fptr = &amp;f;</span><br><span class="line">  std::cout &lt;&lt; &quot;test6&quot; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>the output is sth like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">test1</span><br><span class="line">test2</span><br><span class="line">foo constructor is called</span><br><span class="line">test3</span><br><span class="line">foo constructor is called</span><br><span class="line">foo copy constructor is called</span><br><span class="line">test4</span><br><span class="line">foo copy constructor is called</span><br><span class="line">test5</span><br><span class="line">test6</span><br><span class="line">foo destructor is called</span><br><span class="line">foo destructor is called</span><br><span class="line">foo destructor is called</span><br><span class="line">foo destructor is called</span><br></pre></td></tr></table></figure>
<p>we could find out both the <code>make_unique</code> and the <code>make_shared</code> operation calles the copy constructor of original class.</p>
<p>This is normal in most of the cases, but for some cases, the copy constructor may be labeled by the delete key word such as this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// copy constructor</span><br><span class="line">foo(const foo&amp; other) = delete;</span><br></pre></td></tr></table></figure>
<p>in this case, there are issues if we init the shared pointer by <code>make_shared</code> since the copy constructor will be called. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo.cpp:39:40: note: in instantiation of function template specialization &apos;std::__1::make_shared&lt;foo, foo &amp;&gt;&apos; requested here</span><br><span class="line">  std::shared_ptr&lt;foo&gt; footest4 = std::make_shared&lt;foo&gt;(f);</span><br><span class="line">                                       ^</span><br><span class="line">foo.cpp:8:3: note: &apos;foo&apos; has been explicitly marked deleted here</span><br><span class="line">  foo(const foo&amp; other) = delete;</span><br></pre></td></tr></table></figure>
<p>The good way here is to init the object when we init the smart pointer by this way:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;foo&gt; footest3(new foo());</span><br><span class="line">std::cout &lt;&lt; &quot;test3&quot; &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>in this case, the constructor of the foo class is only called once.</p>
<p>This strategy can be used for init the class that contains the shared ptr that point to foo, such like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class bar &#123;</span><br><span class="line"> public:</span><br><span class="line">  std::shared_ptr&lt;foo&gt; m_foo;</span><br><span class="line">  bar() : m_foo(new foo)&#123;&#125;;</span><br><span class="line">  ~bar() = default;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>by this way, the copy constructor of the <code>class foo</code> is not called.</p>
<p>It might be important to go over some basic information about the cpp class at this point, in this <a href="http://www.cplusplus.com/doc/tutorial/classes/" target="_blank" rel="noopener">article</a>, about the <code>Member initialization in constructors</code>, if the type of the member is a class, such as the exmaple in our case, the constructor of this member can only be accessed in the list of the member initilization. If we do nothing here, the default constructor of the class member will be called when it jump into the body of the constructor. In our case, if we do nothing at the member initilization list, the shared pointer will be constructed by default constructor, which is a nullptr. After this, if we want to give it a valid value, we may need to use the make shared, but this will reigger the copy constructor which is deleted. Another posible solution is to use the <code>reset</code> that replaces the managed object:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class bar &#123;</span><br><span class="line"> public:</span><br><span class="line">  std::shared_ptr&lt;foo&gt; m_foo;</span><br><span class="line">  bar() &#123;</span><br><span class="line">      m_foo.reset(new foo);</span><br><span class="line">  &#125;;</span><br><span class="line">  ~bar() = default;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>anyway, it is important to know that the shared pointer will hold a managed object, and that is important distinction compared with the raw pointer. The init of the smart pointer can be views as sum of the following steps 1. declare raw pointer 2.create class instance 3.assign instance to the pointer. The initilization of the shared pointer may trigger the copy constructor, and it is important to use the proper way to init it to avoid the unnecessary copy operation.</p>
<h4 id="key-of-the-map"><a href="#key-of-the-map" class="headerlink" title="key of the map"></a>key of the map</h4><p>a commonly use case scenario is to customize an class and make it as the key of the map or set, what function are necessary in this case?<br>this is an example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class foo &#123;</span><br><span class="line"> public:</span><br><span class="line">  char a[16];</span><br><span class="line">  // default constructor</span><br><span class="line">  foo() &#123; std::cout &lt;&lt; &quot;foo constructor is called&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">  // destructor</span><br><span class="line">  ~foo() &#123; std::cout &lt;&lt; &quot;foo destructor is called&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">  // copy constructor</span><br><span class="line">  foo(const foo&amp; other) = default;</span><br><span class="line"></span><br><span class="line">  // less-than operator</span><br><span class="line">  bool operator&lt;(const foo&amp; ob) const &#123; return a &lt; ob.a; &#125;</span><br><span class="line"></span><br><span class="line">  // move constructor</span><br><span class="line">  foo(foo&amp;&amp; other) = delete;</span><br><span class="line"></span><br><span class="line">  // assignment operator</span><br><span class="line">  foo&amp; operator=(const foo&amp; t) = delete;</span><br><span class="line"></span><br><span class="line">  // move assignment operator</span><br><span class="line">  foo&amp; operator=(foo&amp;&amp; other) = delete;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  std::map&lt;foo, int&gt; custMap;</span><br><span class="line">  foo f1;</span><br><span class="line">  custMap[f1] = 0;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>the default constructor and destructor is necessary since we need to create the object, another necessary one is the <code>copy constructor</code>, this is because we need to copy the instance into the map when we execute the <code>custMap[f1] = 0</code>, another important thing is the less-than operator, this is required by the implementation of the map, it need to know the sequence between differnt objects.</p>
<p>Let’s check the <code>unordered_map</code>, according to this <a href="https://stackoverflow.com/questions/17016175/c-unordered-map-using-a-custom-class-type-as-the-key" target="_blank" rel="noopener">answer</a>, we need to define the hash function and customize the equality operator. The hash function can be wrapped by the functor and this function can be the third parameter for the unordered map, this is an workable example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class foo &#123;</span><br><span class="line"> public:</span><br><span class="line">  char a[16];</span><br><span class="line">  // default constructor</span><br><span class="line">  foo() &#123; std::cout &lt;&lt; &quot;foo constructor is called&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">  // destructor</span><br><span class="line">  ~foo() &#123; std::cout &lt;&lt; &quot;foo destructor is called&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">  // copy constructor</span><br><span class="line">  foo(const foo&amp; other) = default;</span><br><span class="line"></span><br><span class="line">  // less-than operator</span><br><span class="line">  // bool operator&lt;(const foo&amp; ob) const &#123; return a &lt; ob.a; &#125;</span><br><span class="line"></span><br><span class="line">  // equal operator</span><br><span class="line">  bool operator==(const foo&amp; ob) const &#123; return memcmp(a, ob.a, 16); &#125;</span><br><span class="line"></span><br><span class="line">  // move constructor</span><br><span class="line">  foo(foo&amp;&amp; other) = delete;</span><br><span class="line"></span><br><span class="line">  // assignment operator</span><br><span class="line">  foo&amp; operator=(const foo&amp; t) = delete;</span><br><span class="line"></span><br><span class="line">  // move assignment operator</span><br><span class="line">  foo&amp; operator=(foo&amp;&amp; other) = delete;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct KeyHasher &#123;</span><br><span class="line">  std::size_t operator()(const foo&amp; f) const &#123;</span><br><span class="line">    using std::hash;</span><br><span class="line">    using std::string;</span><br><span class="line"></span><br><span class="line">    return (hash&lt;string&gt;()(f.a));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  std::unordered_map&lt;foo, int, KeyHasher&gt; custMap;</span><br><span class="line">  foo f1;</span><br><span class="line">  custMap[f1] = 0;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>in this example, we define another functor that wrap the hash function.</p>
<h4 id="swap-operation"><a href="#swap-operation" class="headerlink" title="swap operation"></a>swap operation</h4><p>when it is ok to call the swap operation? </p>
<p>if check the cppreference <a href="https://en.cppreference.com/w/cpp/algorithm/swap" target="_blank" rel="noopener">here</a>, the move assignment operator and the move constructor of specific type should be defined.</p>
<p>Just pay attention here, if the delete the coresponding functions, there are compiling error when we use the swap.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo.cpp:44:3: error: no matching function for call to &apos;swap&apos;</span><br><span class="line">  std::swap(f1,f2);</span><br><span class="line">  ^~~~~~~~~</span><br><span class="line">/Library/Developer/CommandLineTools/usr/include/c++/v1/type_traits:4501:1: note: candidate template ignored: requirement &apos;is_move_constructible&lt;foo&gt;::value&apos; was not satisfied [with _Tp = foo]</span><br><span class="line">swap(_Tp&amp; __x, _Tp&amp; __y) _NOEXCEPT_(is_nothrow_move_constructible&lt;_Tp&gt;::value &amp;&amp;</span><br></pre></td></tr></table></figure>
<p>It only works when we set :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// move constructor</span><br><span class="line">foo(foo&amp;&amp; other) = default;</span><br><span class="line">// move assignment operator</span><br><span class="line">foo&amp; operator=(foo&amp;&amp; other) = default;</span><br></pre></td></tr></table></figure>
<p>we could see that another instance is created by swap:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">  foo f1;</span><br><span class="line">  foo f2;</span><br><span class="line">  std::swap(f1,f2);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//output</span><br><span class="line">foo constructor is called</span><br><span class="line">foo constructor is called</span><br><span class="line">foo destructor is called</span><br><span class="line">foo destructor is called</span><br><span class="line">foo destructor is called</span><br></pre></td></tr></table></figure>
<h3 id="references"><a href="#references" class="headerlink" title="references"></a>references</h3><p>why to use the rvalue<br><a href="https://www.educative.io/edpresso/what-is-a-move-constructor-in-cpp" target="_blank" rel="noopener">https://www.educative.io/edpresso/what-is-a-move-constructor-in-cpp</a></p>
<p>problem of double free (use reference instead of copy)</p>
<p><a href="http://www.cplusplus.com/forum/general/29640/" target="_blank" rel="noopener">http://www.cplusplus.com/forum/general/29640/</a> </p>
<p>assignment operator vs copy constructor</p>
<p><a href="https://www.geeksforgeeks.org/copy-constructor-vs-assignment-operator-in-c/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/copy-constructor-vs-assignment-operator-in-c/</a></p>
<p>the rule of zero, five, or maybe six.</p>
<p><a href="https://www.modernescpp.com/index.php/c-core-guidelines-constructors-assignments-and-desctructors" target="_blank" rel="noopener">https://www.modernescpp.com/index.php/c-core-guidelines-constructors-assignments-and-desctructors</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/28/rule-of-three-five/" data-id="cl49ds6oy0061uamc82xou3ox" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
 
<script src="/jquery/jquery.min.js"></script>

  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2020/05/28/cpp-forward-declaration/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          cpp forward declaration
        
      </div>
    </a>
  
  
    <a href="/2020/04/24/single-core-with-multithreading/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">single core with multiprocess</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#rule-of-three"><span class="toc-number">1.</span> <span class="toc-text">rule of three</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rule-of-five"><span class="toc-number">2.</span> <span class="toc-text">rule of five</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#practical-examples"><span class="toc-number">3.</span> <span class="toc-text">practical examples</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#init-the-smart-ptr"><span class="toc-number">3.1.</span> <span class="toc-text">init the smart ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#key-of-the-map"><span class="toc-number">3.2.</span> <span class="toc-text">key of the map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#swap-operation"><span class="toc-number">3.3.</span> <span class="toc-text">swap operation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#references"><span class="toc-number">4.</span> <span class="toc-text">references</span></a></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2022 zhe&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;godenwangzhe@gmail.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
    
 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>