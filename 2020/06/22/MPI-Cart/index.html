<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>MPI_Cart | Wangzhezhe&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="This article aims to introduce how to use the MPI and the cartition grid to solve a Poisson equation.">
<meta property="og:type" content="article">
<meta property="og:title" content="MPI_Cart">
<meta property="og:url" content="http://yoursite.com/2020/06/22/MPI-Cart/index.html">
<meta property="og:site_name" content="Wangzhezhe&#39;s Blog">
<meta property="og:description" content="This article aims to introduce how to use the MPI and the cartition grid to solve a Poisson equation.">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2020-06-28T04:14:28.986Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MPI_Cart">
<meta name="twitter:description" content="This article aims to introduce how to use the MPI and the cartition grid to solve a Poisson equation.">
  
    <link rel="alternate" href="/atom.xml" title="Wangzhezhe&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-165927341-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Wangzhezhe&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Writing is nature&#39;s way of letting you know how sloppy your thinking is.</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-MPI-Cart" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/22/MPI-Cart/" class="article-date">
  <time datetime="2020-06-23T03:44:44.000Z" itemprop="datePublished">2020-06-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/parallel/">parallel</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      MPI_Cart
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>This article aims to introduce how to use the MPI and the cartition grid to solve a Poisson equation.</p>
<a id="more"></a>
<p>Introduce the MPI cartision tools to show how to solve some real world problem such as numerical equations. We discusse the MPI cart firstly, then we will show how to use it to solve 2D possion equation and 3d laplasian equation from the scratch. </p>
<p>this is the basic scripts about using MPI cartisian tool to solve the possion equations, and the related videos are listed as follows:</p>
<p>generate the grid mesh by MPI Cartesian<br><a href="https://www.youtube.com/watch?v=R9qoLC95SzU" target="_blank" rel="noopener">https://www.youtube.com/watch?v=R9qoLC95SzU</a></p>
<p>get the neighbour cell id by MPI Cartesian<br><a href="https://www.youtube.com/watch?v=SmoIFYBWW0E" target="_blank" rel="noopener">https://www.youtube.com/watch?v=SmoIFYBWW0E</a></p>
<p>solving the Poisson equation by serial program<br><a href="https://www.youtube.com/watch?v=najbwGUSZO0" target="_blank" rel="noopener">https://www.youtube.com/watch?v=najbwGUSZO0</a></p>
<p>solving the Poisson equation by parallel program (one cell for one process)<br><a href="https://youtu.be/EnNoj0WKteM" target="_blank" rel="noopener">https://youtu.be/EnNoj0WKteM</a></p>
<p>solving the Poisson equation by parallel program (multiple cells for one process)<br><a href="https://youtu.be/mUeFWnntbC4" target="_blank" rel="noopener">https://youtu.be/mUeFWnntbC4</a></p>
<p>source code<br><a href="https://github.com/wangzhezhe/5MPPT/tree/master/mpi_example/possionhybrid" target="_blank" rel="noopener">https://github.com/wangzhezhe/5MPPT/tree/master/mpi_example/possionhybrid</a></p>
<h3 id="Prerequest"><a href="#Prerequest" class="headerlink" title="Prerequest"></a>Prerequest</h3><p>We assumed that you have already understand the basic knowledge about the MPI such as send/recive broadcast and reduce.</p>
<p>If you are unfamiliar with those concepts, this tutorial is a good place to start.<a href="https://mpitutorial.com/tutorials/" target="_blank" rel="noopener">here</a> </p>
<h3 id="construct-cartision-grid"><a href="#construct-cartision-grid" class="headerlink" title="construct cartision grid"></a>construct cartision grid</h3><p>Besides the basic API used in the message communication such as send and recv, MPI also provides several practical tools, the typical one is MPI Cartesian.</p>
<p>The mesh is basic tool to sovle the numerical problem. If we want to run an MPI program based on our data in specific domain, we need to assign an MPI process to a specific domain/partition/cell and let this process to caculate and update the data in the coresponding domain. This is called the single program multiple data.</p>
<p>This is the question:</p>
<p>The most basic function used in MPI program is to get an id.<br> for example, we use <code>MPI_Comm_rank(comm, &amp;rank)</code>, then we could assign a unique id to every process. The rank id is in 1d space, What if we want to associate this id with the spatial informaion namely the mesh infomation in 2D or 3D, what should we do?</p>
<p>For exmaple, we have 4 MPI processes, and the coordinates of every process is (x,y) which is in 2D space, we need make <code>rank=y*2+x</code> what should we do?</p>
<p><code>MPI_Dims_create</code> could solve this problem. it could generates a communicator that will be used to initialize the cartition grid among all the processes, and then we could use the <code>MPI_Cart_coords</code> to caculates the coresponding coordinates associated with each MPI process. </p>
<p>This is an example for creating the cartition by predefiend dims</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//the example comes from https://www.youtube.com/watch?v=eMnjwohg-sg</span><br><span class="line"></span><br><span class="line">#include &quot;mpi.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int rank, procs;</span><br><span class="line">    MPI_Comm cart_comm;</span><br><span class="line">    int reorder;</span><br><span class="line">    int coord[2], id;</span><br><span class="line">    int up, down, left, right;</span><br><span class="line"></span><br><span class="line">    MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</span><br><span class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;procs);</span><br><span class="line">    if (procs != 12)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;the process number should be 12&quot; &lt;&lt; std::endl;</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int dim[2] = &#123;4, 3&#125;;</span><br><span class="line">    </span><br><span class="line">    int periodical[2] = &#123;1, 1&#125;;</span><br><span class="line">    reorder = 0;</span><br><span class="line"></span><br><span class="line">    MPI_Cart_create(MPI_COMM_WORLD, 2, dim, periodical, reorder, &amp;cart_comm);</span><br><span class="line">    MPI_Cart_coords(cart_comm, rank, 2, coord);</span><br><span class="line"></span><br><span class="line">    printf(&quot;rank %d x %d y %d\n&quot;, rank, coord[0], coord[1]);</span><br><span class="line"></span><br><span class="line">    if (rank == 7)</span><br><span class="line">    &#123;</span><br><span class="line">        MPI_Cart_shift(cart_comm, 0, 1, &amp;up, &amp;down);</span><br><span class="line">        MPI_Cart_shift(cart_comm, 1, 1, &amp;left, &amp;right);</span><br><span class="line">        printf(&quot;neighbors for rank7 left %d right %d up %d down %d\n&quot;,</span><br><span class="line">        left,right,up,down);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The periodical here means if the dimention is perioical, if it is true, the next position of the last element will be the first element. This can be shown by using <code>MPI_Cart_shift</code>, this function is used to get the id of the neighborhood for specific element on specific dimention. For we could see the difference of the neigobor id for the cell at the boundry positions.</p>
<p>information about the reorder, it will let MPI to determine the optimal process ordering (range from the first dimention)</p>
<p><a href="http://www.bu.edu/tech/support/research/training-consulting/online-tutorials/mpi/more/mpi_cart_create/" target="_blank" rel="noopener">http://www.bu.edu/tech/support/research/training-consulting/online-tutorials/mpi/more/mpi_cart_create/</a></p>
<p><a href="https://stackoverflow.com/questions/32125267/mpi-reordering-of-processes-using-mpi-cart-create" target="_blank" rel="noopener">https://stackoverflow.com/questions/32125267/mpi-reordering-of-processes-using-mpi-cart-create</a></p>
<p>One crutial part is how to relates the coordinates with the domain information, we will also discuss how to use the shift API to get the neighborhood of specific cell</p>
<h3 id="caculate-the-rank-id-of-the-neigobor-cells"><a href="#caculate-the-rank-id-of-the-neigobor-cells" class="headerlink" title="caculate the rank id of the neigobor cells"></a>caculate the rank id of the neigobor cells</h3><p>For this part, we will discuss how to caculate the neigobor cells for specific cell in a mash.</p>
<p>Why this is necessary operation? For example, one typical operation for numerical compuing is the stencil operation, we will use this to solve some PDE(Partial Differential Equation). It doesn’t matter if this is a new term to you. The impoant thing here is that, the value in specific cell depednets on the neighbor cells in numerical computing. We assume the value is located in specific cell, in real usecase, the value can locate on point, or edge of the cell etc.</p>
<p>Assume exach MPI process hold a value in specific cell, and each cell is associated with an MPI process. For the five points stencil cell like this [figure], we need to know the rank id of the neigobor cells at the up, down, left and right direaction, by this way, we could index the neighobor cell, fetch the variable value stored at each neigobor cell and caculate the new value at the center position.</p>
<p>If we use coordinates to index the mesh, it is easy to get all the neighbor cells, For 2D mesh, if the coordinates of the current cell is (x,y), then the neigobor cell is (x-1,y) (x+1,y) (x,y-1) (x,y+1). But the underlying index is the rank id which is in one dimention space. Therefore, in order to get the value from the specific MPI process, we need to map the coordinates into the rank id. This is a kind of reverse process compared with the <code>mpi_cart_create</code>.</p>
<p>How to convert the coordinates into the rank id? For example, if the dimention array is a 2D array like this [dim1, dim2], the rank id is </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for d1 in dim1</span><br><span class="line">	for d2 in dim2</span><br><span class="line">       rankid = d2+d1*dim2</span><br></pre></td></tr></table></figure>
<p>If we use the x to represent the horizental axis and use y to represent the vertical axis, if the current rank id is cid,  the id of the up cell is cid+1, the down cell id is cid-1, the left cell id is cid-dim1, the right cell is cid+dim1. We do not consider the boundy cell here. </p>
<p>The caculation is getting complicated if we process the mesh in 3D, and we may need to caculate the id by using the function like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline int l2i(int x, int y, int z) const</span><br><span class="line">&#123;</span><br><span class="line">    return x + y * (size_x + 2) + z * (size_x + 2) * (size_y + 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>MPI_Cart</code> provides simple interface to help us to caculate the id of the neighrbor cells directly. This interface is called MPI_Shift and it is like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int MPI_Cart_shift(MPI_Comm comm, int direction, int disp, int *rank_source, int *rank_dest)</span><br></pre></td></tr></table></figure>
<p>The first parameter is the communicator generated by the cat_create, the second parameter label direction or dimention we want to target, the third parameter is the distance between the neigobor cell and the current cell, they rank_source and rank_dest are the output, they are tricky to understand at the first glance. let us look at an example firstly.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mpi.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int rank, procs;</span><br><span class="line">    MPI_Comm cart_comm;</span><br><span class="line">    int reorder;</span><br><span class="line">    int coord[2], id;</span><br><span class="line">    int up, down, left, right;</span><br><span class="line"></span><br><span class="line">    MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</span><br><span class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;procs);</span><br><span class="line">    if (procs != 12)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;the process number should be 12&quot; &lt;&lt; std::endl;</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int dim[2];</span><br><span class="line">    dim[0] = 4;</span><br><span class="line">    dim[1] = 3;</span><br><span class="line">    int periodical[2] = &#123;1, 1&#125;;</span><br><span class="line">    reorder = 0;</span><br><span class="line"></span><br><span class="line">    MPI_Cart_create(MPI_COMM_WORLD, 2, dim, periodical, reorder, &amp;cart_comm);</span><br><span class="line">    MPI_Cart_coords(cart_comm, rank, 2, coord);</span><br><span class="line"></span><br><span class="line">    printf(&quot;rank %d coor1 %d coor2 %d\n&quot;, rank, coord[0], coord[1]);</span><br><span class="line">    </span><br><span class="line">    if (rank == 7)</span><br><span class="line">    &#123;</span><br><span class="line">        MPI_Cart_shift(cart_comm, 0, 1, &amp;dim1_src, &amp;dim1_dest);</span><br><span class="line">        MPI_Cart_shift(cart_comm, 1, 1, &amp;dim2_src, &amp;dim2_dest);</span><br><span class="line">        printf(&quot;neighbors for rank 7 dim1_src %d dim1_dest %d dim2_src %d dim2_dest %d\n&quot;,</span><br><span class="line">               dim1_src, dim1_dest, dim2_src, dim2_dest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>the output is </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rank 5 coor1 1 coor2 2</span><br><span class="line">rank 0 coor1 0 coor2 0</span><br><span class="line">rank 3 coor1 1 coor2 0</span><br><span class="line">rank 6 coor1 2 coor2 0</span><br><span class="line">rank 9 coor1 3 coor2 0</span><br><span class="line">rank 1 coor1 0 coor2 1</span><br><span class="line">rank 4 coor1 1 coor2 1</span><br><span class="line">rank 11 coor1 3 coor2 2</span><br><span class="line">rank 2 coor1 0 coor2 2</span><br><span class="line">rank 10 coor1 3 coor2 1</span><br><span class="line">rank 7 coor1 2 coor2 1</span><br><span class="line">neighbors for rank 7 dim1_src 4 dim1_dest 10 dim2_src 6 dim2_dest 8</span><br><span class="line">rank 8 coor1 2 coor2 2</span><br></pre></td></tr></table></figure>
<p>if we use another parameter:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MPI_Cart_shift(cart_comm, 0, -1, &amp;dim1_src, &amp;dim1_dest);</span><br><span class="line">MPI_Cart_shift(cart_comm, 1, -1, &amp;dim2_src, &amp;dim2_dest);</span><br></pre></td></tr></table></figure>
<p>the output is </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neighbors for rank 7 dim1_src 10 dim1_dest 4 dim2_src 8 dim2_dest 6</span><br></pre></td></tr></table></figure>
<p>it is upward shift if this value is larger than 0 , upward means the id increase from the small value to the large value, and the downwards shift means the value decrease from the large value to the small value.</p>
<p>the second parameter is used to label with direaction we are target, for 2D mesh, if the direaction is 0, it means we are talking about the first dimention in this API, this is a exmaple of 2D case:</p>
<p>If we make the z direaction perpendicular with the paper plan by this way, we could get the exmaple for neigobor cells for the 3D mesh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MPI_Cart_shift(cart_comm, 0, 1, &amp;west, &amp;east);</span><br><span class="line">MPI_Cart_shift(cart_comm, 1, 1, &amp;down, &amp;up);</span><br><span class="line">MPI_Cart_shift(cart_comm, 2, 1, &amp;south, &amp;north);</span><br></pre></td></tr></table></figure>
<p>if the distance can be the large number than 1, if it is 2, it means we want to get the cell that is 2 unit based on the current cell.</p>
<p>Let’s go back to the following parameters:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int periodical[2] = &#123;1, 1&#125;;</span><br><span class="line">reorder = 0;</span><br><span class="line">MPI_Cart_create(MPI_COMM_WORLD, 2, dim, periodical, reorder, &amp;cart_comm);</span><br></pre></td></tr></table></figure>
<p>The two parameters are used when we create the new communicator, reorder means if you allow MPI to reorder the mapping relationship between the id and the actual process, the process that are close physically may have close id. If reorder = false then the rank of each process in the new group is identical to its rank in the old group. Otherwise, the function may reorder the processes (possibly so as to choose a good embedding of the virtual topology onto the physical machine). </p>
<p>For the cell with id 8, the results is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neighbors for rank 7 dim1_src 5 dim1_dest 11 dim2_src 7 dim2_dest 6</span><br></pre></td></tr></table></figure>
<p>we could see that the dim2_dest is 6, which is acrually the first element in this direaction.</p>
<p><a href="https://mpi.deino.net/mpi_functions/MPI_Cart_create.html" target="_blank" rel="noopener">https://mpi.deino.net/mpi_functions/MPI_Cart_create.html</a></p>
<p><a href="https://stackoverflow.com/questions/32125267/mpi-reordering-of-processes-using-mpi-cart-create" target="_blank" rel="noopener">https://stackoverflow.com/questions/32125267/mpi-reordering-of-processes-using-mpi-cart-create</a></p>
<p>periodical will be considered for the boundy case, if it is 1, the next cell after the last one will go back to the first one for upward direaction.</p>
<p><a href="https://stackoverflow.com/questions/20813185/what-are-source-and-destination-parameters-in-mpi-cart-shift" target="_blank" rel="noopener">https://stackoverflow.com/questions/20813185/what-are-source-and-destination-parameters-in-mpi-cart-shift</a></p>
<p>One benifits of this is that, this function could simplify the programming when we use MPI with other parallel tools such as OpenMP. Becasue in this case, one MPI process could caculate multiple cells, in each MPI process, we don’t need to hold a global view, we just need a local view, and then try to exchange the data between different domains by using <code>MPI_Shift</code>, we discuss this in detaild for the subsequent parts. </p>
<h3 id="construct-dimention-by-number-of-the-process"><a href="#construct-dimention-by-number-of-the-process" class="headerlink" title="construct dimention by number of the process"></a>construct dimention by number of the process</h3><p>For previous example, we simplify the number of the value at each dimention manually. For example <code>int dim[2]; dim[0] = 4; dim[1] = 3;</code> , In some cases, we just want to control the number of the total process and let the MPI to do this things automatically. The <code>MPI_Dims_create</code> could help us to do this thing. It will assign the coresponding values to the array of the dimention. </p>
<p>For this example, we plan to generate the dimention array automatically according to the number of the MPI process. This can be caculated by the <code>MPI_Cart_coords</code>, this is an example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &quot;mpi.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int rank, procs;</span><br><span class="line">    MPI_Comm cart_comm;</span><br><span class="line">    int reorder;</span><br><span class="line">    int coord[3], id;</span><br><span class="line">    int dim=3;</span><br><span class="line">    int xl, xr, yl, yr, zl, zr;</span><br><span class="line"></span><br><span class="line">    MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</span><br><span class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;procs);</span><br><span class="line"></span><br><span class="line">    int periodical[3] = &#123;1, 1, 1&#125;;</span><br><span class="line">    reorder = 0;</span><br><span class="line"></span><br><span class="line">    //update the dim according to nproc</span><br><span class="line">    int dims[3]=&#123;&#125;;</span><br><span class="line">    MPI_Dims_create(procs, 3, dims);</span><br><span class="line"></span><br><span class="line">    if (rank == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;dims %d,%d,%d\n&quot;, dims[0], dims[1], dims[2]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MPI_Cart_create(MPI_COMM_WORLD, dim, dims, periodical, reorder, &amp;cart_comm);</span><br><span class="line">    MPI_Cart_coords(cart_comm, rank, dim, coord);</span><br><span class="line"></span><br><span class="line">    printf(&quot;rank %d x %d y %d z %d\n&quot;, rank, coord[0], coord[1], coord[2]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If we use 12 MPI process, the output is </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dims 3,2,2</span><br><span class="line">rank 10 x 2 y 1 z 0</span><br><span class="line">rank 11 x 2 y 1 z 1</span><br><span class="line">rank 6 x 1 y 1 z 0</span><br><span class="line">rank 9 x 2 y 0 z 1</span><br><span class="line">rank 0 x 0 y 0 z 0</span><br><span class="line">rank 4 x 1 y 0 z 0</span><br><span class="line">rank 2 x 0 y 1 z 0</span><br><span class="line">rank 5 x 1 y 0 z 1</span><br><span class="line">rank 7 x 1 y 1 z 1</span><br><span class="line">rank 1 x 0 y 0 z 1</span><br><span class="line">rank 3 x 0 y 1 z 1</span><br><span class="line">rank 8 x 2 y 0 z 0</span><br></pre></td></tr></table></figure>
<p>the only parameter we input is the number of the process, both the dimention array and coordinates that labels the MPI process are created in automatic way by MPI related functions. </p>
<h3 id="a-real-example-Possion-equation"><a href="#a-real-example-Possion-equation" class="headerlink" title="a real example, Possion equation"></a>a real example, Possion equation</h3><p>For the numerical background and realted solution, please refer to this <a href="https://people.eecs.berkeley.edu/~demmel/cs267-1995/lecture24/lecture24.html" target="_blank" rel="noopener">link</a></p>
<p>Poisson equation is a fundamental and commonly used equation in engineering. If we understand the Poisson equation from the mathematical view. we will be more clear when we write the program to solve it.  When we figure out how to write a serial program to solve it, we can then update it into a parallel version to improve the execution time to solve the equation</p>
<p>This is a <a href="https://people.sc.fsu.edu/~jburkardt/cpp_src/poisson_serial/poisson_serial.html" target="_blank" rel="noopener">good example</a> to solve the possion equation in sequential pattern.</p>
<p>Our task here is to update it and write a parallel version based on this sequential version. In particular, there are several models to map resources into parallel solutions</p>
<p>the basic idea is the consider the granularity of the mesh for one process<br>for serial version, we have one process and one thread to execute whole task. so this single thread have the global view for the whole mesh, the thread can udpate every cell in the mesh step by step in serial way. If we have multiple process, every process can update one cell, therefore, we can accelarate the process of the iteration. The overhead here is the communication between different processes. since the view of the mesh for each proess is one cell. Since we can also use the multi thread on one machine, we can also let each process hold some portion of the mesh, and these mesh can be updated by multiple threads running in parallel. therefore, we can get the following parallel patterns:</p>
<p>(1) MPI, every process process one cell </p>
<p>(2) MPI, every process process multiple cells in serial pattern (a block) </p>
<p>(3) MPI + multithread (such as OpenMP or other accelerator such as GPU), every process, one data block</p>
<p>for this part, we start with the first one, namely, every MPI process one mesh cells. It might be efficient to use the GPU, but as a start point, understanding the MPI version is crutial for parallel programming.</p>
<p>The source code for the parallel version of the possion equation can be found <a href="https://github.com/wangzhezhe/5MPPT/tree/master/mpi_example/possion" target="_blank" rel="noopener">here</a>. </p>
<p>Let’s go through the sequential version quickly and move to the parallel version.</p>
<p>If we ignore the mathmetical part, the code for solving the possion equation is really standard, there are three steps if we use object oriented programming. Let’s say our class is called possion equation, the three functions are init, iterate, checkresults. For init function, basiclly, the framework of the main functions looks like this way:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Possion p;</span><br><span class="line">p.init();</span><br><span class="line">for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">   p.iterate();</span><br><span class="line">   error = p.check();</span><br><span class="line">   if(error &lt; threshold)&#123;</span><br><span class="line">   		break;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The framework is really straightforward. For the init operation, we mainly need to init the mesh and all the necessary boundry conditions, for the iteration, we just need to update the specific data structure based on the mathmetical method, then if the error of iteration results less then the threshould value, then we jump out of the iteration. The sequential code listed <a href="https://github.com/wangzhezhe/5MPPT/blob/master/mpi_example/possion/possionserial.cpp" target="_blank" rel="noopener">here</a> follows this framework. The thing that make it a little bit difficult is the set of the boundy values. no matter for the iterations or for the initlization, the boundy values are different with the interior values, be careful with this part.</p>
<p>For the parallel version, the extra operation is the exchange, since there multiple MPI process may work at the same time, the need to hold variables tha know their neighborhood values. those values are called the ghost value. Before iteration, every cell should tell their neighbors about the cell value itsself. This operation is negligible for the sequential version since the neighbor cells are accessable by same process. But it is different for the parallel version since cells may run at different cores on different nodes which holds different memory space. So the data exchange operation is necessary here.</p>
<p>Frankly speaking, it is hard to debug the parallel code. Mathmetical method itsself is difficult, parallel code is not easy, when these two challenging tasks come together, the program might become messy. For me, the advice is to divide it into severam small part, for example, start from the small scale case, and print out the initial values, and compare it with the sequemtial verison, than check the results for the 1 iteration and so on.</p>
<h3 id="the-poisson-equation-solver-with-the-hybrid-parallelism"><a href="#the-poisson-equation-solver-with-the-hybrid-parallelism" class="headerlink" title="the poisson equation solver with the hybrid parallelism"></a>the poisson equation solver with the hybrid parallelism</h3><p>For the previous <a href="https://github.com/wangzhezhe/5MPPT/tree/master/mpi_example/possion" target="_blank" rel="noopener">solution</a>, there is only one value for one cell, although it runs in parallel, it is not efficient since the communication is heavy. We can update it into the hybrid patten that run the program in paralllel. Every process will hold a block of the data and process it by serial or thread level parallelism.</p>
<p>Here are some tips during the process of the updating:</p>
<p><strong>the data structure that contains the ghost value</strong></p>
<p>if the local size is n times n, the data size that store the value should be the n+2 times n+2 since every block need a ghost area.</p>
<p><strong>the index between the differnet view</strong></p>
<p>since we have the local view and the global view, and the data vecttor is a 1d array, it is necessary to provide following index firstly.</p>
<p>index from the local 2d position to the 1d position that store the data</p>
<p>index from the local 2d position to the gloabl mesh position, this global mesh is a view logically.</p>
<p><strong>the data exchange</strong></p>
<p>another important operation for parallel processing is the face exchange. But the data might not continuous in storage. The <code>MPI_Vector_Type</code> can be used to define the vector contains the non-continuous data. The user just need to define the start position, the length of every block and the space between every blocks. Then this customized vector can be used to transfer data between each others. The data at the ghost area will be updated at the beginning of every iteration. Becase from the view of the logic, evey partition connected with each other, but actually, they are managmed by different thread and when the boundry element is updated, it needs the value from the ghost area to make the computation process run correactly. The advantages of using the customized the vector is the simplified interface of doing the face change between different process.</p>
<p><strong>write the serial program firstly</strong></p>
<p>it is easy to get lost when write a parallel program, therefore, the good tip is always to write a simplified serial program and use it as a checker for the parallel program. Maybe you could start with a small sacal program and use it to check if steps such as initilization, dataexchage and update are correct. It is not trival work to write a parallel program. Some minor bug may cause the results go to the wrong direaction. Basically, the serial program aims to solve the theoretical part, we need to make sure the math or model works. The parallel version is just use more resource wisely to accelarate the computing process. If we did not figure out the math when we write the parallle program, it may mess up tings easily.</p>
<p>The source code can be found <a href="https://github.com/wangzhezhe/5MPPT/tree/master/mpi_example/possionhybrid" target="_blank" rel="noopener">here</a>, for the configuration of the 800 times 800 square, if we use the hybrid parallel with 4 process and every process udpate 200 times 200 data block, it only use around 1/5 time compared with the serial version. The program can be optimized further by all kinds of optimization strategies. And we will discuss these strategies in other blogs.</p>
<h3 id="references"><a href="#references" class="headerlink" title="references"></a>references</h3><p><a href="https://www.mpich.org/static/docs/latest/www3/MPI_Cart_create.html" target="_blank" rel="noopener">https://www.mpich.org/static/docs/latest/www3/MPI_Cart_create.html</a></p>
<p><a href="https://www.mpich.org/static/docs/latest/www3/MPI_Cart_shift.html" target="_blank" rel="noopener">https://www.mpich.org/static/docs/latest/www3/MPI_Cart_shift.html</a></p>
<p>MPI vector type<br><a href="https://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-data.html#Vectortype" target="_blank" rel="noopener">https://pages.tacc.utexas.edu/~eijkhout/pcse/html/mpi-data.html#Vectortype</a></p>
<p>possion equation discritizatio</p>
<p><a href="https://www.youtube.com/watch?v=bLiaz-IHX_Y" target="_blank" rel="noopener">https://www.youtube.com/watch?v=bLiaz-IHX_Y</a></p>
<p>dim_create</p>
<p><a href="https://www.mpich.org/static/docs/v3.1.x/www3/MPI_Dims_create.html" target="_blank" rel="noopener">https://www.mpich.org/static/docs/v3.1.x/www3/MPI_Dims_create.html</a></p>
<p>good resource for halo exchange<br><a href="http://wgropp.cs.illinois.edu/courses/cs598-s15/lectures/lecture25.pdf" target="_blank" rel="noopener">http://wgropp.cs.illinois.edu/courses/cs598-s15/lectures/lecture25.pdf</a></p>
<p>non continuous vector with constant stride<br>exchange face -&gt; even if original one is not continuos<br><a href="https://cvw.cac.cornell.edu/MPIAdvTopics/vectortype" target="_blank" rel="noopener">https://cvw.cac.cornell.edu/MPIAdvTopics/vectortype</a><br>good examples</p>
<p><a href="https://www.rookiehpc.com/mpi/docs/mpi_type_vector.php" target="_blank" rel="noopener">https://www.rookiehpc.com/mpi/docs/mpi_type_vector.php</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/22/MPI-Cart/" data-id="ckejtg0kv004olus6ib8j9g80" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
 <script src="/jquery/jquery.min.js"></script>
  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2020/07/12/application-view-breadth-and-depth/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          application view, breadth and depth of learning computing science
        
      </div>
    </a>
  
  
    <a href="/2020/05/28/cpp-forward-declaration/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">cpp forward declaration</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Prerequest"><span class="toc-number">1.</span> <span class="toc-text">Prerequest</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#construct-cartision-grid"><span class="toc-number">2.</span> <span class="toc-text">construct cartision grid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#caculate-the-rank-id-of-the-neigobor-cells"><span class="toc-number">3.</span> <span class="toc-text">caculate the rank id of the neigobor cells</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#construct-dimention-by-number-of-the-process"><span class="toc-number">4.</span> <span class="toc-text">construct dimention by number of the process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#a-real-example-Possion-equation"><span class="toc-number">5.</span> <span class="toc-text">a real example, Possion equation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#the-poisson-equation-solver-with-the-hybrid-parallelism"><span class="toc-number">6.</span> <span class="toc-text">the poisson equation solver with the hybrid parallelism</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#references"><span class="toc-number">7.</span> <span class="toc-text">references</span></a></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2020 zhe&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;godenwangzhe@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>