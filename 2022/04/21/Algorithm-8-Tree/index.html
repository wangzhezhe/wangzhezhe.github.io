<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Algorithm(8) Tree | AverageMind</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="The typical algorithm questions based on the tree structure.">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithm(8) Tree">
<meta property="og:url" content="http://yoursite.com/2022/04/21/Algorithm-8-Tree/index.html">
<meta property="og:site_name" content="AverageMind">
<meta property="og:description" content="The typical algorithm questions based on the tree structure.">
<meta property="og:locale">
<meta property="article:published_time" content="2022-04-21T20:22:42.000Z">
<meta property="article:modified_time" content="2022-05-24T17:06:08.000Z">
<meta property="article:author" content="zhe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="AverageMind" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-165927341-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AverageMind</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Algorithm-8-Tree" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/21/Algorithm-8-Tree/" class="article-date">
  <time datetime="2022-04-21T20:22:42.000Z" itemprop="datePublished">2022-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Algorithm(8) Tree
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>The typical algorithm questions based on the tree structure.</p>
<a id="more"></a>
<p>This article describes several key considerations of the tree and binary search tree, we first describe the commonly techniques and thinking perspectives to solve these type of problems and then we list several specific problem and there soluations, we may put these solutions into different blogs in future.</p>
<p>The list of sample questions come from <a href="https://docs.google.com/spreadsheets/d/1yRCOJ8KysRVkq0O9IlDriT01tC6lzPapmFO4PCmDJQA/edit#gid=972946549" target="_blank" rel="noopener">here</a></p>
<p>This is also a good resource to classify all kinds of problems.</p>
<h3 id="Key-techniques-and-considerations"><a href="#Key-techniques-and-considerations" class="headerlink" title="Key techniques and considerations"></a>Key techniques and considerations</h3><ul>
<li><p>(1) Classification of the tree node, instead of classifying it into the leaf or null leaf, just assume it is null or not null, or more complex form such as 968 (covered or not covered, 450 is also a good classification example, leaf node, have 1 child, have two child), 257 classifies the node to null node, leaf node and not null node.</p>
</li>
<li><p>(2) From up to bottom, the lower level nodes need the information of the upper level nodes.</p>
</li>
<li><p>(3) From bottom to up, the left and right child tree returns root or specific value, the upper level nodes needs the information of the lower level nodes or subtrees. Make sure which is more eaiser. Sometimes knowing the child status then compute the parent status is more easier, some times knowing parent status then process child case is more easier. 337 is a good example in this case. 98 is a good example to try both bottom to up and up to the bottom case.</p>
</li>
<li><p>(4) Bst tree, the in order traverse (LNR) is the array with ascending values</p>
</li>
<li><p>(5) Typical strategy to insert or delete the node, how to acquire the parent pointer for different questions (the 450 can be a complex one for this type)</p>
</li>
<li><p>(6) The idea of calling level is important for these type of questions, For example, we may print the information of recursion level to debug the code. Besides, for the searching path, remember that the element need to be poped out after each level function call, this techniques are used in 257 and the 437.</p>
</li>
<li><p>(7) When there is the combination of tree and the string, the key step is to map the string into the tree structure logically and we ususlly does not need an explicit tree in that case. But we may use the recursion method. It is important to remember several typical questions and what are the gaps here.</p>
</li>
</ul>
<p>Here are some key thinking perspectives, these ideas can also be used to solving other problems, these steps are useful especially when you do not have ideas for solving current problem </p>
<ul>
<li><p>Consider the data structure adopted by the problem, from the domain specific problem to a cs algorithm problem, this step is comparatively simple for easy or medium question</p>
</li>
<li><p>Confirm the type of problem, typically type of problem is modify, search specific results or compute optimization situation. After confirming this, we can further move to another step.</p>
</li>
<li><p>For the problem of searching, we first need to figure out the total status and the total combinations, then we use the constrains and the techniques discussed above to narrow down these situations. For the problem of modifying, just be caring of common operations for create delete nodes, the tricks of keeping parent pointer etc.</p>
</li>
<li><p>Other specific type of problems (such as search possible solutions) are related to tree, but not totally related, we use another blog to discuss these questions (parathesis match, work search, sudoku problem, queens problem and puzzle problem).</p>
</li>
</ul>
<h3 id="Typical-questions-Traverse-tree"><a href="#Typical-questions-Traverse-tree" class="headerlink" title="Typical questions: Traverse tree"></a>Typical questions: Traverse tree</h3><p><strong>94. Binary Tree Inorder Traversal</strong></p>
<p>This is really typical one, the inorder traversal represents the LNR traversal. The node type is divided into nullptr or not nullptr, this can be the basic framework for more complicated algorithm. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; ans; </span><br><span class="line">        help(root, ans);  </span><br><span class="line">        return ans;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void help(TreeNode* root, vector&lt;int&gt;&amp; ans)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // left</span><br><span class="line">        help(root-&gt;left,ans);</span><br><span class="line">        // current</span><br><span class="line">        ans.push_back(root-&gt;val);</span><br><span class="line">        // right</span><br><span class="line">        help(root-&gt;right, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>144 and 145 are similar problems, they are preorder (NLR) and postorder (LRN) traversal, respectively. 589 and 590 is the N children problem.</p>
<p><strong>429. N-ary Tree Level Order Traversal</strong></p>
<p>how to process the height information? There is no associated variable defination in the tree structure. This is the code that use the BFS style code based on the queue. The key idea that label the level is to <em>remember the queue size after each level</em>. Then at the next iteration, we just need to pop out the node in the previous level, and then the remaning elements are nodes on the current level. We do similar things and move to the next iteration step by step.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// Time complexity O(n)</span><br><span class="line">// Space complexity O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        vector&lt;int&gt; temp;</span><br><span class="line">        help(root, ans, temp, true);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    void help(Node* root,vector&lt;vector&lt;int&gt;&gt;&amp; ans,vector&lt;int&gt;&amp; temp, bool iflast)&#123;</span><br><span class="line">        //put the temp into the ans if switch the height</span><br><span class="line">        //if the current node is null, hit a new level, then push</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;   </span><br><span class="line">        q.push(root);</span><br><span class="line">        int levelsize = q.size();</span><br><span class="line">        while(q.empty()==false)&#123;</span><br><span class="line">            while(levelsize&gt;0)&#123;        </span><br><span class="line">                levelsize--;</span><br><span class="line">                Node* curr=q.front();</span><br><span class="line">                temp.push_back(curr-&gt;val);</span><br><span class="line">                q.pop();</span><br><span class="line"></span><br><span class="line">                for(int i=0;i&lt;curr-&gt;children.size();i++)&#123;</span><br><span class="line">                    q.push(curr-&gt;children[i]);</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;    </span><br><span class="line">            // this layer finish</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">            temp.clear();</span><br><span class="line">            // current queue size, there are qsize element</span><br><span class="line">            // the elements in the queue are elements at a new level now</span><br><span class="line">            levelsize = q.size();</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Another similar code is <a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solution/cong-shang-dao-xia-da-yin-er-cha-shu-ii-fzejw/" target="_blank" rel="noopener">this one</a> we basically need one while loop to adjust the q size and one for loop (or while loop) to monitor the number of current level.</p>
<p>The code can also be written in an <a href="https://zxi.mytechroad.com/blog/tree/leetcode-107-binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">recursive way</a>. The general framework of recursion is easy to write, the key part is that we set the depth and insert the associated elements into the proper position. We also insert the empty array into the ans vector during the recursion process. The code of the recursive way is more clean. This is actually the dfs code, which is not the bfs code !!! The recursion call is in the dfs order.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        help(root, ans, 0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void helper(Node* root, vector&lt;vector&lt;int&gt;&gt;&amp;ans, int depth)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //if the new layer</span><br><span class="line">        if(ans.size()&lt;(depth+1))&#123;</span><br><span class="line">            ans.push_back(&#123;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        // visit node</span><br><span class="line">        ans[depth].push_back(root-&gt;val);</span><br><span class="line">        // call children recursively</span><br><span class="line">        for(auto child: root-&gt;children)&#123;</span><br><span class="line">            help(child, ans, depth+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Similar problem:</p>
<p>102 is also similar one, just using the level order, the code is simple when using the recursion method discussed above.</p>
<p>107 its input data structure is the binary tree, which is the simplified version of the 429. The 107 require the output sequence from the bottom to up. So we only need to add <code>reverse(ans.begin(), ans.end())</code> before returning the ans.</p>
<p>104 is also similar one, just compute the maxdepth of the tree direactly.</p>
<p><strong>987. Vertical Order Traversal of a Binary Tree</strong></p>
<p>Using the data structure in a wise way is the key for this question. The first key of the map indicates the column, the second key indicates the row, the multiset indicates there are multiple elements in same column, row index and the elements is stored in ascending manner, and the elements can also be repeated in the set.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; verticalTraversal(TreeNode* root) &#123;</span><br><span class="line">        // why use the multiset: check this data [3,1,4,0,2,2]</span><br><span class="line">        map&lt;int, map&lt;int, multiset&lt;int&gt;&gt;&gt; mymap;</span><br><span class="line">        helper(root, mymap, 0, 0);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans (mymap.size());</span><br><span class="line">        int i=0;</span><br><span class="line">        for(auto it:mymap)&#123;</span><br><span class="line">            for(auto itmapset : it.second)&#123;</span><br><span class="line">                for(auto itset: itmapset.second)&#123;</span><br><span class="line">                    //printf(&quot;itset %d\n&quot;,itset);</span><br><span class="line">                    ans[i].push_back(itset);                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void helper(TreeNode* root, map&lt;int, map&lt;int, multiset&lt;int&gt;&gt;&gt;&amp; mymap, int row, int column)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mymap[column][row].insert(root-&gt;val);</span><br><span class="line">        //children</span><br><span class="line">        //left</span><br><span class="line">        helper(root-&gt;left, mymap, row+1, column-1);</span><br><span class="line">        //right</span><br><span class="line">        helper(root-&gt;right, mymap, row+1, column+1);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Compared with using a grid, using the ordered map is more simple, other soluation also use the pair as the key of the map</p>
<p>Similar questions:</p>
<p>1302, just sum up the deepest leaves, the question is, how do we know it is the deepest leaves. The idea is just using a spearate depth variable and keep the newest value, then add varaible into the sum </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// one solution for 1302</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth=0;</span><br><span class="line">    int layersum = 0;</span><br><span class="line">    int deepestLeavesSum(TreeNode* root) &#123;</span><br><span class="line">        helper(root, 0);</span><br><span class="line">        return layersum;</span><br><span class="line">    &#125;</span><br><span class="line">    void helper(TreeNode* root, int currDepth)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //visit node, add some trim operation </span><br><span class="line">        if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr)&#123;</span><br><span class="line">            if(currDepth&gt;maxDepth)&#123;</span><br><span class="line">                maxDepth =  currDepth;</span><br><span class="line">                layersum = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if(currDepth == maxDepth)&#123;</span><br><span class="line">                layersum = layersum + root-&gt;val;</span><br><span class="line">            &#125;          </span><br><span class="line">        &#125;</span><br><span class="line">        //move to the children</span><br><span class="line">        helper(root-&gt;left,currDepth+1);</span><br><span class="line">        helper(root-&gt;right,currDepth+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>257 Binary Tree Paths</strong></p>
<p>This question requires to print out the searching paths, one key idea is to adjust current searching path. We use a vector store the searching path, when current level of recursion finish, we then pop back the last element in the vector, by this way, we can always make sure the element in the vector is located in the current path. The similar ideas is also used in the 437, in that case, we decrease the associated path number after leaving the current recursion call each time. The search path here is based on the idea of the dfs essentially.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    vector&lt;string&gt; m_ans;</span><br><span class="line">    vector&lt;int&gt; m_path;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        return m_ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void helper(TreeNode* root)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //visit leaf node</span><br><span class="line">        m_path.push_back(root-&gt;val);</span><br><span class="line"></span><br><span class="line">        //if leaf, add path info</span><br><span class="line">        if(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr)&#123;</span><br><span class="line">            //put currpath into the m_ans</span><br><span class="line">            string tempstr;</span><br><span class="line">            for(int i=0;i&lt;m_path.size();i++)&#123;</span><br><span class="line">                if(i==0)&#123;</span><br><span class="line">                    tempstr=tempstr+to_string(m_path[i]);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    tempstr=tempstr+&quot;-&gt;&quot;+to_string(m_path[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            m_ans.push_back(tempstr);</span><br><span class="line">            </span><br><span class="line">            //remove one elem</span><br><span class="line">            //the leaf node return earlyer at this case</span><br><span class="line">            m_path.pop_back();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //children</span><br><span class="line">        helper(root-&gt;left);</span><br><span class="line">        helper(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        //remove elem in current level</span><br><span class="line">        m_path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Typical-questions-search-particular-properties-of-the-tree"><a href="#Typical-questions-search-particular-properties-of-the-tree" class="headerlink" title="Typical questions: search particular properties of the tree"></a>Typical questions: search particular properties of the tree</h3><p><strong>Compare if two trees are same, mirror or satisfies certain constraints</strong></p>
<p>100 check the same tree, we can use any type of iteration method discussed above, if there is null equal during the recursive process, return the false, otherwise, return true.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// be carefule for the several special cases for deciding the same tree</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSameTree(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if(p==nullptr &amp;&amp; q)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p &amp;&amp; q==nullptr)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p &amp;&amp; q)&#123;</span><br><span class="line">            //visit</span><br><span class="line">            if(p-&gt;val != q-&gt;val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            //check the child</span><br><span class="line">            bool leftSame = isSameTree(p-&gt;left, q-&gt;left);</span><br><span class="line">            </span><br><span class="line">            if(leftSame==false)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            bool rightSame = isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line"></span><br><span class="line">            if(rightSame==false)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;       </span><br><span class="line">        return true;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>572 Subtree of Another Tree, this is the updated version for comparing if two trees are same with each other. Traverse the original tree based on NLR sequence, if the node value equals with the subroot value, executed comparision operation. Otherwise, continue check.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">//572. Subtree of Another Tree</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSubtree(TreeNode* root, TreeNode* subRoot) &#123;</span><br><span class="line">        //edge cases</span><br><span class="line">        if(!root &amp;&amp; !subRoot)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!subRoot)&#123;</span><br><span class="line">            // subroot is null but root is not</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!root)&#123;</span><br><span class="line">            // the root is null but subRoot is not null</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //go through left and right</span><br><span class="line">        bool leftContain = isSubtree(root-&gt;left, subRoot);</span><br><span class="line">        bool rightContain = isSubtree(root-&gt;right, subRoot);</span><br><span class="line">        </span><br><span class="line">        if(leftContain || rightContain)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(leftContain == false &amp;&amp; rightContain==false)&#123;</span><br><span class="line">            if(root-&gt;val == subRoot-&gt;val)&#123;</span><br><span class="line">                bool same=isSameTree(root, subRoot);</span><br><span class="line">                if(same)&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool isSameTree(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if(p==nullptr &amp;&amp; q)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p &amp;&amp; q==nullptr)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p &amp;&amp; q)&#123;</span><br><span class="line">            //visit</span><br><span class="line">            if(p-&gt;val != q-&gt;val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            //check the child</span><br><span class="line">            bool leftSame = isSameTree(p-&gt;left, q-&gt;left);</span><br><span class="line">            </span><br><span class="line">            if(leftSame==false)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            bool rightSame = isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line"></span><br><span class="line">            if(rightSame==false)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;       </span><br><span class="line">        return true;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The above code reuse the function of 100, it still looks a little bit complicated and error prone. For the edge cases, we need to consider four situations and confirm the case that one of the child is nullptr. It also uses the idea of compare left part then compare the right part, since there is a return value of the function. For example, after deciding that the left part do not contain subtree, the right part does not contain subtree and the current root does not contains subtree, we can returns the false.</p>
<p>The 101 symmetric tree is also a similar question, the condition of mirror is just reverse the left and right, one case is right to left, another case is right to left, to decide if they are equal. This is similar with previous one, the difference is the traversal sequence. The origianl thought is to use LNR to traverse left and use RNL to traverse right, then compare the results. But this input <code>[1,2,2,2,null,2]</code> have the same results eigher for LNR and RNL. So it is not uniquely to decide if two parts are mirror of each other. Although the result is straightforward, it is not easy to provide the reuslts at the first glance.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return Compare(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool Compare(TreeNode* p, TreeNode* q)&#123;</span><br><span class="line">        if(p==nullptr &amp;&amp; q)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p &amp;&amp; q == nullptr)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p &amp;&amp; q)&#123;</span><br><span class="line">            //visit</span><br><span class="line">            if(p-&gt;val != q-&gt;val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            bool leftSame = Compare(p-&gt;left, q-&gt;right);</span><br><span class="line">            if(leftSame==false)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            bool rightSame = Compare(p-&gt;right, q-&gt;left);</span><br><span class="line">            if(rightSame==false)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;             </span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>110 check if the tree is balanced. This is a little bit special, since it introduce the idea from the bottom to up. Namely, the helper function returns some information and this information will be used by the upper level. These type of paradigm is used a lot when modify the tree structure.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">        int height=0;</span><br><span class="line">        return helper(root, height);  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool helper(TreeNode* root, int&amp; height)&#123;</span><br><span class="line">        if(!root)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        //left balanced</span><br><span class="line">        int leftHeight=0;</span><br><span class="line">        bool leftBalanced = helper(root-&gt;left, leftHeight);</span><br><span class="line"></span><br><span class="line">        //right balanced</span><br><span class="line">        int rightHeight=0;</span><br><span class="line">        bool rightBalanced = helper(root-&gt;right, rightHeight);         </span><br><span class="line">        height=max(leftHeight,rightHeight)+1;</span><br><span class="line">        </span><br><span class="line">        //check diff</span><br><span class="line">        if(leftBalanced &amp;&amp; rightBalanced)&#123;</span><br><span class="line">            if(abs(leftHeight-rightHeight)&lt;=1)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>965 is also a similar one, just simple checking based on the bottom to up recursion. The properties for these questions is to detect the results of the subtree first and then use the return results to decide the current results.</p>
<p>872 is a similar one with the simple background, the idea of code classification is good. null ptr, leaf, one child, two childern. Pay attention to the sequence of the checking and make sure all situations are considered.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool leafSimilar(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">         //get leaf sequecnce of the first one</span><br><span class="line">        vector&lt;int&gt; seq1;</span><br><span class="line">        getLeafSeq(root1, seq1);</span><br><span class="line">        // get leaf sequence of the second one</span><br><span class="line">        vector&lt;int&gt; seq2;</span><br><span class="line">        getLeafSeq(root2, seq2);</span><br><span class="line">        </span><br><span class="line">        if(seq1.size()!=seq2.size())&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;seq1.size();i++)&#123;</span><br><span class="line">            if(seq1[i]!=seq2[i])&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void getLeafSeq(TreeNode* root, vector&lt;int&gt;&amp; ans)&#123;</span><br><span class="line">        //null</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //leaf</span><br><span class="line">        if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr)&#123;</span><br><span class="line">            ans.push_back(root-&gt;val);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //one child</span><br><span class="line">        if(root-&gt;left)&#123;</span><br><span class="line">            getLeafSeq(root-&gt;left, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right)&#123;</span><br><span class="line">            getLeafSeq(root-&gt;right, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>min or max path of the tree, path sum or path with particualr constraints</strong></p>
<p>111 check the minimum depth. It also use the similar strategy. Check the min depth of the left and right part, and then return the min of the left and right value plus one. Be careful for processing the null node. Since we just return 0 direactly. When we compare the return value, this node is not accounted into the depth of the tree. For the test case such as <code>[2,null,3,null,4,null,5,null,6]</code>, the return value is 5. When we check the min value, we do not consider the return value with the 0. Since the leaf node is the node with no children. Which should return 1 at least.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 111 Minimum Depth of Binary Tree</span><br><span class="line">class Solution &#123;</span><br><span class="line">    int mindepth = 0;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">        return helper(root);</span><br><span class="line">    &#125;</span><br><span class="line">    int helper(TreeNode* root)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;  </span><br><span class="line">        //ldepth</span><br><span class="line">        int ldepth =  helper(root-&gt;left);     </span><br><span class="line">        //rdpeth</span><br><span class="line">        int rdepth=helper(root-&gt;right);     </span><br><span class="line">        //current depth</span><br><span class="line">        int currdepth = 0;</span><br><span class="line">        if(ldepth==0 &amp;&amp; rdepth !=0)&#123;</span><br><span class="line">            currdepth = rdepth+1;</span><br><span class="line">        &#125;else if (rdepth==0 &amp;&amp; ldepth!=0)&#123;</span><br><span class="line">            currdepth = ldepth+1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            currdepth = min (ldepth, rdepth)+1;        </span><br><span class="line">        &#125;</span><br><span class="line">        return currdepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>112.Path Sum, using the NLR to traverse the tree and decrease the target sum each time going to the next level. Only return true at the case where node is the leaf node and satisfies the targeted. Using the idea from the up to bottom is more natural for this one. The idea of considering things in sequence and in a complete way is important, the null node, the leaf node and the non-leaf node. </p>
<p>Actually, the good practice here is to consider the edge case firstly, since we can return it direactly and to not do the subsequent checking, then the remaning logic is the general case. So, the good practice for the recursion operation is to write the return entry firstly and then check the recursion part, but when we thinking it, we may consider the recursion part firstly and then the return part.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        if(root == nullptr)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //visit current node</span><br><span class="line">        //if leaf</span><br><span class="line">        if(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr)&#123;</span><br><span class="line">            if(targetSum==root-&gt;val)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //check left and right</span><br><span class="line">        bool left = hasPathSum(root-&gt;left, targetSum-root-&gt;val);</span><br><span class="line">        if(left)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        bool right = hasPathSum(root-&gt;right, targetSum-root-&gt;val);</span><br><span class="line">        if(right)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>129 Sum Root to Leaf Numbers is a similar question of 112, just times 10 when visiting the leaf node when adding the new path.</p>
<p>113 is the updated version of the 112, it requires to memory the specific path that satisfies the requirments, it is a typical search problem (both the start and the end of the search path is clear). This idea and associated code can be the framework for many more complicated problem.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//113 Path Sum II</span><br><span class="line">class Solution &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; m_ans;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        helper(root, targetSum, &#123;&#125;);</span><br><span class="line">        return m_ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void helper(TreeNode* root, int targetSum, vector&lt;int&gt; currpath)&#123;</span><br><span class="line">        //null node</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //leaf node</span><br><span class="line">        if(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr)&#123;</span><br><span class="line">            currpath.push_back(root-&gt;val);</span><br><span class="line">            //put temp to ans if satisfies requrements</span><br><span class="line">            if(root-&gt;val == targetSum)&#123;</span><br><span class="line">                m_ans.push_back(currpath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //non-leaf node</span><br><span class="line">        //update current path</span><br><span class="line">        //search sub tree</span><br><span class="line">        currpath.push_back(root-&gt;val);</span><br><span class="line">        helper(root-&gt;left, targetSum-root-&gt;val, currpath);</span><br><span class="line">        helper(root-&gt;right, targetSum-root-&gt;val, currpath);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>437(tricky) This is the updated version of the path sum. Compared with the previous one, the started position is not clear, the end of the path is also not clear.</p>
<p>special cases</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1,null,2,null,3,null,4,null,5]</span><br><span class="line">3</span><br><span class="line">[1,-2,-3,1,3,-2,null,-1]</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>solution1, use naive recursion, there might be time limit exceeded issue (did not realize the issue of the start and end point)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//version 1, error prone</span><br><span class="line">//it requires to express the start point or end point clearly</span><br><span class="line">class Solution &#123;</span><br><span class="line">    int m_pathNum=0;</span><br><span class="line">    int m_origianlTarget=0;</span><br><span class="line">public:</span><br><span class="line">    int pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        m_origianlTarget = targetSum;</span><br><span class="line">        helper(root, &#123;&#125;, targetSum, true, 0);</span><br><span class="line">        return m_pathNum;</span><br><span class="line">    &#125;</span><br><span class="line">    //runtime issue for this code</span><br><span class="line">    void helper(TreeNode* root, vector&lt;int&gt; path, int temptargetSum, bool parentAdded, int level)&#123;</span><br><span class="line">        //null</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">                       </span><br><span class="line">        //path does not contains root, use the origianl target</span><br><span class="line">        //this should be considered firstly</span><br><span class="line">        //this can be called multiple times potentially</span><br><span class="line">        //first node, call this, otherwise, use the tempsum</span><br><span class="line">        if(parentAdded==false || path.size()==0)&#123;</span><br><span class="line">            //potentially start point</span><br><span class="line">            helper(root-&gt;left, &#123;&#125;, m_origianlTarget, false, level+1);</span><br><span class="line">            helper(root-&gt;right, &#123;&#125;,m_origianlTarget, false, level+1);          </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        //path contains the current node</span><br><span class="line">        //visit current</span><br><span class="line">        //bool isend = false;</span><br><span class="line">        if(root-&gt;val == temptargetSum)&#123;</span><br><span class="line">            if(parentAdded==true || path.size()==0)&#123;</span><br><span class="line">                //potentially end point</span><br><span class="line">                m_pathNum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //path contains root</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        helper(root-&gt;left, path,temptargetSum-root-&gt;val, true, level+1);</span><br><span class="line">        helper(root-&gt;right, path,temptargetSum-root-&gt;val, true, level+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The following code is the optimization of the version 1, the key point is to figure out if the current node is at the start position or at the following position, that is really important, use equals to 0 to decide the condition is more simplifier than the origianl case,we need to type fewer words in this case.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int m_pathNum=0;</span><br><span class="line">    long long m_origianlTarget=0;</span><br><span class="line">public:</span><br><span class="line">    int pathSum(TreeNode* root, long long targetSum) &#123;</span><br><span class="line">        m_origianlTarget = targetSum;</span><br><span class="line">        helper(root, targetSum, true);</span><br><span class="line">        return m_pathNum;</span><br><span class="line">    &#125;</span><br><span class="line">    //runtime issue for this code</span><br><span class="line">    void helper(TreeNode* root,long long int temptargetSum, bool ifstart)&#123;</span><br><span class="line">        //null</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //first node, call this, otherwise, use the tempsum</span><br><span class="line">        if(ifstart)&#123;</span><br><span class="line">            //start point</span><br><span class="line">            helper(root-&gt;left, m_origianlTarget, true);</span><br><span class="line">            helper(root-&gt;right, m_origianlTarget, true);          </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        temptargetSum-=root-&gt;val;</span><br><span class="line">        if(temptargetSum == 0)&#123;</span><br><span class="line">            //for the end node, do not check the subsequent nodes</span><br><span class="line">            m_pathNum++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //path contains root, other nodes are followers</span><br><span class="line">        //still check till the last one, the node can be negative</span><br><span class="line">        //there value may conteract with each other</span><br><span class="line">        helper(root-&gt;left, temptargetSum, false);</span><br><span class="line">        helper(root-&gt;right, temptargetSum, false); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This code is much more simple and refer to this <a href="https://zxi.mytechroad.com/blog/tree/leetcode-437-path-sum-iii/" target="_blank" rel="noopener">blog</a> , attention that for the first layer, the function name is the pathSum instead of the helper.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int pathSum(TreeNode* root, long long int targetSum) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        return helper(root, targetSum)+pathSum(root-&gt;left, targetSum)+pathSum(root-&gt;right, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int helper(TreeNode* root, long long int tempsum)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tempsum -= root-&gt;val;</span><br><span class="line">        return (tempsum == 0 ? 1 : 0)+helper(root-&gt;left,tempsum)+helper(root-&gt;right,tempsum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Lesson: one important idea is how to debug in recursion code: we might add the level into the print info, this can be an indicator and it can change the flattern code into the hierachy code and check the horizental and vertical. By doing this, we can find an error in our origianl code, at that time, we forget to add the condition when the path is just started. However, it is difficult to figure it out and understanding the code behaviours without the help of the debug info.</p>
<p>This code can be further optimized based on the 560 that computes the prefix sum. The single path in 560 changes to the multiple path on the tree for this question. Here is the optimization version for this question based on the idea of 560</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int m_pathNum=0;</span><br><span class="line">    int m_count = 0;</span><br><span class="line">    unordered_map&lt; long int, int&gt; psum;</span><br><span class="line">public:</span><br><span class="line">    int pathSum(TreeNode* root,  long targetSum) &#123;</span><br><span class="line">        //for the case when the element itsself equals to the targetSum</span><br><span class="line">        psum[0]=1; </span><br><span class="line">        helper(root, targetSum, 0);</span><br><span class="line">        return m_count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void helper(TreeNode* root, long int targetSum,  long currentSum)&#123;</span><br><span class="line">        //null</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //visit current node</span><br><span class="line">        //visit left and right from up to bottom</span><br><span class="line">        currentSum = currentSum+root-&gt;val;</span><br><span class="line"></span><br><span class="line">        int previousSum = currentSum - targetSum;</span><br><span class="line">        //printf(&quot;previousSum %d &quot;, previousSum);</span><br><span class="line">        m_count = m_count+psum[previousSum];</span><br><span class="line">        </span><br><span class="line">        //put current sum into the map</span><br><span class="line">        //default value is 0 for empty element</span><br><span class="line">        psum[currentSum]++;</span><br><span class="line">        </span><br><span class="line">        helper(root-&gt;left, targetSum, currentSum);</span><br><span class="line">        helper(root-&gt;right, targetSum, currentSum);</span><br><span class="line">        </span><br><span class="line">        //this is a really important part from the single path sum to the tree based path sum</span><br><span class="line">        //this is much smarter than copy the map between each recursion call</span><br><span class="line">        psum[currentSum]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The main part of visiting the node is same with the 560, main difference is that, remember to decrease specific elements from map after each call. Essentially, we need a different map for each path, but copy past map direactlly in each call is also time consuming, so we just adjust values in the map dynamically to make sure it works for different path.</p>
<p><strong>508. Most Frequent Subtree Sum</strong></p>
<p>The traversal part is common one, using the idea from the bottom to up, the subtree returns a particular value. The extra part is to use a map to keep track of the sum  during the tree traversal process. When the max freq is updated, we clear the ans, when freq of current sum equals to the max freq, we push the current sum, when the current sum is less than freq, we do nothing. (when there is tie means there are same frequent number for the two cases) </p>
<p>Start and the end of the path sum is comparatively clear in this question, which decrease its level of difficulty.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int maxFreq = 0;</span><br><span class="line">    //key is sum value is freq</span><br><span class="line">    unordered_map&lt;int, int&gt; freMap;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findFrequentTreeSum(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        helper(root, ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int helper(TreeNode* root, vector&lt;int&gt;&amp; ans)&#123;</span><br><span class="line">        </span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        </span><br><span class="line">        //get left sum</span><br><span class="line">        int leftSum = helper(root-&gt;left, ans);</span><br><span class="line">        </span><br><span class="line">        //get right sum</span><br><span class="line">        int rightSum = helper(root-&gt;right, ans);</span><br><span class="line">        </span><br><span class="line">        //with the current sum</span><br><span class="line">        int currSum = leftSum+rightSum+root-&gt;val;</span><br><span class="line">        </span><br><span class="line">        //compute freq, if not exist, default is 0</span><br><span class="line">        int currFreq = freMap[currSum]+1;</span><br><span class="line">        freMap[currSum]=currFreq;</span><br><span class="line">        </span><br><span class="line">        if(maxFreq&lt;currFreq)&#123;</span><br><span class="line">            //update the MaxFreq and ans</span><br><span class="line">            ans.clear();</span><br><span class="line">            maxFreq = currFreq;</span><br><span class="line">            // when equal, current freq is the maximum one update ans</span><br><span class="line">            ans.push_back(currSum);</span><br><span class="line">        &#125;else if(maxFreq==currFreq)&#123;</span><br><span class="line">            ans.push_back(currSum);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //do nothing when large than current</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return currSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>124 Binary Tree Maximum Path Sum</strong></p>
<p>The setting of the question is not that much straightforward and the start and end point of the path is not certained. We could confirm the general framework of the question, and use the bottom to up method approach. The tricky part is to make sure the return value and how to visit the current node.</p>
<p>The key thinking perspective is considering if the current node is included in the path. The maximum path can be following several options: left sum path + root, right sum path + root, left sum path + root + right sum path, or just the root itself (this situation is easy to be forgottern), since the node value can be negative, all these situations can be the maximum case.</p>
<p>The return part is also tricky, we just return the max value among the left side, the right side and the node itsself. Instead of returing the current possible max path sum. Since we just needs the left path or right path of the subtree to construct the new path. Anyway, the code is straightforward and the answer might need some time to come up with. Since the minpath and the return value for each recurssion call are two different variables here.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int maxSum = INT_MIN;</span><br><span class="line">public:</span><br><span class="line">    int maxPathSum(TreeNode* root) &#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        return maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int helper(TreeNode* root)&#123;</span><br><span class="line">        if(root==nullptr) return 0;  </span><br><span class="line">        //left</span><br><span class="line">        int lpsum = helper(root-&gt;left);</span><br><span class="line">        //right</span><br><span class="line">        int rpsum = helper(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        //visit &amp; compare</span><br><span class="line">        int lrsum = lpsum+root-&gt;val;</span><br><span class="line">        maxSum = max(maxSum, lrsum);</span><br><span class="line">        int rrsum = rpsum+root-&gt;val;</span><br><span class="line">        maxSum = max(maxSum, rrsum);</span><br><span class="line">        int lrrsum = lpsum+root-&gt;val+rpsum;</span><br><span class="line">        maxSum = max(maxSum, lrrsum);</span><br><span class="line">        </span><br><span class="line">        //single node without the child</span><br><span class="line">        //may also be the largest one</span><br><span class="line">        maxSum = max(maxSum, root-&gt;val);        </span><br><span class="line">        return max(max(lrsum, rrsum),root-&gt;val);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>543. Diameter of Binary Tree</strong></p>
<p>One similar question is the 543 which compute the diameter of the tree, these two questions use similar strategy and code framework. The 543 can be the foundataion of this question. The important point is that the helper function should not return the whole length, and it should return the max of left path or right path of the subtree. Another smart point is that they return -1 in their code when there is nullptr, which simplifies the expression from 2 layer node classification to 1 layer node classification. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int diameterOfBinaryTree(TreeNode* root) &#123;</span><br><span class="line">        int maxpath=0;</span><br><span class="line">        childp(root,maxpath);</span><br><span class="line">        return maxpath;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int childp(TreeNode* root, int&amp; maxpath)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // when connect with the root, the path length should increase 1</span><br><span class="line">        int lpath = childp(root-&gt;left,maxpath)+1;</span><br><span class="line">        int rpath = childp(root-&gt;right,maxpath)+1;</span><br><span class="line">        maxpath = max(maxpath, lpath+rpath);</span><br><span class="line">        return max(lpath,rpath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>687. Longest Univalue Path</strong></p>
<p>The idea of this question is not diffecult, it is a little bit similar with previous several questions, the key part is consider every situation clearly</p>
<p>For the version1, we calssify the node by null, leave node, one child, two children case. Then in the two children case, we further consider the relationship between the root node and the child node.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int maxpath;</span><br><span class="line">public:</span><br><span class="line">    int longestUnivaluePath(TreeNode* root) &#123;</span><br><span class="line">        lup(root);</span><br><span class="line">        return maxpath;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int lup(TreeNode* root)&#123;</span><br><span class="line">        //root null</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //leaf node</span><br><span class="line">        if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //at least one child</span><br><span class="line">        int lpath = lup(root-&gt;left);</span><br><span class="line">        int rpath = lup(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        //one child case</span><br><span class="line">        if(root-&gt;left &amp;&amp; root-&gt;right==nullptr)&#123;</span><br><span class="line">            if(root-&gt;val == root-&gt;left-&gt;val)&#123;</span><br><span class="line">               lpath++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">               lpath=0; </span><br><span class="line">            &#125;</span><br><span class="line">            maxpath=max(maxpath,lpath);</span><br><span class="line">            return lpath;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(root-&gt;right &amp;&amp; root-&gt;left==nullptr)&#123;</span><br><span class="line">            if(root-&gt;val == root-&gt;right-&gt;val)&#123;</span><br><span class="line">                rpath++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                rpath=0;</span><br><span class="line">            &#125;     </span><br><span class="line">            maxpath=max(maxpath,rpath);</span><br><span class="line">            return rpath;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        //two children case</span><br><span class="line">        //both left and right exist</span><br><span class="line">        </span><br><span class="line">        //if root node not equals to both side</span><br><span class="line">        if(root-&gt;val != root-&gt;left-&gt;val &amp;&amp; root-&gt;val != root-&gt;right-&gt;val)&#123;</span><br><span class="line">            maxpath=max(maxpath,0);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //root node equals to both side        </span><br><span class="line">        if(root-&gt;val == root-&gt;left-&gt;val&amp;&amp;root-&gt;val == root-&gt;right-&gt;val)&#123;</span><br><span class="line">            maxpath=max(maxpath,lpath+1+rpath+1);</span><br><span class="line">            return max(lpath+1, rpath+1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //if root node eqauls to one side</span><br><span class="line">        //left side</span><br><span class="line">        if(root-&gt;val == root-&gt;left-&gt;val)&#123;</span><br><span class="line">            maxpath=max(maxpath,lpath+1);</span><br><span class="line">            return lpath+1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //rside</span><br><span class="line">        maxpath=max(maxpath,rpath+1);</span><br><span class="line">        return rpath+1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>For the case2, we kind of merge the situation where there is one children and two<br>children case. Since when wen want to decide the situation of two children, we need to first decide the case when there is one children.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int maxpath;</span><br><span class="line">public:</span><br><span class="line">    int longestUnivaluePath(TreeNode* root) &#123;</span><br><span class="line">        lup(root);</span><br><span class="line">        return maxpath;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int lup(TreeNode* root)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int lpath = lup(root-&gt;left);</span><br><span class="line">        int rpath = lup(root-&gt;right);</span><br><span class="line">                </span><br><span class="line">        if(root-&gt;left)&#123;</span><br><span class="line">            if(root-&gt;val == root-&gt;left-&gt;val)&#123;</span><br><span class="line">               lpath++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">               lpath=0; </span><br><span class="line">            &#125;</span><br><span class="line">            maxpath=max(maxpath,lpath);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(root-&gt;right)&#123;</span><br><span class="line">            if(root-&gt;val == root-&gt;right-&gt;val)&#123;</span><br><span class="line">                rpath++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                rpath=0;</span><br><span class="line">            &#125;     </span><br><span class="line">            maxpath=max(maxpath,rpath);</span><br><span class="line">            //consider the case that root equals to child</span><br><span class="line">            if(root-&gt;left&amp;&amp;root-&gt;val == root-&gt;left-&gt;val&amp;&amp;root-&gt;val == root-&gt;right-&gt;val)&#123;</span><br><span class="line">                maxpath=max(maxpath,lpath+rpath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max(lpath,rpath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>236(235). Lowest Common Ancestor of a Binary Tree</strong></p>
<p>The naive solution is to use the idea based on the 257 which can remember the path of the tree traverse based on the dfs. When the node comes to the p, remember the path. When the node comdes to the q, remember the path. Then compare two path to find the last one that  is same with each other. This node is the LCA node. For this solution, remember that we can not guarantee the sequence to find the p or q, it is possible to find p first or find the q first.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    vector&lt;TreeNode*&gt; m_pathp;</span><br><span class="line">    vector&lt;TreeNode*&gt; m_pathq;</span><br><span class="line">    vector&lt;TreeNode*&gt; m_currpath;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        bool findp = false;</span><br><span class="line">        bool findq = false;</span><br><span class="line"></span><br><span class="line">        helper(root, p, q, findp, findq);</span><br><span class="line">        //fill int the m_pathp and m_pathq</span><br><span class="line">        int index = min(m_pathp.size(), m_pathq.size());</span><br><span class="line">        TreeNode* temp = nullptr;</span><br><span class="line">        //the unique value must exist</span><br><span class="line">        for(int i=0;i&lt;index;i++)&#123;</span><br><span class="line">            printf(&quot; %d &quot;, m_pathp[i]-&gt;val);</span><br><span class="line">            if(m_pathp[i]-&gt;val!=m_pathq[i]-&gt;val)&#123;</span><br><span class="line">                //find the first different node on the path</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=m_pathp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //the first one can be either p or q</span><br><span class="line">    void helper(TreeNode* root, TreeNode* p, TreeNode* q, bool&amp; findp, bool&amp; findq)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(findp == true &amp;&amp; findq == true)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //visit node in path</span><br><span class="line">        m_currpath.push_back(root);</span><br><span class="line">        </span><br><span class="line">        //when node comes to p</span><br><span class="line">        if(root-&gt;val==p-&gt;val)&#123;</span><br><span class="line">            //find p</span><br><span class="line">            //snapshot path</span><br><span class="line">            m_pathp = m_currpath;</span><br><span class="line">            findp = true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //when node comes to q</span><br><span class="line">        //compare with previous path</span><br><span class="line">        if(root-&gt;val==q-&gt;val)&#123;</span><br><span class="line">            //find q</span><br><span class="line">            //find the correct path</span><br><span class="line">            m_pathq = m_currpath;</span><br><span class="line">            findq = true;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        //left and right</span><br><span class="line">        helper(root-&gt;left, p, q, findp, findq);</span><br><span class="line">        helper(root-&gt;right, p, q, findp, findq);</span><br><span class="line">        //remove last element</span><br><span class="line">        m_currpath.pop_back(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This is another solution for this question. It use the idea that combines both top to down and bottom to up, it uses both current value and the value of lchild or rchild to decide the least common node in the tree. This method can avoid some unnecessary recursion operations.</p>
<p>It can decrease some search path depending the position of p and q. Consider the three node, current node (c), p and q. There are several possibilities about their positions:</p>
<p>a)p and q are not at the subtree of the c, return null in this case.<br>b)p and q are at the left subtree and right subtree respectively, return c in this case.<br>c)p and q are at one subtree of the c.</p>
<p>There are two further situations for the case c), the first one is that the c equals to p or q, return the c direactly in this case. Another situation is that the c not equals to p or q, in this case, return the lchild or rchild that is not null.</p>
<p>Here is a good explanation for this question (<a href="https://www.youtube.com/watch?v=KobQcxdaZKY" target="_blank" rel="noopener">https://www.youtube.com/watch?v=KobQcxdaZKY</a>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        //check current node</span><br><span class="line">        if(root == nullptr)&#123;</span><br><span class="line">            //for processing the edge case</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //current is p or q, return direactly</span><br><span class="line">        if(root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val)&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //lchild</span><br><span class="line">        TreeNode* lchild = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        //rchild</span><br><span class="line">        TreeNode* rchild = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        //if both of them is null</span><br><span class="line">        if(lchild == nullptr &amp;&amp; rchild ==nullptr)&#123;</span><br><span class="line">            // not contain p q in subtree</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //if both of them is not null</span><br><span class="line">        if(lchild &amp;&amp; rchild)&#123;</span><br><span class="line">            //current is the lsc</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //if one of them is null, return the specific one</span><br><span class="line">        //use conditional operator if we must return sth</span><br><span class="line">        return lchild==nullptr?rchild:lchild;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>968. Binary Tree Cameras</strong></p>
<p>It looks like a dp problem, since for each step, we can choose place camera or not</p>
<p>There is one answer looks a little bit complicated, but we considered things in a systamaticall way. Nameyly, null node, one child case and two children case. The status transfer between the two levels of the tree is important for solving the problem. </p>
<p>One tricky part is that when both left and right is the no camera but covered status, we have two options for the current node, either put camera here or weight for its parent. It looks that the dp approach is more general soluation. By analyzing this problem we can find that iftop is true, we prefer to put camera, other wise, we wait for the upper level node to put the camera.</p>
<p>I still did not figure out the how to compress the one child case, some code returns the camera monitored status when the node is null.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">// from top to down not right, for the case that medium node is monitored, we added more node</span><br><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    enum STATUS &#123;CM = 0, NCM = 1, NCNM=2&#125;;</span><br><span class="line">    int ans=0;</span><br><span class="line">    int minCameraCover(TreeNode* root) &#123;</span><br><span class="line">        //root is null</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //only one layer</span><br><span class="line">        if(root-&gt;left == nullptr &amp;&amp; root-&gt;right==nullptr)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //at least two layers</span><br><span class="line">        helper(root, true);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //when it is not at the top position, we can always postpone the choice</span><br><span class="line">    STATUS helper(TreeNode* root, bool iftop)&#123;</span><br><span class="line">        //leaf node</span><br><span class="line">        if(root-&gt;left == nullptr &amp;&amp; root-&gt;right ==nullptr)&#123;</span><br><span class="line">            return STATUS::NCNM;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // check left status</span><br><span class="line">        STATUS lstatus;</span><br><span class="line">        STATUS rstatus;</span><br><span class="line">        </span><br><span class="line">        if(root-&gt;left)&#123;</span><br><span class="line">             lstatus = helper(root-&gt;left, false);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(root-&gt;right)&#123;</span><br><span class="line">             rstatus = helper(root-&gt;right,false);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        // left child</span><br><span class="line">        if(root-&gt;left == nullptr)&#123;</span><br><span class="line">            //check the right part</span><br><span class="line">            if(rstatus == STATUS::NCNM)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                return STATUS::CM;</span><br><span class="line">            &#125;else if(rstatus == STATUS::NCM)&#123;</span><br><span class="line">                if(iftop)&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    return STATUS::CM;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return STATUS::NCNM;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                return STATUS::NCM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(root-&gt;right == nullptr)&#123;</span><br><span class="line">            //check lstatus</span><br><span class="line">            if(lstatus == STATUS::NCNM)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                return STATUS::CM;</span><br><span class="line">            &#125;else if(lstatus == STATUS::NCM)&#123;</span><br><span class="line">                if(iftop)&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    return STATUS::CM;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return STATUS::NCNM;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return STATUS::NCM;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        // two children</span><br><span class="line">        if(lstatus == STATUS::NCM &amp;&amp; rstatus == STATUS::NCM)&#123;</span><br><span class="line">            //there are two options when both children are ncamera covered</span><br><span class="line">            if(iftop)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                return STATUS::CM;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return STATUS::NCNM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(lstatus == STATUS::NCNM || rstatus == STATUS::NCNM)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            return STATUS::CM;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //other cases</span><br><span class="line">        return STATUS::NCM;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>After simplifying the code and assume the null node is the dummy node with the status NCM, we can get this simple code, although the code is simple, but the logical process to create this code is not simple, we need to consider all 3*3 possibilities and compress them into the simplified form as follows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;   </span><br><span class="line">public:</span><br><span class="line">    enum STATUS &#123;CM = 0, NCM = 1, NCNM=2&#125;;</span><br><span class="line">    int ans=0;</span><br><span class="line">    int minCameraCover(TreeNode* root) &#123;</span><br><span class="line">        //root is null</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //at least two layers</span><br><span class="line">        helper(root, true);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //when it is not at the top position, we can always postpone the choice</span><br><span class="line">    STATUS helper(TreeNode* root, bool iftop)&#123;</span><br><span class="line">        //null</span><br><span class="line">        if(root == nullptr)&#123;</span><br><span class="line">            return STATUS::NCM;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        STATUS lstatus = helper(root-&gt;left,  false);</span><br><span class="line">        STATUS rstatus = helper(root-&gt;right, false);</span><br><span class="line">        </span><br><span class="line">        // two children, the null node can be viewed as a dummy child</span><br><span class="line">        if(lstatus == STATUS::NCM &amp;&amp; rstatus == STATUS::NCM)&#123;</span><br><span class="line">            //there are two options when both children are ncamera covered</span><br><span class="line">            if(iftop)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                return STATUS::CM;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return STATUS::NCNM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(lstatus == STATUS::NCNM || rstatus == STATUS::NCNM)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            return STATUS::CM;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //other cases</span><br><span class="line">        return STATUS::NCM;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>979. Distribute Coins in Binary Tree</strong></p>
<p>The code is easy, but the thinking perspective is important and it is not easy to get that point. We use the bottom to up method during the search, the return value for each layer represents how many coins is needed to make the current node and its subtree to satisfy the constraints (this idea is the key for solving the problem). For the simple case, such as the leaf node, the return value of the subtree is 0, they do not need extra coin move. For the case [3,0,0], at the node with value of 3, the return value of the left and right subtree is -1, we need move 1 conin to them. Then in order to make the node with value 3 become case that satisfies the requirements, we need to move 3-1 = 2. Adding this value with two return results, they become 2-1-1=0, so we do not need extra move. When we compute the move count, we use the abs value, no matter we move from current node or move to the current node, the move count through the edge should add one.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int moveNum=0;</span><br><span class="line">    int distributeCoins(TreeNode* root) &#123;</span><br><span class="line">        help(root);</span><br><span class="line">        return moveNum;</span><br><span class="line">    &#125;</span><br><span class="line">    int help(TreeNode* root)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //need how many coins</span><br><span class="line">        //the l and r can be balanced</span><br><span class="line">        int lcc=help(root-&gt;left);</span><br><span class="line">        int rcc=help(root-&gt;right);</span><br><span class="line">        //if the nullptr is not 1, we need to consider more cases here</span><br><span class="line">        //move one coin each time</span><br><span class="line">        moveNum = moveNum+abs(lcc)+abs(rcc);</span><br><span class="line">        int currentNeed = lcc+rcc+(root-&gt;val-1);</span><br><span class="line">        return currentNeed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>98. Validate Binary Search Tree</strong></p>
<p>The idea is not complicated, we make sure the left subtree is valid, the right subtree is valid, then adding the root into the tree to make the current tree is valid. There are two points, one is that we need to record the max value of the left tree to make sure current node is larger than all value in the left tree. Similar for the right subtree. Another is that the data range of the node is -2^31-1 to 2^31<br>This may lead to the case that the left or right node equals to the INT_MAX or INT_MIN (which is the initial status and the status when there is null node). Therefore, we need to consider the case when there is one child and two children separately to make some edge cases work. Otherwise, when the node contains INT_MAX or INT_MIN, the comparision might fail, since we could not provide a boundry value that contains these two values for integrer.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxinit = INT_MAX;</span><br><span class="line">    int mininit = INT_MIN;</span><br><span class="line">    </span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        return helper(root, maxinit, mininit);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool helper(TreeNode* root, int&amp; minV, int&amp;maxV)&#123;</span><br><span class="line">        //null node</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //leaf node</span><br><span class="line">        if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr)&#123;</span><br><span class="line">            maxV = root-&gt;val;</span><br><span class="line">            minV = root-&gt;val;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //one child node</span><br><span class="line">        int lMinV= minV;</span><br><span class="line">        int lMaxV= maxV;</span><br><span class="line">        bool lbst = helper(root-&gt;left, lMinV, lMaxV);</span><br><span class="line">        </span><br><span class="line">        // keep update the max value of the left child tree</span><br><span class="line">        //printf(&quot;l minV %d maxV %d &quot;,lMinV, lMaxV);</span><br><span class="line">        if(root-&gt;left!=nullptr)&#123;</span><br><span class="line">          if(lbst &amp;&amp; lMaxV&gt;=root-&gt;val)&#123;</span><br><span class="line">            return false;</span><br><span class="line">          &#125;</span><br><span class="line">          if(lbst==false) return false;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        int rMinV= minV;</span><br><span class="line">        int rMaxV= maxV;</span><br><span class="line">        // keep the min value of the right child tree</span><br><span class="line">        // the minV here is influenced</span><br><span class="line">        bool rbst = helper(root-&gt;right, rMinV, rMaxV);</span><br><span class="line">        if(root-&gt;right!=nullptr)&#123;</span><br><span class="line">            if(rbst&amp;&amp;rMinV&lt;=root-&gt;val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if(rbst==false) return false;</span><br><span class="line">        &#125;    </span><br><span class="line">        // two children case</span><br><span class="line">        maxV = max(maxV,max(rMaxV, root-&gt;val));</span><br><span class="line">        minV = min(minV,min(lMinV, root-&gt;val));</span><br><span class="line">        return true;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>We can also set the boundry value at the long long int to simplify the code, but we need to transfer the root value into the long long type when doing the comparison:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    long long int maxinit = LLONG_MAX;</span><br><span class="line">    long long int mininit = LLONG_MIN;</span><br><span class="line">    </span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line"></span><br><span class="line">        return help(root, maxinit, mininit);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool help(TreeNode* root, long long int&amp; minV, long long int&amp;maxV)&#123;</span><br><span class="line">        </span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr)&#123;</span><br><span class="line">            maxV = root-&gt;val;</span><br><span class="line">            minV = root-&gt;val;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        long long int lMinV= minV;</span><br><span class="line">        long long int lMaxV= maxV;</span><br><span class="line">        // all nullptr, return true</span><br><span class="line">        bool lbst = help(root-&gt;left, lMinV, lMaxV);</span><br><span class="line">        if(!lbst) return false;</span><br><span class="line">        </span><br><span class="line">        long long int rMinV= minV;</span><br><span class="line">        long long int rMaxV= maxV;</span><br><span class="line">        // keep the min value of the right child tree</span><br><span class="line">        // the minV here is influenced</span><br><span class="line">        bool rbst = help(root-&gt;right, rMinV, rMaxV);</span><br><span class="line">        if(!rbst) return false;</span><br><span class="line">         </span><br><span class="line">        //current </span><br><span class="line">        if(root-&gt;val&lt;=lMaxV || root-&gt;val&gt;=rMinV)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        maxV = max(rMaxV, (long long int)root-&gt;val);</span><br><span class="line">        minV = min(lMinV, (long long int)root-&gt;val);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Another idea is from the top to down, actually the code is more simpler in this case, we start from the root node and then narrow down the range of the child gradually, we set the vmin and vmax as the long int to make sure the results also correct when node equals to the INT_MIN or INT_MAX.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line"></span><br><span class="line">        return helper(root, LLONG_MIN, LLONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool helper(TreeNode* root, long int vmin, long int vmax)&#123;</span><br><span class="line">        </span><br><span class="line">        if(!root) return true;</span><br><span class="line">                </span><br><span class="line">        if(root-&gt;val &lt;= vmin || root-&gt;val&gt;= vmax)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        bool lvalid = helper(root-&gt;left, vmin, root-&gt;val);</span><br><span class="line">        if(lvalid==false) return false;</span><br><span class="line">        </span><br><span class="line">        bool rvalid = helper(root-&gt;right, root-&gt;val, vmax);</span><br><span class="line">        if(rvalid==false) return false;</span><br><span class="line"></span><br><span class="line">        return true;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>530 and 700 are similar questions that use the bst tree. 501 is also a similar one, the idea of updating the most frequent elements and associated length is inspiring. We consider three exclusive cases when checking the current node.</p>
<p>One tricky case is sth like [1,null, 2,2] do not update the recorded value based on the principle such as if current elem eqauls to the previous one. Since we do not know if there are more subsequent elements. For each step, we assume it is the last element.</p>
<p>When there is [1,null, 2] the ans vector contains 1 and 2, then move to the next, update the count, then clear the ans, then push 2 again. The key point here is we actually push the element 2 into the vector twice. </p>
<p><strong>501. Find Mode in Binary Search Tree</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public: </span><br><span class="line">    int recordLongest=0;</span><br><span class="line">    // the continuous value before visiting current node</span><br><span class="line">    int tempk=0;</span><br><span class="line">    int tempprev=INT_MIN;</span><br><span class="line">    vector&lt;int&gt; findMode(TreeNode* root) &#123;        </span><br><span class="line">        //go through LNR</span><br><span class="line">        vector&lt;int&gt; ans;        </span><br><span class="line">        //init values</span><br><span class="line">        help(root,ans);</span><br><span class="line">        return ans;      </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void help(TreeNode* root, vector&lt;int&gt;&amp; ans)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // go through left</span><br><span class="line">        help(root-&gt;left, ans);</span><br><span class="line"></span><br><span class="line">        if(root-&gt;val!=tempprev)&#123;</span><br><span class="line">            tempk=1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            tempk++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(tempk&gt;recordLongest)&#123;</span><br><span class="line">            ans.clear();</span><br><span class="line">            //printf(&quot;tempk %d push %d &quot;, tempk, root-&gt;val);</span><br><span class="line">            ans.push_back(root-&gt;val);</span><br><span class="line">            recordLongest=tempk;</span><br><span class="line">        &#125;else if(tempk==recordLongest)&#123;</span><br><span class="line">            ans.push_back(root-&gt;val);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //do nothing when the tempk&lt;recordLongest</span><br><span class="line">        &#125;</span><br><span class="line">        tempprev = root-&gt;val; </span><br><span class="line">        // go through right</span><br><span class="line">        help(root-&gt;right, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>230. Kth Smallest Element in a BST</strong></p>
<p>This is the updated version of the 700, the LNR traverse is important, in BST, the LNR is the sorted ascending sequence, therefore, we can confirm the position of the kth smallest elements conveniently by gradually decreasing its value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int ans=0;</span><br><span class="line">    int kthSmallest(TreeNode* root, int k) &#123;</span><br><span class="line">        help(root,k);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void help(TreeNode* root, int&amp; k)&#123;</span><br><span class="line">        </span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //in order l n r</span><br><span class="line">        //check left</span><br><span class="line">        help(root-&gt;left, k);</span><br><span class="line">        </span><br><span class="line">        //check central   </span><br><span class="line">        //check k and decrease?</span><br><span class="line">        k--;</span><br><span class="line">        if(k==0)&#123;</span><br><span class="line">            ans = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //check right</span><br><span class="line">        help(root-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Typical-questions-Modify-the-tree-structure"><a href="#Typical-questions-Modify-the-tree-structure" class="headerlink" title="Typical questions: Modify the tree structure"></a>Typical questions: Modify the tree structure</h3><p><strong>814. Binary Tree Pruning</strong></p>
<p>Pruning the subtree with a particular properties. The common strategy is from bottom to up and let every subtree satisfies the requirments firstly. Be careful of the condition. If current node contains 0, and one of the child exist, it means that one of the subtree contains the 1, the current node and subtree satisfies the condition and should not be removed. <strong><em>The idea from bottom to up to reconstruct the whole tree is crutial for the problem that need to modify the tree structure.</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">  TreeNode* pruneTree(TreeNode* root) &#123;</span><br><span class="line">    if (root==nullptr) return nullptr;</span><br><span class="line">    //the left subtree is already cleaned</span><br><span class="line">    //it contains 1 if the left is not nullptr</span><br><span class="line">    root-&gt;left = pruneTree(root-&gt;left);</span><br><span class="line">    //the right part is already clearned</span><br><span class="line">    //it contains the 1 if right is nullptr</span><br><span class="line">    root-&gt;right = pruneTree(root-&gt;right);</span><br><span class="line">    //visit current node</span><br><span class="line">    //if the subtree contains 1</span><br><span class="line">    //keep it, otherwise, delete whole tree</span><br><span class="line">    //or one of left or right exist, which means the subtree</span><br><span class="line">    //contains the 1</span><br><span class="line">    if (root-&gt;val == 1 || root-&gt;left || root-&gt;right)&#123;</span><br><span class="line">        return root;   </span><br><span class="line">    &#125;</span><br><span class="line">    //delete current node</span><br><span class="line">    //also delete left and right</span><br><span class="line">    //this function is unnecessary for result correctness</span><br><span class="line">    removeTree(root);</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  void removeTree(TreeNode* root)&#123;</span><br><span class="line">      if(root==nullptr)&#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      //remove left</span><br><span class="line">      removeTree(root-&gt;left);</span><br><span class="line">      //remove right</span><br><span class="line">      removeTree(root-&gt;right);</span><br><span class="line">      //remove current</span><br><span class="line">      delete root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>More complicated trim operation, we need to adjust tree structure</strong></p>
<p>The key strategy here is to consider the type of the node during the removal operation, if the removed node is leaf node or the node with one child or the node with two childern, etc. The code is more clear if considering things in this way.</p>
<p><strong>669. Trim a Binary Search Tree</strong></p>
<p>The operation is simple, just delete a node and adjust the tree structure. Be careful for the case discussion when we detected that the node should be removed.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* findLeftNode(TreeNode* root)&#123;</span><br><span class="line">        if(!root) return nullptr;</span><br><span class="line">        //if there is left node, move to the left</span><br><span class="line">        while(root-&gt;left)&#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;</span><br><span class="line">        </span><br><span class="line">        if(root==nullptr) return nullptr;</span><br><span class="line">        </span><br><span class="line">        //left</span><br><span class="line">        TreeNode* lchild = trimBST(root-&gt;left, low, high);</span><br><span class="line">        //right</span><br><span class="line">        TreeNode* rchild = trimBST(root-&gt;right, low, high);</span><br><span class="line"></span><br><span class="line">        //visit current</span><br><span class="line">        //if the node need to be deleted</span><br><span class="line">        //supposed to return if it is removed</span><br><span class="line">        if(root-&gt;val&lt;low || root-&gt;val&gt;high)&#123;</span><br><span class="line">            //remove node, there is bug for some case such as [1, null, 2] 2, 4</span><br><span class="line">            //when add this, not sure the reason</span><br><span class="line">            //delete root;</span><br><span class="line">            //leaf</span><br><span class="line">            if(lchild==nullptr &amp;&amp; rchild==nullptr)&#123;</span><br><span class="line">                return nullptr;</span><br><span class="line">            &#125;else if(lchild || rchild)&#123;</span><br><span class="line">                //one child</span><br><span class="line">                if(lchild) return lchild;</span><br><span class="line">                if(rchild) return rchild;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //two children</span><br><span class="line">                //the left tree should be the</span><br><span class="line">                //left side of the right tree</span><br><span class="line">                TreeNode* leftNode = findLeftNode(rchild);</span><br><span class="line">                leftNode-&gt;left = lchild;</span><br><span class="line">                return rchild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //current root satisfy condition</span><br><span class="line">        //update left and right</span><br><span class="line">        root-&gt;left = lchild;</span><br><span class="line">        root-&gt;right= rchild;</span><br><span class="line">        return root;            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Actually, this code can be further improved and we can notice that the case when there are two children if actaully not exist.</p>
<p>For example, if the current node value is c and it does not blongs to the [L,R], if c&lt;L, all the nodes in left of the c &lt; c &lt; L, so all of these nodes should be removed till the current step. Similarly, when the c&gt;R, all the right side nodes of the c &gt; c &gt; R, so the right side subtree should be removed before hand. This fact shows that there only exist two cases for the current recursion step, either c is the leaf node or have one side subtree.</p>
<p>1325 is a similar question, the constrains of removed node is more simple in this question.</p>
<p><strong>450. Delete Node in a BST</strong></p>
<p>The code framework and main considerations for this problem are similar with the previous one. Reuse the existing operation to deleted the selected node for the two children case is a smart point.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* deleteNode(TreeNode* root, int key) &#123;</span><br><span class="line">        return help(root, key, nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode* findMax(TreeNode* root)&#123;</span><br><span class="line">        while(root-&gt;right!=nullptr)&#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode* help(TreeNode* root, int key, TreeNode*parent)&#123;</span><br><span class="line">        </span><br><span class="line">        // edge case</span><br><span class="line">        //root is nullptr</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //find targeted node</span><br><span class="line">        if(key&lt; root-&gt;val)&#123;</span><br><span class="line">            help(root-&gt;left, key, root);</span><br><span class="line">        &#125;else if(key &gt; root-&gt;val)&#123;</span><br><span class="line">            help(root-&gt;right, key, root);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        if(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr)&#123;</span><br><span class="line">            //case1 node is leaf node</span><br><span class="line">            if(parent==nullptr)&#123;</span><br><span class="line">                //[1] 1 </span><br><span class="line">                delete(root);</span><br><span class="line">                return nullptr;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(root-&gt;val &gt; parent-&gt;val)&#123;</span><br><span class="line">                    //rchild</span><br><span class="line">                    parent-&gt;right= nullptr;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    parent-&gt;left=nullptr;</span><br><span class="line">                &#125;</span><br><span class="line">                delete(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(root-&gt;left == nullptr || root-&gt;right == nullptr)&#123;</span><br><span class="line">            //case2 one child</span><br><span class="line">            if(parent==nullptr)&#123;</span><br><span class="line">                if(root-&gt;left)&#123;</span><br><span class="line">                    return root-&gt;left;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return root-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                delete(root);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(root-&gt;val&gt;parent-&gt;val)&#123;</span><br><span class="line">                    //reset the right pointer</span><br><span class="line">                    if(root-&gt;right)&#123;</span><br><span class="line">                        parent-&gt;right=root-&gt;right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(root-&gt;left)&#123;</span><br><span class="line">                        parent-&gt;right=root-&gt;left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    delete(root);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if(root-&gt;right)&#123;</span><br><span class="line">                        parent-&gt;left=root-&gt;right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(root-&gt;left)&#123;</span><br><span class="line">                        parent-&gt;left=root-&gt;left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    delete(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //case3 two children            </span><br><span class="line">            TreeNode* leftMaxNode = findMax(root-&gt;left);</span><br><span class="line">            int leftMaxValue = leftMaxNode-&gt;val;</span><br><span class="line">            help(root-&gt;left, leftMaxValue, root);</span><br><span class="line">            root-&gt;val = leftMaxValue;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>701. Insert into a Binary Search Tree</strong></p>
<p>Using the bottom to up method and return the root of the sub tree after the modification.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool inserted=false;</span><br><span class="line">    //return the modifed tree structure</span><br><span class="line">    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;</span><br><span class="line">        //the situation to create new node and insert</span><br><span class="line">        //return the root</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            TreeNode* nodenew = new TreeNode(val);</span><br><span class="line">            inserted = true;</span><br><span class="line">            return nodenew;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(inserted)&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //val &gt; current</span><br><span class="line">        if(val&lt;=root-&gt;val)&#123;</span><br><span class="line">            TreeNode* lroot = insertIntoBST(root-&gt;left, val);</span><br><span class="line">            root-&gt;left=lroot;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //val &lt; current</span><br><span class="line">        if(val&gt;root-&gt;val)&#123;</span><br><span class="line">            TreeNode* rroot = insertIntoBST(root-&gt;right, val);</span><br><span class="line">            root-&gt;right=rroot;</span><br><span class="line">        &#125;    </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>99. Recover Binary Search Tree</strong></p>
<p>This question utilizes two facts. The first is that when there is ascending sequence, there is LNR operation. Another fact is that in the ascending sequence, if we change two numbers, by checking all the elements, if there is one situation with a1&gt;a2, we know that we switch the adjacent numbers. When there are two these cases, we can make sure that these two numbers are not at the adjacent positions.</p>
<p>If we do not use the fact of LNR and ascending sequence, there is C(n,2) possibilities for two numbers, this is a huge searching space.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* node1=nullptr;</span><br><span class="line">    TreeNode* node2=nullptr;</span><br><span class="line">    TreeNode* prev = nullptr;</span><br><span class="line">    void recoverTree(TreeNode* root) &#123;</span><br><span class="line">        //search two points</span><br><span class="line">        help(root);</span><br><span class="line">        //the node1 and node2 should not be empty till this step</span><br><span class="line">        //swap two points</span><br><span class="line">        //only swap the value, keep the tree structure</span><br><span class="line">        swap(node1-&gt;val, node2-&gt;val);</span><br><span class="line">        return;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //LNR find the two that does not satisfy the ascending sequence</span><br><span class="line">    void help(TreeNode* root)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //left </span><br><span class="line">        help(root-&gt;left);</span><br><span class="line">        //central </span><br><span class="line">        if(prev!=nullptr &amp;&amp; prev-&gt;val&gt;root-&gt;val)&#123;</span><br><span class="line">            //assume there are only two error node</span><br><span class="line">            //first one, prev position is error</span><br><span class="line">            //second one current position is error</span><br><span class="line">            if(node1==nullptr)&#123;</span><br><span class="line">                //printf(&quot;update node1, node1 %d node2 %d &quot;, node1, node2);</span><br><span class="line">                node1=prev;</span><br><span class="line">            &#125;</span><br><span class="line">            //if there is only one diff case</span><br><span class="line">            //two nodes are adjacent with each other</span><br><span class="line">            node2=root;                 </span><br><span class="line">        &#125;</span><br><span class="line">        prev=root;</span><br><span class="line">        //right</span><br><span class="line">        help(root-&gt;right);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>108. Convert Sorted Array to Binary Search Tree</strong></p>
<p>This is bascially the process of reconstructing the bst tree. The bst property simplifies the code a lot. More complex one is the case that decerilize from a random case, check the 297.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len = nums.size();</span><br><span class="line">        return build(nums, 0, len-1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode* build(vector&lt;int&gt;&amp; nums,int lindex, int rindex)&#123;</span><br><span class="line">        </span><br><span class="line">        if(lindex&gt;rindex)&#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //compute curr</span><br><span class="line">        int currindex = (lindex+rindex)/2;</span><br><span class="line">        </span><br><span class="line">        //current</span><br><span class="line">        TreeNode* curr = new TreeNode(nums[currindex]);</span><br><span class="line">        //build left</span><br><span class="line">        TreeNode* lroot = build(nums, lindex, currindex-1);   </span><br><span class="line">        //build right</span><br><span class="line">        TreeNode* rroot = build(nums, currindex+1, rindex);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        curr-&gt;left = lroot;</span><br><span class="line">        curr-&gt;right= rroot;</span><br><span class="line">        </span><br><span class="line">        return curr;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Tree-others"><a href="#Tree-others" class="headerlink" title="Tree + others"></a>Tree + others</h3><p>This type of questions use both the techniques used in tree and array (maybe map) to solve the problem. The key step here is to make sure what is the decision tree.<br>(Todo, the part sill need to be splited into another blog, since there are so many search based problem based on decision tree, the input can be 1d array, 2d array or other form)</p>
<h4 id="tree-string"><a href="#tree-string" class="headerlink" title="tree+string"></a>tree+string</h4><p>The input of the function is a string in this type of question. And it may potentially use the tree structure to derive the property of the tree structure. The difficult part is how to map the string structure into the tree structure. That is way these questions looks tricky firstly, we should first try to transform it into a tree type problem logically.</p>
<p><strong>297 Serialize and Deserialize Binary Tree</strong></p>
<p>The idea of this question is not complecated, but it is really error-prone. We use the layered traversal here based on the queue, be careful about the condition that when there is the mix of the nullptr node and the actual solide node. This is a little bit different with the level order question such as 429, since the null node also need to be considered if current level contains both empty and solid node</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">class Codec &#123;</span><br><span class="line">public:</span><br><span class="line">    // Encodes a tree to a single string.</span><br><span class="line">    // the origianl way use the layer approach</span><br><span class="line">    // it is also possible to use other approach</span><br><span class="line">    // if using the NLR</span><br><span class="line">    string serialize(TreeNode* root) &#123;</span><br><span class="line">        string str=&quot;&quot;;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return str;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        //nullnode       </span><br><span class="line">        int levelSize = q.size();</span><br><span class="line">        //label if the next layer contains the solide node</span><br><span class="line">        //if the next layer contains no solid node, return true</span><br><span class="line">        bool nextcontainSolid = true;</span><br><span class="line">        while (q.empty()==false &amp;&amp; nextcontainSolid)&#123;</span><br><span class="line">            nextcontainSolid = false;</span><br><span class="line">            while(levelSize&gt;0)&#123;</span><br><span class="line">                levelSize--;</span><br><span class="line">                TreeNode *temp = q.front();            </span><br><span class="line">                //visit node</span><br><span class="line">                if(temp!=nullptr)&#123;</span><br><span class="line">                    str+=to_string(temp-&gt;val)+&quot;,&quot;;    </span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    str+=&quot;#,&quot;;</span><br><span class="line">                    q.pop();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                q.pop();</span><br><span class="line">                if(temp-&gt;left) &#123;</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                    nextcontainSolid = true;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    q.push(nullptr);</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp-&gt;right)&#123;</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">                    nextcontainSolid = true;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    q.push(nullptr); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            levelSize = q.size();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //printf(&quot;%s&quot;, str.c_str());</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Decodes your encoded data to tree.</span><br><span class="line">    TreeNode* deserialize(string data) &#123;</span><br><span class="line">        // reconstruct based on the layered structure</span><br><span class="line">        if(data==&quot;&quot;)&#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        // split the str based on , </span><br><span class="line">        string delimiter = &quot;,&quot;;</span><br><span class="line">        int delimLength = delimiter.length();</span><br><span class="line">        int posStart=0;</span><br><span class="line">        int posEnd=0;</span><br><span class="line">        TreeNode* root = nullptr;</span><br><span class="line">        TreeNode* parent = nullptr;</span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        int index=0;</span><br><span class="line">        while ((posEnd = data.find(delimiter,posStart)) != string::npos) &#123;</span><br><span class="line">            string token = data.substr(posStart, posEnd-posStart);</span><br><span class="line">            //check the element </span><br><span class="line">            //printf(&quot;&lt;%s&gt;&quot;, token.c_str());</span><br><span class="line">            //constructure by layered way</span><br><span class="line">            if(root==nullptr)&#123;</span><br><span class="line">                //the first element</span><br><span class="line">                root = new TreeNode(stoi(token));</span><br><span class="line">                q.push(root);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(index%2==0)&#123;</span><br><span class="line">                    //update the parent</span><br><span class="line">                    //when the current left and right are built ok</span><br><span class="line">                    parent = q.front();</span><br><span class="line">                    q.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                // construct node</span><br><span class="line">                // the parent is root for the first case</span><br><span class="line">                TreeNode* current=nullptr;</span><br><span class="line">                if(token!=&quot;#&quot;)&#123;</span><br><span class="line">                    current = new TreeNode(stoi(token));</span><br><span class="line">                    //printf(&quot;curr %d parr %d &quot;, current-&gt;val, parent-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // left or right separately</span><br><span class="line">                if(index%2==0)&#123;</span><br><span class="line">                    parent-&gt;left = current;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    parent-&gt;right = current;</span><br><span class="line">                &#125;                </span><br><span class="line">                </span><br><span class="line">                // node is not null</span><br><span class="line">                // push node into the queue</span><br><span class="line">                if(current!=nullptr)&#123;</span><br><span class="line">                    q.push(current);</span><br><span class="line">                &#125;                </span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            posStart=posEnd+delimLength;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The similar one is the 449, we can also use the similar level traversal techniques.  Is there more efficient techniques for the bst structure?</p>
<p><strong>obvious inserted structure, such as parathesis 22 and 856</strong></p>
<p>For question <code>22. Generate Parentheses</code>, it is just the naive tree search, evey node can be the left or right parentheses, and then we trim some results. From the top to bottom, the final path from the root to the leaf node is the actual ans we need to record.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int totalLen=0;</span><br><span class="line">    vector&lt;string&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        totalLen=n*2;</span><br><span class="line">        helper(ans, &quot;&quot;, 0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void helper(vector&lt;string&gt;&amp; ans, string str, int rleftc)&#123;</span><br><span class="line">        int strlen = str.length();</span><br><span class="line">        if(strlen == totalLen &amp;&amp; rleftc==0)&#123;</span><br><span class="line">            //put string into ans</span><br><span class="line">            ans.push_back(str);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(strlen&lt;totalLen)&#123;</span><br><span class="line">            //can put leftc anyway, left child</span><br><span class="line">            helper(ans,str+&quot;(&quot;,rleftc+1);                </span><br><span class="line">            if(rleftc&gt;0)&#123;</span><br><span class="line">                //can put right if there is remaining leftc</span><br><span class="line">                // left child</span><br><span class="line">                helper(ans,str+&quot;)&quot;,rleftc-1);</span><br><span class="line">            &#125;              </span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>the 856 is a more complicated case. It is also based on the parenthesis, but there are more rules. There are kind of inserted structure. Originally, when we meet the parathesis, we may think of stack. </p>
<p>This is the O(N) algorithm of the <code>856 Score of Parentheses</code>, the code looks super easy, but it is not straightforward to figure out why it works. The whole idea for solving this problem is to emulate a tree structure, different with the previous one, every node is a () pair.</p>
<p>For example, if the input is <code>(())</code>, the imaginary tree is as follows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">()</span><br><span class="line">|</span><br><span class="line">()</span><br></pre></td></tr></table></figure>
<p>If there is <code>(()())</code>, the imaginary tree (or the decision tree) is as follows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">()</span><br><span class="line">| \</span><br><span class="line">() ()</span><br></pre></td></tr></table></figure>
<p>The key is that we do not consider the implementaion, we consider the abstraction first. Then according to the rule of the score, for each leaf node, its score is 2^depth, then we accumulate all the scores of leaf node together. Although the description of the question is to compute the score from the bottom to top, it is much easier to compute scores from the top to the bottom.</p>
<p>Regarding to the implementation, when there is <code>(</code>, the depth increase, when there is <code>)</code> the depth decrease, and if the previous one is <code>(</code>, we assume that we met the leaf node. The whole sequence is just like the LRN traversal of the tree</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int scoreOfParentheses(string s) &#123;</span><br><span class="line">        int score =0;</span><br><span class="line">        int len = s.length();</span><br><span class="line">        int depth=0;</span><br><span class="line">        //range s</span><br><span class="line">        for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">            if(s[i] == &apos;(&apos;)&#123;</span><br><span class="line">                depth++;</span><br><span class="line">            &#125;else if(s[i] == &apos;)&apos;)&#123;</span><br><span class="line">                if(i&gt;0 &amp;&amp; s[i-1]==&apos;(&apos;)&#123;</span><br><span class="line">                    score+=pow(2,depth-1);</span><br><span class="line">                &#125;</span><br><span class="line">                depth--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Another way is to find the balanced outlayer strcutre, and then use the recursion to call the inner layer, which is like the tree taversal from the top to the bottom, in the string case, it can use the left and right index to label the each layer of the structure, when you find each layer, the tree depth increase one.</p>
<p>Enssentially, it like the process of decoding the string into the tree and then compute some properties of the tree. For the <code>394. Decode String</code>, this idea is more obvious, and we basically use the bottom to up strategy of the tree based approach and we decode each subtree recursively. For each level, we just need a function to let it return the reuslts of the subtree. For the tree structure in logically, the leaf node is the character and the parent node is the number. The issue is that in the string structure, we basically flatten everything and not knwo when it end. So that’s why we also return a right index. That right index labels when the current level moves to the end. And then we start from the next segment (which is the node at the same level with the current node)</p>
<p><strong>726. Number of Atoms</strong></p>
<p>This is the a hard one, the main reason is that the rules are a liitle bit complex. The idea is same with previous one, the different place is that we read the string from right side to the left side, it might be easier to consider things in this way. By this way, we check the number first(the non leaf node) then the atom (the leaf node). The code can be further optimized. Although current code can work, it is still a little bit unclear for when to put the information into the map.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string decodeString(string s) &#123;</span><br><span class="line">        int len = s.length();</span><br><span class="line">        string str = getSubstr(s, 0, len, len);</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string getSubstr(string&amp; s, int l, int len, int&amp; rindex)&#123;</span><br><span class="line">        string fullstr;</span><br><span class="line">        int depth=0;        </span><br><span class="line">        int i=l;</span><br><span class="line">        int repeat=0;</span><br><span class="line"></span><br><span class="line">        while(i&lt;len)&#123;</span><br><span class="line">            if( s[i]==&apos;]&apos;)&#123;</span><br><span class="line">                rindex=i;</span><br><span class="line">                repeat=0;</span><br><span class="line">                return fullstr;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(s[i]&gt;=&apos;a&apos; &amp;&amp; s[i]&lt;=&apos;z&apos;)&#123;</span><br><span class="line">                fullstr+=s[i];</span><br><span class="line">                i++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(s[i]&gt;=&apos;0&apos; &amp;&amp; s[i]&lt;=&apos;9&apos;)&#123;</span><br><span class="line">                int tempRepeat = (s[i]-&apos;0&apos;);</span><br><span class="line">                if(i&gt;0 &amp;&amp; s[i-1]&gt;=&apos;0&apos; &amp;&amp; s[i-1]&lt;=&apos;9&apos;)&#123;</span><br><span class="line">                    //consider previous one only when</span><br><span class="line">                    //there are adjacent digits</span><br><span class="line">                    repeat = repeat*10+tempRepeat;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    repeat = tempRepeat;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            string tempstr;</span><br><span class="line">            if(s[i]==&apos;[&apos;)&#123;</span><br><span class="line">                tempstr = getSubstr(s,i+1,len,rindex);</span><br><span class="line">                i=rindex+1;</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">            for(int j=0;j&lt;repeat;j++)&#123;</span><br><span class="line">                fullstr+=tempstr;</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        return fullstr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    map &lt;string, int&gt; atomMap;</span><br><span class="line">    string countOfAtoms(string formula) &#123;</span><br><span class="line">        // ordered map to store the atom and its number</span><br><span class="line">        string str;</span><br><span class="line">        int len = formula.length();</span><br><span class="line">        int lindex=0;</span><br><span class="line">        helper(formula,lindex,len-1,len,1);</span><br><span class="line">        //output the value from map into string</span><br><span class="line">        for(auto it : atomMap)&#123;</span><br><span class="line">            string key = it.first;</span><br><span class="line">            //std::cout &lt;&lt; &quot;key&quot; &lt;&lt; key &lt;&lt;std::endl;</span><br><span class="line">            int value = it.second;</span><br><span class="line">            str+=key;</span><br><span class="line">            if(value!=1)&#123;</span><br><span class="line">                str+=to_string(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //paras: formular, start position, len of the formula</span><br><span class="line">    //read it from right to left for simplicity</span><br><span class="line">    void helper(string&amp; f, int&amp; lindex, int rindex, int&amp; len, int multiplier)&#123;</span><br><span class="line">        string atomName;</span><br><span class="line">        int fNum=1;</span><br><span class="line">        int i=rindex;</span><br><span class="line">        while(i&gt;=0)&#123;</span><br><span class="line">            //std::cout &lt;&lt; &quot;i &quot; &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">            //number</span><br><span class="line">            if(f[i] &gt;= &apos;0&apos; &amp;&amp; f[i]&lt;=&apos;9&apos;)&#123;</span><br><span class="line">                // H2O case, it can be a new started atom</span><br><span class="line">                if(i+1&lt;len &amp;&amp; f[i+1]&gt;=&apos;A&apos; &amp;&amp; f[i+1]&lt;=&apos;Z&apos;)&#123;</span><br><span class="line">                    //this condition is prior than case where there is (</span><br><span class="line">                    //when this executed, we do not check ( further</span><br><span class="line">                    //this is a new atom</span><br><span class="line">                    //std::cout&lt;&lt;&quot;anmed &quot;&lt;&lt;atomName &lt;&lt; &quot;fnum &quot; &lt;&lt; fNum &lt;&lt; &quot;multi &quot; &lt;&lt; multiplier&lt;&lt;std::endl;</span><br><span class="line">                    atomMap[atomName]+=fNum*multiplier;</span><br><span class="line">                    //reset key variables</span><br><span class="line">                    atomName=&quot;&quot;;</span><br><span class="line">                    fNum=1;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                //current number</span><br><span class="line">                int tempNum = f[i]-&apos;0&apos;;</span><br><span class="line">                //read from right to left</span><br><span class="line">                if(i+1 &lt; len &amp;&amp; f[i+1] &gt;= &apos;0&apos; &amp;&amp; f[i+1]&lt;=&apos;9&apos;)&#123;</span><br><span class="line">                    fNum = tempNum*10+fNum;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    fNum = tempNum;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                i--;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //character(multiple)</span><br><span class="line">            if((f[i]&gt;=&apos;A&apos; &amp;&amp; f[i]&lt;=&apos;Z&apos;) || (f[i]&gt;=&apos;a&apos; &amp;&amp; f[i]&lt;=&apos;z&apos;))&#123;</span><br><span class="line">                //reset the fNum if there are two upper case</span><br><span class="line">                //the 1 is omitted in expression</span><br><span class="line">                //also update in this case</span><br><span class="line">                if(i+1&lt;len &amp;&amp; f[i+1]&gt;=&apos;A&apos; &amp;&amp; f[i+1]&lt;=&apos;Z&apos;)&#123;</span><br><span class="line">                    //this condition is prior than case where there is (</span><br><span class="line">                    //when this executed, we do not check ( further</span><br><span class="line">                    //this is a new atom</span><br><span class="line">                    //std::cout&lt;&lt;&quot;anmec &quot;&lt;&lt;atomName&lt;&lt;std::endl;</span><br><span class="line">                    atomMap[atomName]+=fNum*multiplier;</span><br><span class="line">                    //reset key variables</span><br><span class="line">                    atomName=f[i];</span><br><span class="line">                    fNum=1;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    atomName=f[i]+atomName;</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(f[i]==&apos;)&apos;)&#123;</span><br><span class="line">                //recursion, process multiple elements inserted</span><br><span class="line">                //in current section</span><br><span class="line">                //update l index</span><br><span class="line">                helper(f, lindex, i-1, len, multiplier*fNum);</span><br><span class="line">                //remember to set new fNum, from this point, it is a new segment</span><br><span class="line">                fNum=1;</span><br><span class="line">                i=lindex-1;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // can start with chracter</span><br><span class="line">            // when i==0 also insert</span><br><span class="line">            if(f[i]==&apos;(&apos; || i==0)&#123;</span><br><span class="line">                //return point</span><br><span class="line">                //put thing into map</span><br><span class="line">                //std::cout&lt;&lt;&quot;anmeb &quot;&lt;&lt;atomName&lt;&lt;std::endl;</span><br><span class="line">                if(atomName!=&quot;&quot;)&#123;</span><br><span class="line">                    atomMap[atomName]+=fNum*multiplier;</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">                //reset key variables</span><br><span class="line">                atomName=&quot;&quot;;</span><br><span class="line">                fNum=1;</span><br><span class="line">                lindex=i--;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //process the first one</span><br><span class="line">        if(atomName!=&quot;&quot;)&#123;</span><br><span class="line">            //std::cout&lt;&lt;&quot;anmea &quot;&lt;&lt;atomName&lt;&lt; &quot; fNum &quot; &lt;&lt; fNum &lt;&lt; &quot; multi &quot; &lt;&lt; multiplier &lt;&lt; std::endl;</span><br><span class="line">            atomMap[atomName]+=fNum*multiplier;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Another example is 736, which is a little bit complex. (todo, use multiple if else, check if the info needed to be put into the map at the end of each iteration, maybe use a variable to label it)</p>
<h4 id="tree-map-or-dp"><a href="#tree-map-or-dp" class="headerlink" title="tree+map or dp"></a>tree+map or dp</h4><p>Some complex path sum questions such as may use the map, such as the 437. The main idead that uses the map is to improve the performance of the searching. </p>
<p><strong>337. House Robber III</strong></p>
<p>This one is inspiring. There is some intersection between the traditional tree based strategy such as top to bottom or bottom to up with the thinking perspective of the dp.</p>
<p>For example, this is the code from the top to bottom. We make sure the status of the start node (parent node) and then considering the status of the child node.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 1 index of the node, 2 true or false</span><br><span class="line">    map&lt;TreeNode*, map&lt;bool, int&gt; &gt; cache;</span><br><span class="line">    int rob(TreeNode* root) &#123;</span><br><span class="line">        //choose root</span><br><span class="line">        int max1=help(root,true);</span><br><span class="line">        int max2=help(root,false);</span><br><span class="line">        return max(max1,max2);</span><br><span class="line">    &#125;</span><br><span class="line">    // return the max value when the current node is root</span><br><span class="line">    int help(TreeNode* root, bool ifrob)&#123;</span><br><span class="line">        if(cache.find(root)!=cache.end())&#123;</span><br><span class="line">            if(cache[root].find(ifrob)!=cache[root].end())&#123;</span><br><span class="line">                return cache[root][ifrob];</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // add a cache here? </span><br><span class="line">        if(ifrob)&#123;</span><br><span class="line">           int lvalue=help(root-&gt;left,false);</span><br><span class="line">           int rvalue=help(root-&gt;right,false); </span><br><span class="line">           return lvalue+rvalue+root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //if current is false</span><br><span class="line">        //the next level can be false or true</span><br><span class="line">        int l1=help(root-&gt;left,false);</span><br><span class="line">        int l2=help(root-&gt;right,false);</span><br><span class="line">        int l3=help(root-&gt;left,true);</span><br><span class="line">        int l4=help(root-&gt;right,true);</span><br><span class="line">        </span><br><span class="line">        int result = max(l1,l3)+max(l2,l4);</span><br><span class="line">        </span><br><span class="line">        cache[root][ifrob]=result;</span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>and this is the code from the bottom to up. We make sure the status of the child node and then refer to the status of the parent node.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(TreeNode* root) &#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int Vr, Vnr = 0;</span><br><span class="line">        helper(root, Vr, Vnr);</span><br><span class="line">        return max(Vr,Vnr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //return value is the status of the current</span><br><span class="line">    //The Vcr and Vcnr are used to store the intermediate status</span><br><span class="line">    void helper(TreeNode* root, int&amp; Vcr, int&amp; Vcnr)&#123; </span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            Vcr = 0;</span><br><span class="line">            Vcnr = 0;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //l child status</span><br><span class="line">        int Vlr, Vlnr =0;</span><br><span class="line">        helper(root-&gt;left,Vlr,Vlnr);</span><br><span class="line">        </span><br><span class="line">        //r child status</span><br><span class="line">        int Vrr, Vrnr =0;</span><br><span class="line">        helper(root-&gt;right,Vrr,Vrnr);</span><br><span class="line"></span><br><span class="line">        //compute the Vcr and Vcnr</span><br><span class="line">        //if current rub</span><br><span class="line">        Vcr = Vlnr+Vrnr+root-&gt;val;</span><br><span class="line">        //if current not rub</span><br><span class="line">        Vcnr = max(Vlr,Vlnr)+max(Vrr,Vrnr);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>If we consider the issue from the status transfer, the parent node and the child node mainatins a kind of relationship (depending on the context of the question), the status table is listed as follows from the child to the parent</p>
<p>L  R  C<br>R  NR NR<br>R  R  NR<br>NR NR R/NR<br>NR R  NR</p>
<p>we could check the parent firstly or child firstly, there are two different programming paradigm. For the first version, we use the strategy from start to the end. For the second case, we fix the status of the leaf node firstly, then derive it from the bottom to the top. Even for previous questions that search the properties of the tree, we also use the similar ideas. These questions only have one variable and the status is also comparatively simple.</p>
<p>Inspired by the dp solution of the 337, we can write another dp solution of the <code>968. Binary Tree Cameras</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;   </span><br><span class="line">public:</span><br><span class="line">    int ans=0;</span><br><span class="line">    int minCameraCover(TreeNode* root) &#123;</span><br><span class="line">        //root is null</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //at least two layers</span><br><span class="line">        int Vcm, Vncm, Vncnm=0;</span><br><span class="line">        helper(root, Vcm, Vncm, Vncnm);</span><br><span class="line">        //the result is 1 at least</span><br><span class="line">        if(Vcm==0)&#123;</span><br><span class="line">            return Vncm;</span><br><span class="line">        &#125;</span><br><span class="line">        if(Vncm==0)&#123;</span><br><span class="line">            return Vcm;</span><br><span class="line">        &#125;</span><br><span class="line">        return min(Vcm,Vncm);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //when it is not at the top position, we can always postpone the choice</span><br><span class="line">    void helper(TreeNode* root, int&amp; Vcm, int&amp; Vncm, int&amp; Vncnm)&#123;</span><br><span class="line">        </span><br><span class="line">        //null</span><br><span class="line">        if(root == nullptr)&#123;</span><br><span class="line">            //the init status should be fixed, which is ncm</span><br><span class="line">            Vcm=9999;</span><br><span class="line">            Vncm=0;</span><br><span class="line">            Vncnm=9999;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int LVcm, LVncm, LVncnm=0;</span><br><span class="line">        helper(root-&gt;left,  LVcm, LVncm, LVncnm);</span><br><span class="line">        int RVcm, RVncm, RVncnm=0;</span><br><span class="line">        helper(root-&gt;right, RVcm, RVncm, RVncnm);</span><br><span class="line">        </span><br><span class="line">        Vcm = 1+min(LVcm, min(LVncm, LVncnm))+min(RVcm, min(RVncm, RVncnm));</span><br><span class="line">        Vncm= min(LVcm+RVcm, min((LVcm+RVncm), (LVncm+RVcm)));</span><br><span class="line">        Vncnm=min(LVcm,LVncm)+min(RVcm, RVncm);</span><br><span class="line">         </span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This code is easy to understand if we list the status transfer between children and the parent:</p>
<p>L——R——C<br>CM   CM   CM/NCM/NCNM<br>CM   NCM  CM/NCM/NCNM<br>CM   NCNM CM<br>NCM  CM   CM/NCM/NCNM<br>NCM  NCM  CM/NCNM<br>NCM  NCNM CM<br>NCNM CM   CM<br>NCNM NCM  CM<br>NCNM NCNM CM</p>
<p>The tricky point is the status when there is nullptr, at that case, we should assume the node status is the NCM. For the origianl solution, it assume that when there is CM or NCM, it is always prefered to postpone the camera except the current node is the top layer, so we can guarantee the status of the tree by this analysis. But the dp solution is a more general case.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/04/21/Algorithm-8-Tree/" data-id="cl49ds6p6007auamc066w3j06" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
 
<script src="/jquery/jquery.min.js"></script>

  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2022/04/24/GraphicsBasics/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          GraphicsBasics
        
      </div>
    </a>
  
  
    <a href="/2022/03/20/phd-story/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">PhD story</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Key-techniques-and-considerations"><span class="toc-number">1.</span> <span class="toc-text">Key techniques and considerations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Typical-questions-Traverse-tree"><span class="toc-number">2.</span> <span class="toc-text">Typical questions: Traverse tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Typical-questions-search-particular-properties-of-the-tree"><span class="toc-number">3.</span> <span class="toc-text">Typical questions: search particular properties of the tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Typical-questions-Modify-the-tree-structure"><span class="toc-number">4.</span> <span class="toc-text">Typical questions: Modify the tree structure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tree-others"><span class="toc-number">5.</span> <span class="toc-text">Tree + others</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tree-string"><span class="toc-number">5.1.</span> <span class="toc-text">tree+string</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tree-map-or-dp"><span class="toc-number">5.2.</span> <span class="toc-text">tree+map or dp</span></a></li></ol></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2022 zhe&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;godenwangzhe@gmail.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>