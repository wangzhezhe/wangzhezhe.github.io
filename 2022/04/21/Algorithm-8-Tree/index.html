<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Algorithm(8) Tree | AverageMind</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="The typical algorithm questions based on the tree structure.">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithm(8) Tree">
<meta property="og:url" content="http://yoursite.com/2022/04/21/Algorithm-8-Tree/index.html">
<meta property="og:site_name" content="AverageMind">
<meta property="og:description" content="The typical algorithm questions based on the tree structure.">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2022-05-05T03:21:48.932Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Algorithm(8) Tree">
<meta name="twitter:description" content="The typical algorithm questions based on the tree structure.">
  
    <link rel="alternate" href="/atom.xml" title="AverageMind" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-165927341-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AverageMind</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Writing is nature&#39;s way of letting you know how sloppy your thinking is.</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Algorithm-8-Tree" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/21/Algorithm-8-Tree/" class="article-date">
  <time datetime="2022-04-21T20:22:42.000Z" itemprop="datePublished">2022-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Algorithm(8) Tree
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>The typical algorithm questions based on the tree structure.</p>
<a id="more"></a>
<p>This article describes several key considerations of the tree and binary search tree, we first describe the commonly techniques and thinking perspectives to solve these type of problems and then we list several specific problem and there soluations, we may put these solutions into different blogs in future.</p>
<p>The list of sample questions come from <a href="https://docs.google.com/spreadsheets/d/1yRCOJ8KysRVkq0O9IlDriT01tC6lzPapmFO4PCmDJQA/edit#gid=972946549" target="_blank" rel="noopener">here</a></p>
<p>This is also a good resource to classify all kinds of problems.</p>
<h3 id="Key-techniques-and-considerations"><a href="#Key-techniques-and-considerations" class="headerlink" title="Key techniques and considerations"></a>Key techniques and considerations</h3><ul>
<li><p>(1) Classification of the tree node, instead of classifying it into the leaf or null leaf, just assume it is null or not null, or more complex form such as 968 (covered or not covered, 450 is also a good classification example, leaf node, have 1 child, have two child), 257 classifies the node to null node, leaf node and not null node.</p>
</li>
<li><p>(2) From up to bottom, the lower level nodes need the information of the upper level nodes.</p>
</li>
<li><p>(3) From bottom to up, the left and right child tree returns root or specific value, the upper level nodes needs the information of the lower level nodes or subtrees.</p>
</li>
<li><p>(4) Bst tree, the in order traverse (LNR) is the array with ascending values</p>
</li>
<li><p>(5) Typical strategy to insert or delete the node, how to acquire the parent pointer for different questions (the 450 can be a complex one for this type)</p>
</li>
<li><p>(6) The idea of calling level is important for these type of questions, For example, we may print the information of recursion level to debug the code. Besides, for the searching path, remember that the element need to be poped out after each level function call, this techniques are used in 257 and the 437.</p>
</li>
</ul>
<p>Here are some key thinking perspectives, these ideas can also be used to solving other problems, these steps are useful especially when you do not have ideas for solving current problem </p>
<ul>
<li><p>Consider the data structure adopted by the problem, from the domain specific problem to a cs algorithm problem, this step is comparatively simple for easy or medium question</p>
</li>
<li><p>Confirm the type of problem, typically type of problem is modify, search specific results or compute optimization situation. After confirming this, we can further move to another step.</p>
</li>
<li><p>For the problem of searching, we first need to figure out the total status and the total combinations, then we use the constrains and the techniques discussed above to narrow down these situations. For the problem of modifying, just be caring of common operations for create delete nodes, the tricks of keeping parent pointer etc.</p>
</li>
<li><p>Other specific type of problems (such as search possible solutions) are related to tree, but not totally related, we use another blog to discuss these questions (parathesis match, work search, sudoku problem, queens problem and puzzle problem).</p>
</li>
</ul>
<h3 id="Typical-questions-Traverse-tree"><a href="#Typical-questions-Traverse-tree" class="headerlink" title="Typical questions: Traverse tree"></a>Typical questions: Traverse tree</h3><p><strong>94. Binary Tree Inorder Traversal</strong></p>
<p>This is really typical one, the inorder traversal represents the LNR traversal. The node type is divided into nullptr or not nullptr, this can be the basic framework for more complicated algorithm. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; ans; </span><br><span class="line">        help(root, ans);  </span><br><span class="line">        return ans;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void help(TreeNode* root, vector&lt;int&gt;&amp; ans)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // left</span><br><span class="line">        help(root-&gt;left,ans);</span><br><span class="line">        // current</span><br><span class="line">        ans.push_back(root-&gt;val);</span><br><span class="line">        // right</span><br><span class="line">        help(root-&gt;right, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>144 and 145 are similar problems, they are preorder (NLR) and postorder (LRN) traversal, respectively. 589 and 590 is the N children problem.</p>
<p><strong>429. N-ary Tree Level Order Traversal</strong></p>
<p>how to process the height information? There is no associated variable defination in the tree structure. This is the code that use the BFS style code based on the queue. The key idea that label the level is to <em>remember the queuesize after each level</em>. Then at the next iteration, we just need to pop out the node in the previous level, and then the remaning elements are nodes on the current level. We do similar things and move to the next iteration step by step.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// Time complexity O(n)</span><br><span class="line">// Space complexity O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        vector&lt;int&gt; temp;</span><br><span class="line">        help(root, ans, temp, true);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    void help(Node* root,vector&lt;vector&lt;int&gt;&gt;&amp; ans,vector&lt;int&gt;&amp; temp, bool iflast)&#123;</span><br><span class="line">        //put the temp into the ans if switch the height</span><br><span class="line">        //if the current node is null, hit a new level, then push</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;   </span><br><span class="line">        q.push(root);</span><br><span class="line">        int levelsize = q.size();</span><br><span class="line">        while(q.empty()==false)&#123;</span><br><span class="line">            while(levelsize&gt;0)&#123;        </span><br><span class="line">                levelsize--;</span><br><span class="line">                Node* curr=q.front();</span><br><span class="line">                temp.push_back(curr-&gt;val);</span><br><span class="line">                q.pop();</span><br><span class="line"></span><br><span class="line">                for(int i=0;i&lt;curr-&gt;children.size();i++)&#123;</span><br><span class="line">                    q.push(curr-&gt;children[i]);</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;    </span><br><span class="line">            // this layer finish</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">            temp.clear();</span><br><span class="line">            // current queue size, there are qsize element</span><br><span class="line">            // the elements in the queue are elements at a new level now</span><br><span class="line">            levelsize = q.size();</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The code can also be written in an <a href="https://zxi.mytechroad.com/blog/tree/leetcode-107-binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">recursive way</a>. The general framework of recursion is easy to write, the key part is that we set the depth and insert the associated elements into the proper position. We also insert the empty array into the ans vector during the recursion process. The code of the recursive way is more clean.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        help(root, ans, 0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void help(Node* root, vector&lt;vector&lt;int&gt;&gt;&amp;ans, int depth)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //if the new layer</span><br><span class="line">        if(ans.size()&lt;(depth+1))&#123;</span><br><span class="line">            ans.push_back(&#123;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        // visit node</span><br><span class="line">        ans[depth].push_back(root-&gt;val);</span><br><span class="line">        // call children recursively</span><br><span class="line">        for(auto child: root-&gt;children)&#123;</span><br><span class="line">            help(child, ans, depth+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Similar problem:</p>
<p>102 is also similar one, just using the level order, the code is simple when using the recursion method discussed above.</p>
<p>107 its input data structure is the binary tree, which is the simplified version of the 429. The 107 require the output sequence from the bottom to up. So we only need to add <code>reverse(ans.begin(), ans.end())</code> before returning the ans.</p>
<p>104 is also similar one, just compute the maxdepth of the tree direactly.</p>
<p><strong>987. Vertical Order Traversal of a Binary Tree</strong></p>
<p>Using the data structure in a wise way is the key for this question. The first key of the map indicates the column, the second key indicates the row, the multiset indicates there are multiple elements in same column, row index and the elements is stored in ascending manner, and the elements can also be repeated in the set.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; verticalTraversal(TreeNode* root) &#123;</span><br><span class="line">        // why use the multiset: check this data [3,1,4,0,2,2]</span><br><span class="line">        map&lt;int, map&lt;int, multiset&lt;int&gt;&gt;&gt; mymap;</span><br><span class="line">        helper(root, mymap, 0, 0);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans (mymap.size());</span><br><span class="line">        int i=0;</span><br><span class="line">        for(auto it:mymap)&#123;</span><br><span class="line">            for(auto itmapset : it.second)&#123;</span><br><span class="line">                for(auto itset: itmapset.second)&#123;</span><br><span class="line">                    //printf(&quot;itset %d\n&quot;,itset);</span><br><span class="line">                    ans[i].push_back(itset);                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void helper(TreeNode* root, map&lt;int, map&lt;int, multiset&lt;int&gt;&gt;&gt;&amp; mymap, int row, int column)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mymap[column][row].insert(root-&gt;val);</span><br><span class="line">        //children</span><br><span class="line">        //left</span><br><span class="line">        helper(root-&gt;left, mymap, row+1, column-1);</span><br><span class="line">        //right</span><br><span class="line">        helper(root-&gt;right, mymap, row+1, column+1);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Compared with using a grid, using the ordered map is more simple, other soluation also use the pair as the key of the map</p>
<p>Similar questions:</p>
<p>1302, just sum up the deepest leaves, the question is, how do we know it is the deepest leaves. The idea is just using a spearate depth variable and keep the newest value, then add varaible into the sum </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// one solution for 1302</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth=0;</span><br><span class="line">    int layersum = 0;</span><br><span class="line">    int deepestLeavesSum(TreeNode* root) &#123;</span><br><span class="line">        helper(root, 0);</span><br><span class="line">        return layersum;</span><br><span class="line">    &#125;</span><br><span class="line">    void helper(TreeNode* root, int currDepth)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //visit node, add some trim operation </span><br><span class="line">        if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr)&#123;</span><br><span class="line">            if(currDepth&gt;maxDepth)&#123;</span><br><span class="line">                maxDepth =  currDepth;</span><br><span class="line">                layersum = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if(currDepth == maxDepth)&#123;</span><br><span class="line">                layersum = layersum + root-&gt;val;</span><br><span class="line">            &#125;          </span><br><span class="line">        &#125;</span><br><span class="line">        //move to the children</span><br><span class="line">        helper(root-&gt;left,currDepth+1);</span><br><span class="line">        helper(root-&gt;right,currDepth+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>257 Binary Tree Paths</strong></p>
<p>This question requires to print out the searching paths, one key idea is to adjust current searching path. We use a vector store the searching path, when current level of recursion finish, we then pop back the last element in the vector, by this way, we can always make sure the element in the vector is located in the current path. The similar ideas is also used in the 437, in that case, we decrease the associated path number after leaving the current recursion call each time. The search path here is based on the idea of the dfs essentially.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    vector&lt;string&gt; m_ans;</span><br><span class="line">    vector&lt;int&gt; m_path;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        return m_ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void helper(TreeNode* root)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //visit leaf node</span><br><span class="line">        m_path.push_back(root-&gt;val);</span><br><span class="line"></span><br><span class="line">        //if leaf, add path info</span><br><span class="line">        if(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr)&#123;</span><br><span class="line">            //put currpath into the m_ans</span><br><span class="line">            string tempstr;</span><br><span class="line">            for(int i=0;i&lt;m_path.size();i++)&#123;</span><br><span class="line">                if(i==0)&#123;</span><br><span class="line">                    tempstr=tempstr+to_string(m_path[i]);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    tempstr=tempstr+&quot;-&gt;&quot;+to_string(m_path[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            m_ans.push_back(tempstr);</span><br><span class="line">            </span><br><span class="line">            //remove one elem</span><br><span class="line">            //the leaf node return earlyer at this case</span><br><span class="line">            m_path.pop_back();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //children</span><br><span class="line">        helper(root-&gt;left);</span><br><span class="line">        helper(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        //remove elem in current level</span><br><span class="line">        m_path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Typical-questions-search-particular-properties-of-the-tree"><a href="#Typical-questions-search-particular-properties-of-the-tree" class="headerlink" title="Typical questions: search particular properties of the tree"></a>Typical questions: search particular properties of the tree</h3><p><strong>Compare if two trees are same, mirror or satisfies certain constraints</strong></p>
<p>100 check the same tree, we can use any type of iteration method discussed above, if there is null equal during the recursive process, return the false, otherwise, return true.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// be carefule for the several special cases for deciding the same tree</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSameTree(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if(p==nullptr &amp;&amp; q)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p &amp;&amp; q==nullptr)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p &amp;&amp; q)&#123;</span><br><span class="line">            //visit</span><br><span class="line">            if(p-&gt;val != q-&gt;val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            //check the child</span><br><span class="line">            bool leftSame = isSameTree(p-&gt;left, q-&gt;left);</span><br><span class="line">            </span><br><span class="line">            if(leftSame==false)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            bool rightSame = isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line"></span><br><span class="line">            if(rightSame==false)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;       </span><br><span class="line">        return true;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>572 Subtree of Another Tree, this is the updated version for comparing if two trees are same with each other. Traverse the original tree based on NLR sequence, if the node value equals with the subroot value, executed comparision operation. Otherwise, continue check.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">//572. Subtree of Another Tree</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSubtree(TreeNode* root, TreeNode* subRoot) &#123;</span><br><span class="line">        //edge cases</span><br><span class="line">        if(!root &amp;&amp; !subRoot)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!subRoot)&#123;</span><br><span class="line">            // subroot is null but root is not</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!root)&#123;</span><br><span class="line">            // the root is null but subRoot is not null</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //go through left and right</span><br><span class="line">        bool leftContain = isSubtree(root-&gt;left, subRoot);</span><br><span class="line">        bool rightContain = isSubtree(root-&gt;right, subRoot);</span><br><span class="line">        </span><br><span class="line">        if(leftContain || rightContain)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(leftContain == false &amp;&amp; rightContain==false)&#123;</span><br><span class="line">            if(root-&gt;val == subRoot-&gt;val)&#123;</span><br><span class="line">                bool same=isSameTree(root, subRoot);</span><br><span class="line">                if(same)&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool isSameTree(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if(p==nullptr &amp;&amp; q)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p &amp;&amp; q==nullptr)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p &amp;&amp; q)&#123;</span><br><span class="line">            //visit</span><br><span class="line">            if(p-&gt;val != q-&gt;val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            //check the child</span><br><span class="line">            bool leftSame = isSameTree(p-&gt;left, q-&gt;left);</span><br><span class="line">            </span><br><span class="line">            if(leftSame==false)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            bool rightSame = isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line"></span><br><span class="line">            if(rightSame==false)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;       </span><br><span class="line">        return true;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The above code reuse the function of 100, it still looks a little bit complicated and error prone. For the edge cases, we need to consider four situations and confirm the case that one of the child is nullptr. It also uses the idea of compare left part then compare the right part, since there is a return value of the function. For example, after deciding that the left part do not contain subtree, the right part does not contain subtree and the current root does not contains subtree, we can returns the false.</p>
<p>The 101 symmetric tree is also a similar question, the condition of mirror is just reverse the left and right, one case is right to left, another case is right to left, to decide if they are equal. This is similar with previous one, the difference is the traversal sequence. The origianl thought is to use LNR to traverse left and use RNL to traverse right, then compare the results. But this input <code>[1,2,2,2,null,2]</code> have the same results eigher for LNR and RNL. So it is not uniquely to decide if two parts are mirror of each other. Although the result is straightforward, it is not easy to provide the reuslts at the first glance.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return Compare(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool Compare(TreeNode* p, TreeNode* q)&#123;</span><br><span class="line">        if(p==nullptr &amp;&amp; q)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p &amp;&amp; q == nullptr)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p &amp;&amp; q)&#123;</span><br><span class="line">            //visit</span><br><span class="line">            if(p-&gt;val != q-&gt;val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            bool leftSame = Compare(p-&gt;left, q-&gt;right);</span><br><span class="line">            if(leftSame==false)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            bool rightSame = Compare(p-&gt;right, q-&gt;left);</span><br><span class="line">            if(rightSame==false)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;             </span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>110 check if the tree is balanced. This is a little bit special, since it introduce the idea from the bottom to up. Namely, the helper function returns some information and this information will be used by the upper level. These type of paradigm is used a lot when modify the tree structure.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">        int height=0;</span><br><span class="line">        return helper(root, height);  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool helper(TreeNode* root, int&amp; height)&#123;</span><br><span class="line">        if(!root)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        //left balanced</span><br><span class="line">        int leftHeight=0;</span><br><span class="line">        bool leftBalanced = helper(root-&gt;left, leftHeight);</span><br><span class="line"></span><br><span class="line">        //right balanced</span><br><span class="line">        int rightHeight=0;</span><br><span class="line">        bool rightBalanced = helper(root-&gt;right, rightHeight);         </span><br><span class="line">        height=max(leftHeight,rightHeight)+1;</span><br><span class="line">        </span><br><span class="line">        //check diff</span><br><span class="line">        if(leftBalanced &amp;&amp; rightBalanced)&#123;</span><br><span class="line">            if(abs(leftHeight-rightHeight)&lt;=1)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>965 is also a similar one, just simple checking based on the bottom to up recursion. The properties for these questions is to detect the results of the subtree first and then use the return results to decide the current results.</p>
<p>872 is a similar one with the simple background, the idea of code classification is good. null ptr, leaf, one child, two childern. Pay attention to the sequence of the checking and make sure all situations are considered.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool leafSimilar(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">         //get leaf sequecnce of the first one</span><br><span class="line">        vector&lt;int&gt; seq1;</span><br><span class="line">        getLeafSeq(root1, seq1);</span><br><span class="line">        // get leaf sequence of the second one</span><br><span class="line">        vector&lt;int&gt; seq2;</span><br><span class="line">        getLeafSeq(root2, seq2);</span><br><span class="line">        </span><br><span class="line">        if(seq1.size()!=seq2.size())&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;seq1.size();i++)&#123;</span><br><span class="line">            if(seq1[i]!=seq2[i])&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void getLeafSeq(TreeNode* root, vector&lt;int&gt;&amp; ans)&#123;</span><br><span class="line">        //null</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //leaf</span><br><span class="line">        if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr)&#123;</span><br><span class="line">            ans.push_back(root-&gt;val);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //one child</span><br><span class="line">        if(root-&gt;left)&#123;</span><br><span class="line">            getLeafSeq(root-&gt;left, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right)&#123;</span><br><span class="line">            getLeafSeq(root-&gt;right, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>min or max path of the tree, path sum or path with particualr constraints</strong></p>
<p>111 check the minimum depth. It also use the similar strategy. Check the min depth of the left and right part, and then return the min of the left and right value plus one. Be careful for processing the null node. Since we just return 0 direactly. When we compare the return value, this node is not accounted into the depth of the tree. For the test case such as <code>[2,null,3,null,4,null,5,null,6]</code>, the return value is 5. When we check the min value, we do not consider the return value with the 0. Since the leaf node is the node with no children. Which should return 1 at least.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 111 Minimum Depth of Binary Tree</span><br><span class="line">class Solution &#123;</span><br><span class="line">    int mindepth = 0;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">        return helper(root);</span><br><span class="line">    &#125;</span><br><span class="line">    int helper(TreeNode* root)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;  </span><br><span class="line">        //ldepth</span><br><span class="line">        int ldepth =  helper(root-&gt;left);     </span><br><span class="line">        //rdpeth</span><br><span class="line">        int rdepth=helper(root-&gt;right);     </span><br><span class="line">        //current depth</span><br><span class="line">        int currdepth = 0;</span><br><span class="line">        if(ldepth==0 &amp;&amp; rdepth !=0)&#123;</span><br><span class="line">            currdepth = rdepth+1;</span><br><span class="line">        &#125;else if (rdepth==0 &amp;&amp; ldepth!=0)&#123;</span><br><span class="line">            currdepth = ldepth+1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            currdepth = min (ldepth, rdepth)+1;        </span><br><span class="line">        &#125;</span><br><span class="line">        return currdepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>112.Path Sum, using the NLR to traverse the tree and decrease the target sum each time going to the next level. Only return true at the case where node is the leaf node and satisfies the targeted. Using the idea from the up to bottom is more natural for this one. The idea of considering things in sequence and in a complete way is important, the null node, the leaf node and the non-leaf node. </p>
<p>Actually, the good practice here is to consider the edge case firstly, since we can return it direactly and to not do the subsequent checking, then the remaning logic is the general case. So, the good practice for the recursion operation is to write the return entry firstly and then check the recursion part, but when we thinking it, we may consider the recursion part firstly and then the return part.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        if(root == nullptr)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //visit current node</span><br><span class="line">        //if leaf</span><br><span class="line">        if(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr)&#123;</span><br><span class="line">            if(targetSum==root-&gt;val)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //check left and right</span><br><span class="line">        bool left = hasPathSum(root-&gt;left, targetSum-root-&gt;val);</span><br><span class="line">        if(left)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        bool right = hasPathSum(root-&gt;right, targetSum-root-&gt;val);</span><br><span class="line">        if(right)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>129 Sum Root to Leaf Numbers is a similar question of 112, just times 10 when visiting the leaf node when adding the new path.</p>
<p>113 is the updated version of the 112, it requires to memory the specific path that satisfies the requirments, it is a typical search problem (both the start and the end of the search path is clear). This idea and associated code can be the framework for many more complicated problem.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//113 Path Sum II</span><br><span class="line">class Solution &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; m_ans;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        helper(root, targetSum, &#123;&#125;);</span><br><span class="line">        return m_ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void helper(TreeNode* root, int targetSum, vector&lt;int&gt; currpath)&#123;</span><br><span class="line">        //null node</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //leaf node</span><br><span class="line">        if(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr)&#123;</span><br><span class="line">            currpath.push_back(root-&gt;val);</span><br><span class="line">            //put temp to ans if satisfies requrements</span><br><span class="line">            if(root-&gt;val == targetSum)&#123;</span><br><span class="line">                m_ans.push_back(currpath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //non-leaf node</span><br><span class="line">        //update current path</span><br><span class="line">        //search sub tree</span><br><span class="line">        currpath.push_back(root-&gt;val);</span><br><span class="line">        helper(root-&gt;left, targetSum-root-&gt;val, currpath);</span><br><span class="line">        helper(root-&gt;right, targetSum-root-&gt;val, currpath);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>437(tricky) This is the updated version of the path sum. Compared with the previous one, the started position is not clear, the end of the path is also not clear.</p>
<p>special cases</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1,null,2,null,3,null,4,null,5]</span><br><span class="line">3</span><br><span class="line">[1,-2,-3,1,3,-2,null,-1]</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>solution1, use naive recursion, there might be time limit exceeded issue (did not realize the issue of the start and end point)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//version 1, error prone</span><br><span class="line">//it requires to express the start point or end point clearly</span><br><span class="line">class Solution &#123;</span><br><span class="line">    int m_pathNum=0;</span><br><span class="line">    int m_origianlTarget=0;</span><br><span class="line">public:</span><br><span class="line">    int pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        m_origianlTarget = targetSum;</span><br><span class="line">        helper(root, &#123;&#125;, targetSum, true, 0);</span><br><span class="line">        return m_pathNum;</span><br><span class="line">    &#125;</span><br><span class="line">    //runtime issue for this code</span><br><span class="line">    void helper(TreeNode* root, vector&lt;int&gt; path, int temptargetSum, bool parentAdded, int level)&#123;</span><br><span class="line">        //null</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">                       </span><br><span class="line">        //path does not contains root, use the origianl target</span><br><span class="line">        //this should be considered firstly</span><br><span class="line">        //this can be called multiple times potentially</span><br><span class="line">        //first node, call this, otherwise, use the tempsum</span><br><span class="line">        if(parentAdded==false || path.size()==0)&#123;</span><br><span class="line">            //potentially start point</span><br><span class="line">            helper(root-&gt;left, &#123;&#125;, m_origianlTarget, false, level+1);</span><br><span class="line">            helper(root-&gt;right, &#123;&#125;,m_origianlTarget, false, level+1);          </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        //path contains the current node</span><br><span class="line">        //visit current</span><br><span class="line">        //bool isend = false;</span><br><span class="line">        if(root-&gt;val == temptargetSum)&#123;</span><br><span class="line">            if(parentAdded==true || path.size()==0)&#123;</span><br><span class="line">                //potentially end point</span><br><span class="line">                m_pathNum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //path contains root</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        helper(root-&gt;left, path,temptargetSum-root-&gt;val, true, level+1);</span><br><span class="line">        helper(root-&gt;right, path,temptargetSum-root-&gt;val, true, level+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The following code is the optimization of the version 1, the key point is to figure out if the current node is at the start position or at the following position, that is really important, use equals to 0 to decide the condition is more simplifier than the origianl case,we need to type fewer words in this case.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int m_pathNum=0;</span><br><span class="line">    long long m_origianlTarget=0;</span><br><span class="line">public:</span><br><span class="line">    int pathSum(TreeNode* root, long long targetSum) &#123;</span><br><span class="line">        m_origianlTarget = targetSum;</span><br><span class="line">        helper(root, targetSum, true);</span><br><span class="line">        return m_pathNum;</span><br><span class="line">    &#125;</span><br><span class="line">    //runtime issue for this code</span><br><span class="line">    void helper(TreeNode* root,long long int temptargetSum, bool ifstart)&#123;</span><br><span class="line">        //null</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //first node, call this, otherwise, use the tempsum</span><br><span class="line">        if(ifstart)&#123;</span><br><span class="line">            //start point</span><br><span class="line">            helper(root-&gt;left, m_origianlTarget, true);</span><br><span class="line">            helper(root-&gt;right, m_origianlTarget, true);          </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        temptargetSum-=root-&gt;val;</span><br><span class="line">        if(temptargetSum == 0)&#123;</span><br><span class="line">            //for the end node, do not check the subsequent nodes</span><br><span class="line">            m_pathNum++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //path contains root, other nodes are followers</span><br><span class="line">        //still check till the last one, the node can be negative</span><br><span class="line">        //there value may conteract with each other</span><br><span class="line">        helper(root-&gt;left, temptargetSum, false);</span><br><span class="line">        helper(root-&gt;right, temptargetSum, false); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This code is much more simple and refer to this <a href="https://zxi.mytechroad.com/blog/tree/leetcode-437-path-sum-iii/" target="_blank" rel="noopener">blog</a> , attention that for the first layer, the function name is the pathSum instead of the helper.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int pathSum(TreeNode* root, long long int targetSum) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        return helper(root, targetSum)+pathSum(root-&gt;left, targetSum)+pathSum(root-&gt;right, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int helper(TreeNode* root, long long int tempsum)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tempsum -= root-&gt;val;</span><br><span class="line">        return (tempsum == 0 ? 1 : 0)+helper(root-&gt;left,tempsum)+helper(root-&gt;right,tempsum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Lesson: one important idea is how to debug in recursion code: we might add the level into the print info, this can be an indicator and it can change the flattern code into the hierachy code and check the horizental and vertical. By doing this, we can find an error in our origianl code, at that time, we forget to add the condition when the path is just started. However, it is difficult to figure it out and understanding the code behaviours without the help of the debug info.</p>
<p>This code can be further optimized based on the 560 that computes the prefix sum. The single path in 560 changes to the multiple path on the tree for this question. Here is the optimization version for this question based on the idea of 560</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int m_pathNum=0;</span><br><span class="line">    int m_count = 0;</span><br><span class="line">    unordered_map&lt; long int, int&gt; psum;</span><br><span class="line">public:</span><br><span class="line">    int pathSum(TreeNode* root,  long targetSum) &#123;</span><br><span class="line">        //for the case when the element itsself equals to the targetSum</span><br><span class="line">        psum[0]=1; </span><br><span class="line">        helper(root, targetSum, 0);</span><br><span class="line">        return m_count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void helper(TreeNode* root, long int targetSum,  long currentSum)&#123;</span><br><span class="line">        //null</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //visit current node</span><br><span class="line">        //visit left and right from up to bottom</span><br><span class="line">        currentSum = currentSum+root-&gt;val;</span><br><span class="line"></span><br><span class="line">        int previousSum = currentSum - targetSum;</span><br><span class="line">        //printf(&quot;previousSum %d &quot;, previousSum);</span><br><span class="line">        m_count = m_count+psum[previousSum];</span><br><span class="line">        </span><br><span class="line">        //put current sum into the map</span><br><span class="line">        //default value is 0 for empty element</span><br><span class="line">        psum[currentSum]++;</span><br><span class="line">        </span><br><span class="line">        helper(root-&gt;left, targetSum, currentSum);</span><br><span class="line">        helper(root-&gt;right, targetSum, currentSum);</span><br><span class="line">        </span><br><span class="line">        //this is a really important part from the single path sum to the tree based path sum</span><br><span class="line">        //this is much smarter than copy the map between each recursion call</span><br><span class="line">        psum[currentSum]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The main part of visiting the node is same with the 560, main difference is that, remember to decrease specific elements from map after each call. Essentially, we need a different map for each path, but copy past map direactlly in each call is also time consuming, so we just adjust values in the map dynamically to make sure it works for different path.</p>
<p><strong>508. Most Frequent Subtree Sum</strong></p>
<p>The traversal part is common one, using the idea from the bottom to up, the subtree returns a particular value. The extra part is to use a map to keep track of the sum  during the tree traversal process. When the max freq is updated, we clear the ans, when freq of current sum equals to the max freq, we push the current sum, when the current sum is less than freq, we do nothing. (when there is tie means there are same frequent number for the two cases) </p>
<p>Start and the end of the path sum is comparatively clear in this question, which decrease its level of difficulty.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int maxFreq = 0;</span><br><span class="line">    //key is sum value is freq</span><br><span class="line">    unordered_map&lt;int, int&gt; freMap;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findFrequentTreeSum(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        helper(root, ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int helper(TreeNode* root, vector&lt;int&gt;&amp; ans)&#123;</span><br><span class="line">        </span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        </span><br><span class="line">        //get left sum</span><br><span class="line">        int leftSum = helper(root-&gt;left, ans);</span><br><span class="line">        </span><br><span class="line">        //get right sum</span><br><span class="line">        int rightSum = helper(root-&gt;right, ans);</span><br><span class="line">        </span><br><span class="line">        //with the current sum</span><br><span class="line">        int currSum = leftSum+rightSum+root-&gt;val;</span><br><span class="line">        </span><br><span class="line">        //compute freq, if not exist, default is 0</span><br><span class="line">        int currFreq = freMap[currSum]+1;</span><br><span class="line">        freMap[currSum]=currFreq;</span><br><span class="line">        </span><br><span class="line">        if(maxFreq&lt;currFreq)&#123;</span><br><span class="line">            //update the MaxFreq and ans</span><br><span class="line">            ans.clear();</span><br><span class="line">            maxFreq = currFreq;</span><br><span class="line">            // when equal, current freq is the maximum one update ans</span><br><span class="line">            ans.push_back(currSum);</span><br><span class="line">        &#125;else if(maxFreq==currFreq)&#123;</span><br><span class="line">            ans.push_back(currSum);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //do nothing when large than current</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return currSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>124 Binary Tree Maximum Path Sum</strong></p>
<p>The setting of the question is not that much straightforward and the start and end point of the path is not certained. We could confirm the general framework of the question, and use the bottom to up method approach. The tricky part is to make sure the return value and how to visit the current node.</p>
<p>The key thinking perspective is considering if the current node is included in the path. The maximum path can be following several options: left sum path + root, right sum path + root, left sum path + root + right sum path, or just the root itself (this situation is easy to be forgottern), since the node value can be negative, all these situations can be the maximum case.</p>
<p>The return part is also tricky, we just return the max value among the left side, the right side and the node itsself. Instead of returing the current possible max path sum. Since we just needs the left path or right path of the subtree to construct the new path. Anyway, the code is straightforward and the answer might need some time to come up with. Since the minpath and the return value for each recurssion call are two different variables here.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int maxSum = INT_MIN;</span><br><span class="line">public:</span><br><span class="line">    int maxPathSum(TreeNode* root) &#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        return maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int helper(TreeNode* root)&#123;</span><br><span class="line">        if(root==nullptr) return 0;  </span><br><span class="line">        //left</span><br><span class="line">        int lpsum = helper(root-&gt;left);</span><br><span class="line">        //right</span><br><span class="line">        int rpsum = helper(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        //visit &amp; compare</span><br><span class="line">        int lrsum = lpsum+root-&gt;val;</span><br><span class="line">        maxSum = max(maxSum, lrsum);</span><br><span class="line">        int rrsum = rpsum+root-&gt;val;</span><br><span class="line">        maxSum = max(maxSum, rrsum);</span><br><span class="line">        int lrrsum = lpsum+root-&gt;val+rpsum;</span><br><span class="line">        maxSum = max(maxSum, lrrsum);</span><br><span class="line">        </span><br><span class="line">        //single node without the child</span><br><span class="line">        //may also be the largest one</span><br><span class="line">        maxSum = max(maxSum, root-&gt;val);        </span><br><span class="line">        return max(max(lrsum, rrsum),root-&gt;val);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>543. Diameter of Binary Tree</strong></p>
<p>One similar question is the 543 which compute the diameter of the tree, these two questions use similar strategy and code framework. The 543 can be the foundataion of this question. The important point is that the helper function should not return the whole length, and it should return the max of left path or right path of the subtree. Another smart point is that they return -1 in their code when there is nullptr, which simplifies the expression from 2 layer node classification to 1 layer node classification. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int diameterOfBinaryTree(TreeNode* root) &#123;</span><br><span class="line">        int maxpath=0;</span><br><span class="line">        childp(root,maxpath);</span><br><span class="line">        return maxpath;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int childp(TreeNode* root, int&amp; maxpath)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // when connect with the root, the path length should increase 1</span><br><span class="line">        int lpath = childp(root-&gt;left,maxpath)+1;</span><br><span class="line">        int rpath = childp(root-&gt;right,maxpath)+1;</span><br><span class="line">        maxpath = max(maxpath, lpath+rpath);</span><br><span class="line">        return max(lpath,rpath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>687. Longest Univalue Path</strong></p>
<p>The idea of this question is not diffecult, it is a little bit similar with previous several questions, the key part is consider every situation clearly</p>
<p>For the version1, we calssify the node by null, leave node, one child, two children case. Then in the two children case, we further consider the relationship between the root node and the child node.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int maxpath;</span><br><span class="line">public:</span><br><span class="line">    int longestUnivaluePath(TreeNode* root) &#123;</span><br><span class="line">        lup(root);</span><br><span class="line">        return maxpath;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int lup(TreeNode* root)&#123;</span><br><span class="line">        //root null</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //leaf node</span><br><span class="line">        if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //at least one child</span><br><span class="line">        int lpath = lup(root-&gt;left);</span><br><span class="line">        int rpath = lup(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        //one child case</span><br><span class="line">        if(root-&gt;left &amp;&amp; root-&gt;right==nullptr)&#123;</span><br><span class="line">            if(root-&gt;val == root-&gt;left-&gt;val)&#123;</span><br><span class="line">               lpath++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">               lpath=0; </span><br><span class="line">            &#125;</span><br><span class="line">            maxpath=max(maxpath,lpath);</span><br><span class="line">            return lpath;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(root-&gt;right &amp;&amp; root-&gt;left==nullptr)&#123;</span><br><span class="line">            if(root-&gt;val == root-&gt;right-&gt;val)&#123;</span><br><span class="line">                rpath++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                rpath=0;</span><br><span class="line">            &#125;     </span><br><span class="line">            maxpath=max(maxpath,rpath);</span><br><span class="line">            return rpath;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        //two children case</span><br><span class="line">        //both left and right exist</span><br><span class="line">        </span><br><span class="line">        //if root node not equals to both side</span><br><span class="line">        if(root-&gt;val != root-&gt;left-&gt;val &amp;&amp; root-&gt;val != root-&gt;right-&gt;val)&#123;</span><br><span class="line">            maxpath=max(maxpath,0);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //root node equals to both side        </span><br><span class="line">        if(root-&gt;val == root-&gt;left-&gt;val&amp;&amp;root-&gt;val == root-&gt;right-&gt;val)&#123;</span><br><span class="line">            maxpath=max(maxpath,lpath+1+rpath+1);</span><br><span class="line">            return max(lpath+1, rpath+1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //if root node eqauls to one side</span><br><span class="line">        //left side</span><br><span class="line">        if(root-&gt;val == root-&gt;left-&gt;val)&#123;</span><br><span class="line">            maxpath=max(maxpath,lpath+1);</span><br><span class="line">            return lpath+1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //rside</span><br><span class="line">        maxpath=max(maxpath,rpath+1);</span><br><span class="line">        return rpath+1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>For the case2, we kind of merge the situation where there is one children and two<br>children case. Since when wen want to decide the situation of two children, we need to first decide the case when there is one children.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int maxpath;</span><br><span class="line">public:</span><br><span class="line">    int longestUnivaluePath(TreeNode* root) &#123;</span><br><span class="line">        lup(root);</span><br><span class="line">        return maxpath;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int lup(TreeNode* root)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int lpath = lup(root-&gt;left);</span><br><span class="line">        int rpath = lup(root-&gt;right);</span><br><span class="line">                </span><br><span class="line">        if(root-&gt;left)&#123;</span><br><span class="line">            if(root-&gt;val == root-&gt;left-&gt;val)&#123;</span><br><span class="line">               lpath++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">               lpath=0; </span><br><span class="line">            &#125;</span><br><span class="line">            maxpath=max(maxpath,lpath);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(root-&gt;right)&#123;</span><br><span class="line">            if(root-&gt;val == root-&gt;right-&gt;val)&#123;</span><br><span class="line">                rpath++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                rpath=0;</span><br><span class="line">            &#125;     </span><br><span class="line">            maxpath=max(maxpath,rpath);</span><br><span class="line">            //consider the case that root equals to child</span><br><span class="line">            if(root-&gt;left&amp;&amp;root-&gt;val == root-&gt;left-&gt;val&amp;&amp;root-&gt;val == root-&gt;right-&gt;val)&#123;</span><br><span class="line">                maxpath=max(maxpath,lpath+rpath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max(lpath,rpath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>236(235). Lowest Common Ancestor of a Binary Tree</strong></p>
<p>The naive solution is to use the idea based on the 257 which can remember the path of the tree traverse based on the dfs. When the node comes to the p, remember the path. When the node comdes to the q, remember the path. Then compare two path to find the last one that  is same with each other. This node is the LCA node. For this solution, remember that we can not guarantee the sequence to find the p or q, it is possible to find p first or find the q first.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    vector&lt;TreeNode*&gt; m_pathp;</span><br><span class="line">    vector&lt;TreeNode*&gt; m_pathq;</span><br><span class="line">    vector&lt;TreeNode*&gt; m_currpath;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        bool findp = false;</span><br><span class="line">        bool findq = false;</span><br><span class="line"></span><br><span class="line">        helper(root, p, q, findp, findq);</span><br><span class="line">        //fill int the m_pathp and m_pathq</span><br><span class="line">        int index = min(m_pathp.size(), m_pathq.size());</span><br><span class="line">        TreeNode* temp = nullptr;</span><br><span class="line">        //the unique value must exist</span><br><span class="line">        for(int i=0;i&lt;index;i++)&#123;</span><br><span class="line">            printf(&quot; %d &quot;, m_pathp[i]-&gt;val);</span><br><span class="line">            if(m_pathp[i]-&gt;val!=m_pathq[i]-&gt;val)&#123;</span><br><span class="line">                //find the first different node on the path</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=m_pathp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //the first one can be either p or q</span><br><span class="line">    void helper(TreeNode* root, TreeNode* p, TreeNode* q, bool&amp; findp, bool&amp; findq)&#123;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(findp == true &amp;&amp; findq == true)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //visit node in path</span><br><span class="line">        m_currpath.push_back(root);</span><br><span class="line">        </span><br><span class="line">        //when node comes to p</span><br><span class="line">        if(root-&gt;val==p-&gt;val)&#123;</span><br><span class="line">            //find p</span><br><span class="line">            //snapshot path</span><br><span class="line">            m_pathp = m_currpath;</span><br><span class="line">            findp = true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //when node comes to q</span><br><span class="line">        //compare with previous path</span><br><span class="line">        if(root-&gt;val==q-&gt;val)&#123;</span><br><span class="line">            //find q</span><br><span class="line">            //find the correct path</span><br><span class="line">            m_pathq = m_currpath;</span><br><span class="line">            findq = true;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        //left and right</span><br><span class="line">        helper(root-&gt;left, p, q, findp, findq);</span><br><span class="line">        helper(root-&gt;right, p, q, findp, findq);</span><br><span class="line">        //remove last element</span><br><span class="line">        m_currpath.pop_back(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This is another solution for this question. It use the idea that combines both top to down and bottom to up, it uses both current value and the value of lchild or rchild to decide the least common node in the tree. This method can avoid some unnecessary recursion operations.</p>
<p>It can decrease some search path depending the position of p and q. Consider the three node, current node (c), p and q. There are several possibilities about their positions:</p>
<p>a)p and q are not at the subtree of the c, return null in this case.<br>b)p and q are at the left subtree and right subtree respectively, return c in this case.<br>c)p and q are at one subtree of the c.</p>
<p>There are two further situations for the case c), the first one is that the c equals to p or q, return the c direactly in this case. Another situation is that the c not equals to p or q, in this case, return the lchild or rchild that is not null.</p>
<p>Here is a good explanation for this question (<a href="https://www.youtube.com/watch?v=KobQcxdaZKY" target="_blank" rel="noopener">https://www.youtube.com/watch?v=KobQcxdaZKY</a>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        //check current node</span><br><span class="line">        if(root == nullptr)&#123;</span><br><span class="line">            //for processing the edge case</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //current is p or q, return direactly</span><br><span class="line">        if(root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val)&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //lchild</span><br><span class="line">        TreeNode* lchild = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        //rchild</span><br><span class="line">        TreeNode* rchild = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        //if both of them is null</span><br><span class="line">        if(lchild == nullptr &amp;&amp; rchild ==nullptr)&#123;</span><br><span class="line">            // not contain p q in subtree</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //if both of them is not null</span><br><span class="line">        if(lchild &amp;&amp; rchild)&#123;</span><br><span class="line">            //current is the lsc</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //if one of them is null, return the specific one</span><br><span class="line">        //use conditional operator if we must return sth</span><br><span class="line">        return lchild==nullptr?rchild:lchild;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>968. Binary Tree Cameras</strong></p>
<p>It looks like a dp problem, since for each step, we can choose place camera or not</p>
<p>There is one answer looks a little bit complicated, but we considered things in a systamaticall way. Nameyly, null node, one child case and two children case. The status transfer between the two levels of the tree is important for solving the problem. </p>
<p>One tricky part is that when both left and right is the no camera but covered status, we have two options for the current node, either put camera here or weight for its parent. It looks that the dp approach is more general soluation. By analyzing this problem we can find that iftop is true, we prefer to put camera, other wise, we wait for the upper level node to put the camera.</p>
<p>I still did not figure out the how to compress the one child case, some code returns the camera monitored status when the node is null.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">// from top to down not right, for the case that medium node is monitored, we added more node</span><br><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    enum STATUS &#123;CM = 0, NCM = 1, NCNM=2&#125;;</span><br><span class="line">    int ans=0;</span><br><span class="line">    int minCameraCover(TreeNode* root) &#123;</span><br><span class="line">        //root is null</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //only one layer</span><br><span class="line">        if(root-&gt;left == nullptr &amp;&amp; root-&gt;right==nullptr)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //at least two layers</span><br><span class="line">        helper(root, true);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //when it is not at the top position, we can always postpone the choice</span><br><span class="line">    STATUS helper(TreeNode* root, bool iftop)&#123;</span><br><span class="line">        //leaf node</span><br><span class="line">        if(root-&gt;left == nullptr &amp;&amp; root-&gt;right ==nullptr)&#123;</span><br><span class="line">            return STATUS::NCNM;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // check left status</span><br><span class="line">        STATUS lstatus;</span><br><span class="line">        STATUS rstatus;</span><br><span class="line">        </span><br><span class="line">        if(root-&gt;left)&#123;</span><br><span class="line">             lstatus = helper(root-&gt;left, false);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(root-&gt;right)&#123;</span><br><span class="line">             rstatus = helper(root-&gt;right,false);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        // left child</span><br><span class="line">        if(root-&gt;left == nullptr)&#123;</span><br><span class="line">            //check the right part</span><br><span class="line">            if(rstatus == STATUS::NCNM)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                return STATUS::CM;</span><br><span class="line">            &#125;else if(rstatus == STATUS::NCM)&#123;</span><br><span class="line">                if(iftop)&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    return STATUS::CM;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return STATUS::NCNM;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                return STATUS::NCM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(root-&gt;right == nullptr)&#123;</span><br><span class="line">            //check lstatus</span><br><span class="line">            if(lstatus == STATUS::NCNM)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                return STATUS::CM;</span><br><span class="line">            &#125;else if(lstatus == STATUS::NCM)&#123;</span><br><span class="line">                if(iftop)&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    return STATUS::CM;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return STATUS::NCNM;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return STATUS::NCM;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        // two children</span><br><span class="line">        if(lstatus == STATUS::NCM &amp;&amp; rstatus == STATUS::NCM)&#123;</span><br><span class="line">            //there are two options when both children are ncamera covered</span><br><span class="line">            if(iftop)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                return STATUS::CM;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return STATUS::NCNM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(lstatus == STATUS::NCNM || rstatus == STATUS::NCNM)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            return STATUS::CM;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //other cases</span><br><span class="line">        return STATUS::NCM;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>After simplifying the code and assume the null node is the dummy node with the status NCM, we can get this simple code, although the code is simple, but the logical process to create this code is not simple, we need to consider all 3*3 possibilities and compress them into the simplified form as follows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;   </span><br><span class="line">public:</span><br><span class="line">    enum STATUS &#123;CM = 0, NCM = 1, NCNM=2&#125;;</span><br><span class="line">    int ans=0;</span><br><span class="line">    int minCameraCover(TreeNode* root) &#123;</span><br><span class="line">        //root is null</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //at least two layers</span><br><span class="line">        helper(root, true);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //when it is not at the top position, we can always postpone the choice</span><br><span class="line">    STATUS helper(TreeNode* root, bool iftop)&#123;</span><br><span class="line">        //null</span><br><span class="line">        if(root == nullptr)&#123;</span><br><span class="line">            return STATUS::NCM;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        STATUS lstatus = helper(root-&gt;left,  false);</span><br><span class="line">        STATUS rstatus = helper(root-&gt;right, false);</span><br><span class="line">        </span><br><span class="line">        // two children, the null node can be viewed as a dummy child</span><br><span class="line">        if(lstatus == STATUS::NCM &amp;&amp; rstatus == STATUS::NCM)&#123;</span><br><span class="line">            //there are two options when both children are ncamera covered</span><br><span class="line">            if(iftop)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                return STATUS::CM;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return STATUS::NCNM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(lstatus == STATUS::NCNM || rstatus == STATUS::NCNM)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            return STATUS::CM;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //other cases</span><br><span class="line">        return STATUS::NCM;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The solution provided by leetcode looks much simple. Another one is based on the dynamic programming. The essential of the dp is to memorize all the status. TODO, also add the dp solution here.</p>
<h3 id="Typical-questions-Modify-the-tree-structure"><a href="#Typical-questions-Modify-the-tree-structure" class="headerlink" title="Typical questions: Modify the tree structure"></a>Typical questions: Modify the tree structure</h3><p><strong>814. Binary Tree Pruning</strong></p>
<p>Pruning the subtree with a particular properties. The common strategy is from bottom to up and let every subtree satisfies the requirments firstly. Be careful of the condition. If current node contains 0, and one of the child exist, it means that one of the subtree contains the 1, the current node and subtree satisfies the condition and should not be removed. <strong><em>The idea from bottom to up to reconstruct the whole tree is crutial for the problem that need to modify the tree structure.</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">  TreeNode* pruneTree(TreeNode* root) &#123;</span><br><span class="line">    if (root==nullptr) return nullptr;</span><br><span class="line">    //the left subtree is already cleaned</span><br><span class="line">    //it contains 1 if the left is not nullptr</span><br><span class="line">    root-&gt;left = pruneTree(root-&gt;left);</span><br><span class="line">    //the right part is already clearned</span><br><span class="line">    //it contains the 1 if right is nullptr</span><br><span class="line">    root-&gt;right = pruneTree(root-&gt;right);</span><br><span class="line">    //visit current node</span><br><span class="line">    //if the subtree contains 1</span><br><span class="line">    //keep it, otherwise, delete whole tree</span><br><span class="line">    //or one of left or right exist, which means the subtree</span><br><span class="line">    //contains the 1</span><br><span class="line">    if (root-&gt;val == 1 || root-&gt;left || root-&gt;right)&#123;</span><br><span class="line">        return root;   </span><br><span class="line">    &#125;</span><br><span class="line">    //delete current node</span><br><span class="line">    //also delete left and right</span><br><span class="line">    //this function is unnecessary for result correctness</span><br><span class="line">    removeTree(root);</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  void removeTree(TreeNode* root)&#123;</span><br><span class="line">      if(root==nullptr)&#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      //remove left</span><br><span class="line">      removeTree(root-&gt;left);</span><br><span class="line">      //remove right</span><br><span class="line">      removeTree(root-&gt;right);</span><br><span class="line">      //remove current</span><br><span class="line">      delete root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>More complicated trim operation, we need to adjust tree structure</strong></p>
<p>The key strategy here is to consider the type of the node during the removal operation, if the removed node is leaf node or the node with one child or the node with two childern, etc. The code is more clear if considering things in this way.</p>
<p><strong>669. Trim a Binary Search Tree</strong></p>
<p>The operation is simple, just delete a node and adjust the tree structure. Be careful for the case discussion when we detected that the node should be removed.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* findLeftNode(TreeNode* root)&#123;</span><br><span class="line">        if(!root) return nullptr;</span><br><span class="line">        //if there is left node, move to the left</span><br><span class="line">        while(root-&gt;left)&#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;</span><br><span class="line">        </span><br><span class="line">        if(root==nullptr) return nullptr;</span><br><span class="line">        </span><br><span class="line">        //left</span><br><span class="line">        TreeNode* lchild = trimBST(root-&gt;left, low, high);</span><br><span class="line">        //right</span><br><span class="line">        TreeNode* rchild = trimBST(root-&gt;right, low, high);</span><br><span class="line"></span><br><span class="line">        //visit current</span><br><span class="line">        //if the node need to be deleted</span><br><span class="line">        //supposed to return if it is removed</span><br><span class="line">        if(root-&gt;val&lt;low || root-&gt;val&gt;high)&#123;</span><br><span class="line">            //remove node, there is bug for some case such as [1, null, 2] 2, 4</span><br><span class="line">            //when add this, not sure the reason</span><br><span class="line">            //delete root;</span><br><span class="line">            //leaf</span><br><span class="line">            if(lchild==nullptr &amp;&amp; rchild==nullptr)&#123;</span><br><span class="line">                return nullptr;</span><br><span class="line">            &#125;else if(lchild || rchild)&#123;</span><br><span class="line">                //one child</span><br><span class="line">                if(lchild) return lchild;</span><br><span class="line">                if(rchild) return rchild;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //two children</span><br><span class="line">                //the left tree should be the</span><br><span class="line">                //left side of the right tree</span><br><span class="line">                TreeNode* leftNode = findLeftNode(rchild);</span><br><span class="line">                leftNode-&gt;left = lchild;</span><br><span class="line">                return rchild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //current root satisfy condition</span><br><span class="line">        //update left and right</span><br><span class="line">        root-&gt;left = lchild;</span><br><span class="line">        root-&gt;right= rchild;</span><br><span class="line">        return root;            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Actually, this code can be further improved and we can notice that the case when there are two children if actaully not exist.</p>
<p>For example, if the current node value is c and it does not blongs to the [L,R], if c&lt;L, all the nodes in left of the c &lt; c &lt; L, so all of these nodes should be removed till the current step. Similarly, when the c&gt;R, all the right side nodes of the c &gt; c &gt; R, so the right side subtree should be removed before hand. This fact shows that there only exist two cases for the current recursion step, either c is the leaf node or have one side subtree.</p>
<p>1325 is a similar question, the constrains of removed node is more simple in this question.</p>
<p><strong>450. Delete Node in a BST</strong></p>
<p>The code framework and main considerations for this problem are similar with the previous one. Reuse the existing operation to deleted the selected node for the two children case is a smart point.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* deleteNode(TreeNode* root, int key) &#123;</span><br><span class="line">        return help(root, key, nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode* findMax(TreeNode* root)&#123;</span><br><span class="line">        while(root-&gt;right!=nullptr)&#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode* help(TreeNode* root, int key, TreeNode*parent)&#123;</span><br><span class="line">        </span><br><span class="line">        // edge case</span><br><span class="line">        //root is nullptr</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //find targeted node</span><br><span class="line">        if(key&lt; root-&gt;val)&#123;</span><br><span class="line">            help(root-&gt;left, key, root);</span><br><span class="line">        &#125;else if(key &gt; root-&gt;val)&#123;</span><br><span class="line">            help(root-&gt;right, key, root);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        if(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr)&#123;</span><br><span class="line">            //case1 node is leaf node</span><br><span class="line">            if(parent==nullptr)&#123;</span><br><span class="line">                //[1] 1 </span><br><span class="line">                delete(root);</span><br><span class="line">                return nullptr;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(root-&gt;val &gt; parent-&gt;val)&#123;</span><br><span class="line">                    //rchild</span><br><span class="line">                    parent-&gt;right= nullptr;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    parent-&gt;left=nullptr;</span><br><span class="line">                &#125;</span><br><span class="line">                delete(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(root-&gt;left == nullptr || root-&gt;right == nullptr)&#123;</span><br><span class="line">            //case2 one child</span><br><span class="line">            if(parent==nullptr)&#123;</span><br><span class="line">                if(root-&gt;left)&#123;</span><br><span class="line">                    return root-&gt;left;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return root-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                delete(root);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(root-&gt;val&gt;parent-&gt;val)&#123;</span><br><span class="line">                    //reset the right pointer</span><br><span class="line">                    if(root-&gt;right)&#123;</span><br><span class="line">                        parent-&gt;right=root-&gt;right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(root-&gt;left)&#123;</span><br><span class="line">                        parent-&gt;right=root-&gt;left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    delete(root);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if(root-&gt;right)&#123;</span><br><span class="line">                        parent-&gt;left=root-&gt;right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(root-&gt;left)&#123;</span><br><span class="line">                        parent-&gt;left=root-&gt;left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    delete(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //case3 two children            </span><br><span class="line">            TreeNode* leftMaxNode = findMax(root-&gt;left);</span><br><span class="line">            int leftMaxValue = leftMaxNode-&gt;val;</span><br><span class="line">            help(root-&gt;left, leftMaxValue, root);</span><br><span class="line">            root-&gt;val = leftMaxValue;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Typical-questions-the-combinations-of-tree-and-array"><a href="#Typical-questions-the-combinations-of-tree-and-array" class="headerlink" title="Typical questions: the combinations of tree and array"></a>Typical questions: the combinations of tree and array</h3><p>This type of questions use both the techniques used in tree and array (maybe map) to solve the problem</p>
<p><strong>297 Serialize and Deserialize Binary Tree</strong></p>
<p>The idea of this question is not complecated, but it is really error-prone. We use the layered traversal here based on the queue, be careful about the condition that when there is the mix of the nullptr node and the actual solide node. This is a little bit different with the level order question such as 429, since the null node also need to be considered if current level contains both empty and solid node</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">class Codec &#123;</span><br><span class="line">public:</span><br><span class="line">    // Encodes a tree to a single string.</span><br><span class="line">    // the origianl way use the layer approach</span><br><span class="line">    // it is also possible to use other approach</span><br><span class="line">    // if using the NLR</span><br><span class="line">    string serialize(TreeNode* root) &#123;</span><br><span class="line">        string str=&quot;&quot;;</span><br><span class="line">        if(root==nullptr)&#123;</span><br><span class="line">            return str;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        //nullnode       </span><br><span class="line">        int levelSize = q.size();</span><br><span class="line">        //label if the next layer contains the solide node</span><br><span class="line">        //if the next layer contains no solid node, return true</span><br><span class="line">        bool nextcontainSolid = true;</span><br><span class="line">        while (q.empty()==false &amp;&amp; nextcontainSolid)&#123;</span><br><span class="line">            nextcontainSolid = false;</span><br><span class="line">            while(levelSize&gt;0)&#123;</span><br><span class="line">                levelSize--;</span><br><span class="line">                TreeNode *temp = q.front();            </span><br><span class="line">                //visit node</span><br><span class="line">                if(temp!=nullptr)&#123;</span><br><span class="line">                    str+=to_string(temp-&gt;val)+&quot;,&quot;;    </span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    str+=&quot;#,&quot;;</span><br><span class="line">                    q.pop();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                q.pop();</span><br><span class="line">                if(temp-&gt;left) &#123;</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                    nextcontainSolid = true;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    q.push(nullptr);</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp-&gt;right)&#123;</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">                    nextcontainSolid = true;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    q.push(nullptr); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            levelSize = q.size();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //printf(&quot;%s&quot;, str.c_str());</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Decodes your encoded data to tree.</span><br><span class="line">    TreeNode* deserialize(string data) &#123;</span><br><span class="line">        // reconstruct based on the layered structure</span><br><span class="line">        if(data==&quot;&quot;)&#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        // split the str based on , </span><br><span class="line">        string delimiter = &quot;,&quot;;</span><br><span class="line">        int delimLength = delimiter.length();</span><br><span class="line">        int posStart=0;</span><br><span class="line">        int posEnd=0;</span><br><span class="line">        TreeNode* root = nullptr;</span><br><span class="line">        TreeNode* parent = nullptr;</span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        int index=0;</span><br><span class="line">        while ((posEnd = data.find(delimiter,posStart)) != string::npos) &#123;</span><br><span class="line">            string token = data.substr(posStart, posEnd-posStart);</span><br><span class="line">            //check the element </span><br><span class="line">            //printf(&quot;&lt;%s&gt;&quot;, token.c_str());</span><br><span class="line">            //constructure by layered way</span><br><span class="line">            if(root==nullptr)&#123;</span><br><span class="line">                //the first element</span><br><span class="line">                root = new TreeNode(stoi(token));</span><br><span class="line">                q.push(root);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(index%2==0)&#123;</span><br><span class="line">                    //update the parent</span><br><span class="line">                    //when the current left and right are built ok</span><br><span class="line">                    parent = q.front();</span><br><span class="line">                    q.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                // construct node</span><br><span class="line">                // the parent is root for the first case</span><br><span class="line">                TreeNode* current=nullptr;</span><br><span class="line">                if(token!=&quot;#&quot;)&#123;</span><br><span class="line">                    current = new TreeNode(stoi(token));</span><br><span class="line">                    //printf(&quot;curr %d parr %d &quot;, current-&gt;val, parent-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // left or right separately</span><br><span class="line">                if(index%2==0)&#123;</span><br><span class="line">                    parent-&gt;left = current;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    parent-&gt;right = current;</span><br><span class="line">                &#125;                </span><br><span class="line">                </span><br><span class="line">                // node is not null</span><br><span class="line">                // push node into the queue</span><br><span class="line">                if(current!=nullptr)&#123;</span><br><span class="line">                    q.push(current);</span><br><span class="line">                &#125;                </span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            posStart=posEnd+delimLength;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The similar one is the 449, we can also use the similar level traversal techniques.  Is there more efficient techniques for the bst structure?</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/04/21/Algorithm-8-Tree/" data-id="cl2sg01ya007ak90ags2io1bt" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
 <script src="/jquery/jquery.min.js"></script>
  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2022/04/24/GraphicsBasics/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          GraphicsBasics
        
      </div>
    </a>
  
  
    <a href="/2022/03/20/phd-story/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">PhD story</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Key-techniques-and-considerations"><span class="toc-number">1.</span> <span class="toc-text">Key techniques and considerations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Typical-questions-Traverse-tree"><span class="toc-number">2.</span> <span class="toc-text">Typical questions: Traverse tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Typical-questions-search-particular-properties-of-the-tree"><span class="toc-number">3.</span> <span class="toc-text">Typical questions: search particular properties of the tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Typical-questions-Modify-the-tree-structure"><span class="toc-number">4.</span> <span class="toc-text">Typical questions: Modify the tree structure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Typical-questions-the-combinations-of-tree-and-array"><span class="toc-number">5.</span> <span class="toc-text">Typical questions: the combinations of tree and array</span></a></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2022 zhe&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;godenwangzhe@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>