<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Algorithm(8) Naive Tree(By input data structure) | AverageMind</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="The typical algorithm questions based on the tree structure.">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithm(8) Naive Tree(By input data structure)">
<meta property="og:url" content="http://yoursite.com/2022/04/21/Algorithm-8-Tree/index.html">
<meta property="og:site_name" content="AverageMind">
<meta property="og:description" content="The typical algorithm questions based on the tree structure.">
<meta property="og:locale">
<meta property="article:published_time" content="2022-04-21T20:22:42.000Z">
<meta property="article:modified_time" content="2023-11-16T04:07:24.988Z">
<meta property="article:author" content="zhe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="AverageMind" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-165927341-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
<!-- Google adds -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5642436380582343"
     crossorigin="anonymous">
</script>
<!-- End Google adds -->




<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AverageMind</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Algorithm-8-Tree" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/21/Algorithm-8-Tree/" class="article-date">
  <time datetime="2022-04-21T20:22:42.000Z" itemprop="datePublished">2022-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Algorithm(8) Naive Tree(By input data structure)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>The typical algorithm questions based on the tree structure.</p>
<span id="more"></span>

<p>This article describes several key considerations of the tree and binary search tree, we first describe the commonly techniques and thinking perspectives to solve these type of problems and then we list several specific problem and there soluations, we may put these solutions into different blogs in future.</p>
<p>The list of sample questions is based on <a target="_blank" rel="noopener" href="https://docs.google.com/spreadsheets/d/1yRCOJ8KysRVkq0O9IlDriT01tC6lzPapmFO4PCmDJQA/edit#gid=972946549">this table</a></p>
<p>This part mainly contains question which provides a tree structure explicitly. The more complexed question based on decision tree or search tree can be and different context is listed in another blog. In this blog, we only list the question that provide the tree structure as the input in explicit way. This table summarize the question listed in this article.</p>
<table>
<thead>
<tr>
<th>Traverse tree</th>
<th>Modify tree structure</th>
<th>Tree properties <br> (whole tree)</th>
<th>Tree properties <br> (search path <br> path sum, nodes)</th>
<th>Serilization</th>
<th>Search with <br> map optimization</th>
</tr>
</thead>
<tbody><tr>
<td>94,429,987</td>
<td>814,669,450 <br> 701,99,108</td>
<td>100,572,101 <br> 110,965,872<br>98</td>
<td>111,112,129<br>113,437,508<br>124,543,235<br>968,501,230</td>
<td>297</td>
<td>337</td>
</tr>
</tbody></table>
<h3 id="Key-techniques-and-considerations"><a href="#Key-techniques-and-considerations" class="headerlink" title="Key techniques and considerations"></a>Key techniques and considerations</h3><ul>
<li><p>(1) Classification of the tree node, instead of classifying it into the leaf or null leaf, just assume it is null or not null, or more complex form such as 968 (covered or not covered, 450 is also a good classification example, leaf node, have 1 child, have two child), 257 classifies the node to null node, leaf node and not null node.</p>
</li>
<li><p>(2) From up to bottom, the lower level nodes need the information of the upper level nodes.</p>
</li>
<li><p>(3) From bottom to up, the left and right child tree returns root or specific value, the upper level nodes needs the information of the lower level nodes or subtrees. Make sure which is more eaiser. Sometimes knowing the child status then compute the parent status is more easier, some times knowing parent status then process child case is more easier. 337 is a good example in this case. 98 is a good example to try both bottom to up and up to the bottom case.</p>
</li>
<li><p>(4) Bst tree, the in order traverse (LNR) is the array with ascending values</p>
</li>
<li><p>(5) Typical strategy to insert or delete the node, how to acquire the parent pointer for different questions (the 450 can be a complex one for this type)</p>
</li>
<li><p>(6) The idea of calling level is important for these type of questions, For example, we may print the information of recursion level to debug the code. Besides, for the searching path, remember that the element need to be poped out after each level function call, this techniques are used in 257 and the 437.</p>
</li>
<li><p>(7) When there is the combination of tree and the string, the key step is to map the string into the tree structure logically and we ususlly does not need an explicit tree in that case. But we may use the recursion method. It is important to remember several typical questions and what are the gaps here.</p>
</li>
</ul>
<p>Here are some key thinking perspectives, these ideas can also be used to solving other problems, these steps are useful especially when you do not have ideas for solving current problem </p>
<ul>
<li><p>Consider the data structure adopted by the problem, from the domain specific problem to a cs algorithm problem, this step is comparatively simple for easy or medium question</p>
</li>
<li><p>Confirm the type of problem, typically type of problem is modify, search specific results or compute optimization situation. After confirming this, we can further move to another step.</p>
</li>
<li><p>For the problem of searching, we first need to figure out the total status and the total combinations, then we use the constrains and the techniques discussed above to narrow down these situations. For the problem of modifying, just be caring of common operations for create delete nodes, the tricks of keeping parent pointer etc.</p>
</li>
<li><p>Other specific type of problems (such as search possible solutions) are related to tree, but not totally related, we use another blog to discuss these questions (parathesis match, work search, sudoku problem, queens problem and puzzle problem).</p>
</li>
<li><p>(8) Sth that might be asked in the interview is actually the multi order tree or the tree with multiple children. The thought can be limited if only considering the tree with two branch. One typical question is to build a index that can find a min value in specific sub range of array. In this case, we might have multiple segment, we store the min value of each segment, the min value of whole array is must one of the these subrange, then we just find the one that is minimal in this subrange, we can even sort each level of children to accelarate the searching process. The multiple node tree can be the founudation of B tree, these question might be asked in practical interview. The start point is find an element in specific range, then move to the harder one. The complicated idea of b tree than multi-branch tree is how to make each node more balanced and split the node. The key idea behind the index is just remember the search path as it is, not the searching operation itsself. (When we search it, we build it and then we can reuse this index tree)</p>
</li>
</ul>
<h3 id="Traverse-tree"><a href="#Traverse-tree" class="headerlink" title="Traverse tree"></a>Traverse tree</h3><p><strong>94. Binary Tree Inorder Traversal</strong></p>
<p>This is really typical one, the inorder traversal represents the LNR traversal. The node type is divided into nullptr or not nullptr, this can be the basic framework for more complicated algorithm. </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans; </span><br><span class="line">        <span class="built_in">help</span>(root, ans);  </span><br><span class="line">        <span class="keyword">return</span> ans;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">help</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// left</span></span><br><span class="line">        <span class="built_in">help</span>(root-&gt;left,ans);</span><br><span class="line">        <span class="comment">// current</span></span><br><span class="line">        ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="comment">// right</span></span><br><span class="line">        <span class="built_in">help</span>(root-&gt;right, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>144 and 145 are similar problems, they are preorder (NLR) and postorder (LRN) traversal, respectively. 589 and 590 is the N children problem.</p>
<p><strong>429. N-ary Tree Level Order Traversal</strong></p>
<p>how to process the height information? There is no associated variable defination in the tree structure. This is the code that use the BFS style code based on the queue. The key idea that label the level is to <em>remember the queue size after each level</em>. Then at the next iteration, we just need to pop out the node in the previous level, and then the remaning elements are nodes on the current level. We do similar things and move to the next iteration step by step.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Time complexity O(n)</span></span><br><span class="line"><span class="comment">// Space complexity O(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="built_in">help</span>(root, ans, temp, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">help</span><span class="params">(Node* root,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans,vector&lt;<span class="type">int</span>&gt;&amp; temp, <span class="type">bool</span> iflast)</span></span>&#123;</span><br><span class="line">        <span class="comment">//put the temp into the ans if switch the height</span></span><br><span class="line">        <span class="comment">//if the current node is null, hit a new level, then push</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> levelsize = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">empty</span>()==<span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(levelsize&gt;<span class="number">0</span>)&#123;        </span><br><span class="line">                levelsize--;</span><br><span class="line">                Node* curr=q.<span class="built_in">front</span>();</span><br><span class="line">                temp.<span class="built_in">push_back</span>(curr-&gt;val);</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;curr-&gt;children.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(curr-&gt;children[i]);</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="comment">// this layer finish</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            temp.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="comment">// current queue size, there are qsize element</span></span><br><span class="line">            <span class="comment">// the elements in the queue are elements at a new level now</span></span><br><span class="line">            levelsize = q.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Another similar code is <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solution/cong-shang-dao-xia-da-yin-er-cha-shu-ii-fzejw/">this one</a> we basically need one while loop to adjust the q size and one for loop (or while loop) to monitor the number of current level.</p>
<p>The code can also be written in an <a target="_blank" rel="noopener" href="https://zxi.mytechroad.com/blog/tree/leetcode-107-binary-tree-level-order-traversal-ii/">recursive way</a>. The general framework of recursion is easy to write, the key part is that we set the depth and insert the associated elements into the proper position. We also insert the empty array into the ans vector during the recursion process. The code of the recursive way is more clean. This is actually the dfs code, which is not the bfs code !!! The recursion call is in the dfs order.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">help</span>(root, ans, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(Node* root, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;ans, <span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if the new layer</span></span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">size</span>()&lt;(depth+<span class="number">1</span>))&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// visit node</span></span><br><span class="line">        ans[depth].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="comment">// call children recursively</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> child: root-&gt;children)&#123;</span><br><span class="line">            <span class="built_in">help</span>(child, ans, depth+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Similar problem:</p>
<p>102 is also similar one, just using the level order, the code is simple when using the recursion method discussed above.</p>
<p>107 its input data structure is the binary tree, which is the simplified version of the 429. The 107 require the output sequence from the bottom to up. So we only need to add <code>reverse(ans.begin(), ans.end())</code> before returning the ans.</p>
<p>104 is also similar one, just compute the maxdepth of the tree direactly.</p>
<p><strong>987. Vertical Order Traversal of a Binary Tree</strong></p>
<p>Using the data structure in a wise way is the key for this question. The first key of the map indicates the column, the second key indicates the row, the multiset indicates there are multiple elements in same column, row index and the elements is stored in ascending manner, and the elements can also be repeated in the set.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">verticalTraversal</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="comment">// why use the multiset: check this data [3,1,4,0,2,2]</span></span><br><span class="line">        map&lt;<span class="type">int</span>, map&lt;<span class="type">int</span>, multiset&lt;<span class="type">int</span>&gt;&gt;&gt; mymap;</span><br><span class="line">        <span class="built_in">helper</span>(root, mymap, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span> (mymap.<span class="built_in">size</span>());</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:mymap)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> itmapset : it.second)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> itset: itmapset.second)&#123;</span><br><span class="line">                    <span class="comment">//printf(&quot;itset %d\n&quot;,itset);</span></span><br><span class="line">                    ans[i].<span class="built_in">push_back</span>(itset);                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, map&lt;<span class="type">int</span>, map&lt;<span class="type">int</span>, multiset&lt;<span class="type">int</span>&gt;&gt;&gt;&amp; mymap, <span class="type">int</span> row, <span class="type">int</span> column)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mymap[column][row].<span class="built_in">insert</span>(root-&gt;val);</span><br><span class="line">        <span class="comment">//children</span></span><br><span class="line">        <span class="comment">//left</span></span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;left, mymap, row+<span class="number">1</span>, column<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//right</span></span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;right, mymap, row+<span class="number">1</span>, column+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Compared with using a grid, using the ordered map is more simple, other soluation also use the pair as the key of the map</p>
<p>Similar questions:</p>
<p>1302, just sum up the deepest leaves, the question is, how do we know it is the deepest leaves. The idea is just using a spearate depth variable and keep the newest value, then add varaible into the sum </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// one solution for 1302</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxDepth=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> layersum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deepestLeavesSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">helper</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> layersum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="type">int</span> currDepth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//visit node, add some trim operation </span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(currDepth&gt;maxDepth)&#123;</span><br><span class="line">                maxDepth =  currDepth;</span><br><span class="line">                layersum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(currDepth == maxDepth)&#123;</span><br><span class="line">                layersum = layersum + root-&gt;val;</span><br><span class="line">            &#125;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//move to the children</span></span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;left,currDepth+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;right,currDepth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>257 Binary Tree Paths</strong></p>
<p>This question requires to print out the searching paths, one key idea is to adjust current searching path. We use a vector store the searching path, when current level of recursion finish, we then pop back the last element in the vector, by this way, we can always make sure the element in the vector is located in the current path. The similar ideas is also used in the 437, in that case, we decrease the associated path number after leaving the current recursion call each time. The search path here is based on the idea of the dfs essentially.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;string&gt; m_ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; m_path;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">helper</span>(root);</span><br><span class="line">        <span class="keyword">return</span> m_ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//visit leaf node</span></span><br><span class="line">        m_path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if leaf, add path info</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">//put currpath into the m_ans</span></span><br><span class="line">            string tempstr;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_path.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    tempstr=tempstr+<span class="built_in">to_string</span>(m_path[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tempstr=tempstr+<span class="string">&quot;-&gt;&quot;</span>+<span class="built_in">to_string</span>(m_path[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            m_ans.<span class="built_in">push_back</span>(tempstr);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//remove one elem</span></span><br><span class="line">            <span class="comment">//the leaf node return earlyer at this case</span></span><br><span class="line">            m_path.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//children</span></span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//remove elem in current level</span></span><br><span class="line">        m_path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Tree-properties-whole-tree"><a href="#Tree-properties-whole-tree" class="headerlink" title="Tree properties (whole tree)"></a>Tree properties (whole tree)</h3><p><strong>Compare if two trees are same, mirror or satisfies certain constraints</strong></p>
<p>100 check the same tree, we can use any type of iteration method discussed above, if there is null equal during the recursive process, return the false, otherwise, return true.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// be carefule for the several special cases for deciding the same tree</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">nullptr</span> &amp;&amp; q)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p &amp;&amp; q==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p &amp;&amp; q)&#123;</span><br><span class="line">            <span class="comment">//visit</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val != q-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//check the child</span></span><br><span class="line">            <span class="type">bool</span> leftSame = <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(leftSame==<span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="type">bool</span> rightSame = <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(rightSame==<span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>572 Subtree of Another Tree, this is the updated version for comparing if two trees are same with each other. Traverse the original tree based on NLR sequence, if the node value equals with the subroot value, executed comparision operation. Otherwise, continue check.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//572. Subtree of Another Tree</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//edge cases</span></span><br><span class="line">        <span class="keyword">if</span>(!root &amp;&amp; !subRoot)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!subRoot)&#123;</span><br><span class="line">            <span class="comment">// subroot is null but root is not</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="comment">// the root is null but subRoot is not null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//go through left and right</span></span><br><span class="line">        <span class="type">bool</span> leftContain = <span class="built_in">isSubtree</span>(root-&gt;left, subRoot);</span><br><span class="line">        <span class="type">bool</span> rightContain = <span class="built_in">isSubtree</span>(root-&gt;right, subRoot);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(leftContain || rightContain)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(leftContain == <span class="literal">false</span> &amp;&amp; rightContain==<span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val == subRoot-&gt;val)&#123;</span><br><span class="line">                <span class="type">bool</span> same=<span class="built_in">isSameTree</span>(root, subRoot);</span><br><span class="line">                <span class="keyword">if</span>(same)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">nullptr</span> &amp;&amp; q)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p &amp;&amp; q==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p &amp;&amp; q)&#123;</span><br><span class="line">            <span class="comment">//visit</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val != q-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//check the child</span></span><br><span class="line">            <span class="type">bool</span> leftSame = <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(leftSame==<span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="type">bool</span> rightSame = <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(rightSame==<span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The above code reuse the function of 100, it still looks a little bit complicated and error prone. For the edge cases, we need to consider four situations and confirm the case that one of the child is nullptr. It also uses the idea of compare left part then compare the right part, since there is a return value of the function. For example, after deciding that the left part do not contain subtree, the right part does not contain subtree and the current root does not contains subtree, we can returns the false.</p>
<p>The 101 symmetric tree is also a similar question, the condition of mirror is just reverse the left and right, one case is right to left, another case is right to left, to decide if they are equal. This is similar with previous one, the difference is the traversal sequence. The origianl thought is to use LNR to traverse left and use RNL to traverse right, then compare the results. But this input <code>[1,2,2,2,null,2]</code> have the same results eigher for LNR and RNL. So it is not uniquely to decide if two parts are mirror of each other. Although the result is straightforward, it is not easy to provide the reuslts at the first glance.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Compare</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Compare</span><span class="params">(TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">nullptr</span> &amp;&amp; q)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p &amp;&amp; q == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p &amp;&amp; q)&#123;</span><br><span class="line">            <span class="comment">//visit</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val != q-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">bool</span> leftSame = <span class="built_in">Compare</span>(p-&gt;left, q-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(leftSame==<span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">bool</span> rightSame = <span class="built_in">Compare</span>(p-&gt;right, q-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(rightSame==<span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;             </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>110 check if the tree is balanced. This is a little bit special, since it introduce the idea from the bottom to up. Namely, the helper function returns some information and this information will be used by the upper level. These type of paradigm is used a lot when modify the tree structure.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> height=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(root, height);  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="type">int</span>&amp; height)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//left balanced</span></span><br><span class="line">        <span class="type">int</span> leftHeight=<span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> leftBalanced = <span class="built_in">helper</span>(root-&gt;left, leftHeight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//right balanced</span></span><br><span class="line">        <span class="type">int</span> rightHeight=<span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> rightBalanced = <span class="built_in">helper</span>(root-&gt;right, rightHeight);         </span><br><span class="line">        height=<span class="built_in">max</span>(leftHeight,rightHeight)+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check diff</span></span><br><span class="line">        <span class="keyword">if</span>(leftBalanced &amp;&amp; rightBalanced)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(leftHeight-rightHeight)&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>965 is also a similar one, just simple checking based on the bottom to up recursion. The properties for these questions is to detect the results of the subtree first and then use the return results to decide the current results.</p>
<p>872 is a similar one with the simple background, the idea of code classification is good. null ptr, leaf, one child, two childern. Pay attention to the sequence of the checking and make sure all situations are considered.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">leafSimilar</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//get leaf sequecnce of the first one</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; seq1;</span><br><span class="line">        <span class="built_in">getLeafSeq</span>(root1, seq1);</span><br><span class="line">        <span class="comment">// get leaf sequence of the second one</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; seq2;</span><br><span class="line">        <span class="built_in">getLeafSeq</span>(root2, seq2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(seq1.<span class="built_in">size</span>()!=seq2.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;seq1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(seq1[i]!=seq2[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getLeafSeq</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//leaf</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//one child</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            <span class="built_in">getLeafSeq</span>(root-&gt;left, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            <span class="built_in">getLeafSeq</span>(root-&gt;right, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>98. Validate Binary Search Tree</strong></p>
<p>The idea is not complicated, we make sure the left subtree is valid, the right subtree is valid, then adding the root into the tree to make the current tree is valid. There are two points, one is that we need to record the max value of the left tree to make sure current node is larger than all value in the left tree. Similar for the right subtree. Another is that the data range of the node is -2^31-1 to 2^31<br>This may lead to the case that the left or right node equals to the INT_MAX or INT_MIN (which is the initial status and the status when there is null node). Therefore, we need to consider the case when there is one child and two children separately to make some edge cases work. Otherwise, when the node contains INT_MAX or INT_MIN, the comparision might fail, since we could not provide a boundry value that contains these two values for integrer.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxinit = INT_MAX;</span><br><span class="line">    <span class="type">int</span> mininit = INT_MIN;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(root, maxinit, mininit);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="type">int</span>&amp; minV, <span class="type">int</span>&amp;maxV)</span></span>&#123;</span><br><span class="line">        <span class="comment">//null node</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//leaf node</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            maxV = root-&gt;val;</span><br><span class="line">            minV = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//one child node</span></span><br><span class="line">        <span class="type">int</span> lMinV= minV;</span><br><span class="line">        <span class="type">int</span> lMaxV= maxV;</span><br><span class="line">        <span class="type">bool</span> lbst = <span class="built_in">helper</span>(root-&gt;left, lMinV, lMaxV);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// keep update the max value of the left child tree</span></span><br><span class="line">        <span class="comment">//printf(&quot;l minV %d maxV %d &quot;,lMinV, lMaxV);</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(lbst &amp;&amp; lMaxV&gt;=root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(lbst==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="type">int</span> rMinV= minV;</span><br><span class="line">        <span class="type">int</span> rMaxV= maxV;</span><br><span class="line">        <span class="comment">// keep the min value of the right child tree</span></span><br><span class="line">        <span class="comment">// the minV here is influenced</span></span><br><span class="line">        <span class="type">bool</span> rbst = <span class="built_in">helper</span>(root-&gt;right, rMinV, rMaxV);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rbst&amp;&amp;rMinV&lt;=root-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rbst==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="comment">// two children case</span></span><br><span class="line">        maxV = <span class="built_in">max</span>(maxV,<span class="built_in">max</span>(rMaxV, root-&gt;val));</span><br><span class="line">        minV = <span class="built_in">min</span>(minV,<span class="built_in">min</span>(lMinV, root-&gt;val));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>We can also set the boundry value at the long long int to simplify the code, but we need to transfer the root value into the long long type when doing the comparison:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> maxinit = LLONG_MAX;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> mininit = LLONG_MIN;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">help</span>(root, maxinit, mininit);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">help</span><span class="params">(TreeNode* root, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&amp; minV, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&amp;maxV)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            maxV = root-&gt;val;</span><br><span class="line">            minV = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> lMinV= minV;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> lMaxV= maxV;</span><br><span class="line">        <span class="comment">// all nullptr, return true</span></span><br><span class="line">        <span class="type">bool</span> lbst = <span class="built_in">help</span>(root-&gt;left, lMinV, lMaxV);</span><br><span class="line">        <span class="keyword">if</span>(!lbst) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rMinV= minV;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rMaxV= maxV;</span><br><span class="line">        <span class="comment">// keep the min value of the right child tree</span></span><br><span class="line">        <span class="comment">// the minV here is influenced</span></span><br><span class="line">        <span class="type">bool</span> rbst = <span class="built_in">help</span>(root-&gt;right, rMinV, rMaxV);</span><br><span class="line">        <span class="keyword">if</span>(!rbst) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//current </span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;=lMaxV || root-&gt;val&gt;=rMinV)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        maxV = <span class="built_in">max</span>(rMaxV, (<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)root-&gt;val);</span><br><span class="line">        minV = <span class="built_in">min</span>(lMinV, (<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Another idea is from the top to down, actually the code is more simpler in this case, we start from the root node and then narrow down the range of the child gradually, we set the vmin and vmax as the long int to make sure the results also correct when node equals to the INT_MIN or INT_MAX.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(root, LLONG_MIN, LLONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="type">long</span> <span class="type">int</span> vmin, <span class="type">long</span> <span class="type">int</span> vmax)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt;= vmin || root-&gt;val&gt;= vmax)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> lvalid = <span class="built_in">helper</span>(root-&gt;left, vmin, root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(lvalid==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> rvalid = <span class="built_in">helper</span>(root-&gt;right, root-&gt;val, vmax);</span><br><span class="line">        <span class="keyword">if</span>(rvalid==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="Tree-properties-path-path-sum-nodes"><a href="#Tree-properties-path-path-sum-nodes" class="headerlink" title="Tree properties (path, path sum, nodes)"></a>Tree properties (path, path sum, nodes)</h3><p>111 check the minimum depth. It also use the similar strategy. Check the min depth of the left and right part, and then return the min of the left and right value plus one. Be careful for processing the null node. Since we just return 0 direactly. When we compare the return value, this node is not accounted into the depth of the tree. For the test case such as <code>[2,null,3,null,4,null,5,null,6]</code>, the return value is 5. When we check the min value, we do not consider the return value with the 0. Since the leaf node is the node with no children. Which should return 1 at least.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 111 Minimum Depth of Binary Tree</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> mindepth = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//ldepth</span></span><br><span class="line">        <span class="type">int</span> ldepth =  <span class="built_in">helper</span>(root-&gt;left);     </span><br><span class="line">        <span class="comment">//rdpeth</span></span><br><span class="line">        <span class="type">int</span> rdepth=<span class="built_in">helper</span>(root-&gt;right);     </span><br><span class="line">        <span class="comment">//current depth</span></span><br><span class="line">        <span class="type">int</span> currdepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ldepth==<span class="number">0</span> &amp;&amp; rdepth !=<span class="number">0</span>)&#123;</span><br><span class="line">            currdepth = rdepth+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (rdepth==<span class="number">0</span> &amp;&amp; ldepth!=<span class="number">0</span>)&#123;</span><br><span class="line">            currdepth = ldepth+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            currdepth = <span class="built_in">min</span> (ldepth, rdepth)+<span class="number">1</span>;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currdepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>112.Path Sum, using the NLR to traverse the tree and decrease the target sum each time going to the next level. Only return true at the case where node is the leaf node and satisfies the targeted. Using the idea from the up to bottom is more natural for this one. The idea of considering things in sequence and in a complete way is important, the null node, the leaf node and the non-leaf node. </p>
<p>Actually, the good practice here is to consider the edge case firstly, since we can return it direactly and to not do the subsequent checking, then the remaning logic is the general case. So, the good practice for the recursion operation is to write the return entry firstly and then check the recursion part, but when we thinking it, we may consider the recursion part firstly and then the return part.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//visit current node</span></span><br><span class="line">        <span class="comment">//if leaf</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(targetSum==root-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check left and right</span></span><br><span class="line">        <span class="type">bool</span> left = <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum-root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(left)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> right = <span class="built_in">hasPathSum</span>(root-&gt;right, targetSum-root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>129 Sum Root to Leaf Numbers is a similar question of 112, just times 10 when visiting the leaf node when adding the new path.</p>
<p>113 is the updated version of the 112, it requires to memory the specific path that satisfies the requirments, it is a typical search problem (both the start and the end of the search path is clear). This idea and associated code can be the framework for many more complicated problem.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//113 Path Sum II</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; m_ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        <span class="built_in">helper</span>(root, targetSum, &#123;&#125;);</span><br><span class="line">        <span class="keyword">return</span> m_ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum, vector&lt;<span class="type">int</span>&gt; currpath)</span></span>&#123;</span><br><span class="line">        <span class="comment">//null node</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//leaf node</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            currpath.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="comment">//put temp to ans if satisfies requrements</span></span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val == targetSum)&#123;</span><br><span class="line">                m_ans.<span class="built_in">push_back</span>(currpath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//non-leaf node</span></span><br><span class="line">        <span class="comment">//update current path</span></span><br><span class="line">        <span class="comment">//search sub tree</span></span><br><span class="line">        currpath.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;left, targetSum-root-&gt;val, currpath);</span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;right, targetSum-root-&gt;val, currpath);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>437(tricky) This is the updated version of the path sum. Compared with the previous one, the started position is not clear, the end of the path is also not clear.</p>
<p>special cases</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,null,2,null,3,null,4,null,5]</span><br><span class="line">3</span><br><span class="line">[1,-2,-3,1,3,-2,null,-1]</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>solution1, use naive recursion, there might be time limit exceeded issue (did not realize the issue of the start and end point)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//version 1, error prone</span></span><br><span class="line"><span class="comment">//it requires to express the start point or end point clearly</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_pathNum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m_origianlTarget=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        m_origianlTarget = targetSum;</span><br><span class="line">        <span class="built_in">helper</span>(root, &#123;&#125;, targetSum, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> m_pathNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//runtime issue for this code</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; path, <span class="type">int</span> temptargetSum, <span class="type">bool</span> parentAdded, <span class="type">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                       </span><br><span class="line">        <span class="comment">//path does not contains root, use the origianl target</span></span><br><span class="line">        <span class="comment">//this should be considered firstly</span></span><br><span class="line">        <span class="comment">//this can be called multiple times potentially</span></span><br><span class="line">        <span class="comment">//first node, call this, otherwise, use the tempsum</span></span><br><span class="line">        <span class="keyword">if</span>(parentAdded==<span class="literal">false</span> || path.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//potentially start point</span></span><br><span class="line">            <span class="built_in">helper</span>(root-&gt;left, &#123;&#125;, m_origianlTarget, <span class="literal">false</span>, level+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">helper</span>(root-&gt;right, &#123;&#125;,m_origianlTarget, <span class="literal">false</span>, level+<span class="number">1</span>);          </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//path contains the current node</span></span><br><span class="line">        <span class="comment">//visit current</span></span><br><span class="line">        <span class="comment">//bool isend = false;</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == temptargetSum)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parentAdded==<span class="literal">true</span> || path.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//potentially end point</span></span><br><span class="line">                m_pathNum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//path contains root</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;left, path,temptargetSum-root-&gt;val, <span class="literal">true</span>, level+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;right, path,temptargetSum-root-&gt;val, <span class="literal">true</span>, level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The following code is the optimization of the version 1, the key point is to figure out if the current node is at the start position or at the following position, that is really important, use equals to 0 to decide the condition is more simplifier than the origianl case,we need to type fewer words in this case.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_pathNum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m_origianlTarget=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">long</span> <span class="type">long</span> targetSum)</span> </span>&#123;</span><br><span class="line">        m_origianlTarget = targetSum;</span><br><span class="line">        <span class="built_in">helper</span>(root, targetSum, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> m_pathNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//runtime issue for this code</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(TreeNode* root,<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> temptargetSum, <span class="type">bool</span> ifstart)</span></span>&#123;</span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//first node, call this, otherwise, use the tempsum</span></span><br><span class="line">        <span class="keyword">if</span>(ifstart)&#123;</span><br><span class="line">            <span class="comment">//start point</span></span><br><span class="line">            <span class="built_in">helper</span>(root-&gt;left, m_origianlTarget, <span class="literal">true</span>);</span><br><span class="line">            <span class="built_in">helper</span>(root-&gt;right, m_origianlTarget, <span class="literal">true</span>);          </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        temptargetSum-=root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(temptargetSum == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//for the end node, do not check the subsequent nodes</span></span><br><span class="line">            m_pathNum++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//path contains root, other nodes are followers</span></span><br><span class="line">        <span class="comment">//still check till the last one, the node can be negative</span></span><br><span class="line">        <span class="comment">//there value may conteract with each other</span></span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;left, temptargetSum, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;right, temptargetSum, <span class="literal">false</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This code is much more simple and refer to this <a target="_blank" rel="noopener" href="https://zxi.mytechroad.com/blog/tree/leetcode-437-path-sum-iii/">blog</a> , attention that for the first layer, the function name is the pathSum instead of the helper.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(root, targetSum)+<span class="built_in">pathSum</span>(root-&gt;left, targetSum)+<span class="built_in">pathSum</span>(root-&gt;right, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> tempsum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tempsum -= root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> (tempsum == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>)+<span class="built_in">helper</span>(root-&gt;left,tempsum)+<span class="built_in">helper</span>(root-&gt;right,tempsum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Lesson: one important idea is how to debug in recursion code: we might add the level into the print info, this can be an indicator and it can change the flattern code into the hierachy code and check the horizental and vertical. By doing this, we can find an error in our origianl code, at that time, we forget to add the condition when the path is just started. However, it is difficult to figure it out and understanding the code behaviours without the help of the debug info.</p>
<p>This code can be further optimized based on the 560 that computes the prefix sum. The single path in 560 changes to the multiple path on the tree for this question. Here is the optimization version for this question based on the idea of 560</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_pathNum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m_count = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt; <span class="type">long</span> <span class="type">int</span>, <span class="type">int</span>&gt; psum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root,  <span class="type">long</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//for the case when the element itsself equals to the targetSum</span></span><br><span class="line">        psum[<span class="number">0</span>]=<span class="number">1</span>; </span><br><span class="line">        <span class="built_in">helper</span>(root, targetSum, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> m_count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="type">long</span> <span class="type">int</span> targetSum,  <span class="type">long</span> currentSum)</span></span>&#123;</span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//visit current node</span></span><br><span class="line">        <span class="comment">//visit left and right from up to bottom</span></span><br><span class="line">        currentSum = currentSum+root-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> previousSum = currentSum - targetSum;</span><br><span class="line">        <span class="comment">//printf(&quot;previousSum %d &quot;, previousSum);</span></span><br><span class="line">        m_count = m_count+psum[previousSum];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//put current sum into the map</span></span><br><span class="line">        <span class="comment">//default value is 0 for empty element</span></span><br><span class="line">        psum[currentSum]++;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;left, targetSum, currentSum);</span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;right, targetSum, currentSum);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//this is a really important part from the single path sum to the tree based path sum</span></span><br><span class="line">        <span class="comment">//this is much smarter than copy the map between each recursion call</span></span><br><span class="line">        psum[currentSum]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The main part of visiting the node is same with the 560, main difference is that, remember to decrease specific elements from map after each call. Essentially, we need a different map for each path, but copy past map direactlly in each call is also time consuming, so we just adjust values in the map dynamically to make sure it works for different path.</p>
<p><strong>508. Most Frequent Subtree Sum</strong></p>
<p>The traversal part is common one, using the idea from the bottom to up, the subtree returns a particular value. The extra part is to use a map to keep track of the sum  during the tree traversal process. When the max freq is updated, we clear the ans, when freq of current sum equals to the max freq, we push the current sum, when the current sum is less than freq, we do nothing. (when there is tie means there are same frequent number for the two cases) </p>
<p>Start and the end of the path sum is comparatively clear in this question, which decrease its level of difficulty.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxFreq = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//key is sum value is freq</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; freMap;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findFrequentTreeSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">helper</span>(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//get left sum</span></span><br><span class="line">        <span class="type">int</span> leftSum = <span class="built_in">helper</span>(root-&gt;left, ans);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//get right sum</span></span><br><span class="line">        <span class="type">int</span> rightSum = <span class="built_in">helper</span>(root-&gt;right, ans);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//with the current sum</span></span><br><span class="line">        <span class="type">int</span> currSum = leftSum+rightSum+root-&gt;val;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//compute freq, if not exist, default is 0</span></span><br><span class="line">        <span class="type">int</span> currFreq = freMap[currSum]+<span class="number">1</span>;</span><br><span class="line">        freMap[currSum]=currFreq;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(maxFreq&lt;currFreq)&#123;</span><br><span class="line">            <span class="comment">//update the MaxFreq and ans</span></span><br><span class="line">            ans.<span class="built_in">clear</span>();</span><br><span class="line">            maxFreq = currFreq;</span><br><span class="line">            <span class="comment">// when equal, current freq is the maximum one update ans</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(currSum);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxFreq==currFreq)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(currSum);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//do nothing when large than current</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> currSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>124 Binary Tree Maximum Path Sum</strong></p>
<p>The setting of the question is not that much straightforward and the start and end point of the path is not certained. We could confirm the general framework of the question, and use the bottom to up method approach. The tricky part is to make sure the return value and how to visit the current node.</p>
<p>The key thinking perspective is considering if the current node is included in the path. The maximum path can be following several options: left sum path + root, right sum path + root, left sum path + root + right sum path, or just the root itself (this situation is easy to be forgottern), since the node value can be negative, all these situations can be the maximum case.</p>
<p>The return part is also tricky, we just return the max value among the left side, the right side and the node itsself. Instead of returing the current possible max path sum. Since we just needs the left path or right path of the subtree to construct the new path. Anyway, the code is straightforward and the answer might need some time to come up with. Since the minpath and the return value for each recurssion call are two different variables here.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxSum = INT_MIN;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">helper</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="comment">//left</span></span><br><span class="line">        <span class="type">int</span> lpsum = <span class="built_in">helper</span>(root-&gt;left);</span><br><span class="line">        <span class="comment">//right</span></span><br><span class="line">        <span class="type">int</span> rpsum = <span class="built_in">helper</span>(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//visit &amp; compare</span></span><br><span class="line">        <span class="type">int</span> lrsum = lpsum+root-&gt;val;</span><br><span class="line">        maxSum = <span class="built_in">max</span>(maxSum, lrsum);</span><br><span class="line">        <span class="type">int</span> rrsum = rpsum+root-&gt;val;</span><br><span class="line">        maxSum = <span class="built_in">max</span>(maxSum, rrsum);</span><br><span class="line">        <span class="type">int</span> lrrsum = lpsum+root-&gt;val+rpsum;</span><br><span class="line">        maxSum = <span class="built_in">max</span>(maxSum, lrrsum);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//single node without the child</span></span><br><span class="line">        <span class="comment">//may also be the largest one</span></span><br><span class="line">        maxSum = <span class="built_in">max</span>(maxSum, root-&gt;val);        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(lrsum, rrsum),root-&gt;val);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>543. Diameter of Binary Tree</strong></p>
<p>One similar question is the 543 which compute the diameter of the tree, these two questions use similar strategy and code framework. The 543 can be the foundataion of this question. The important point is that the helper function should not return the whole length, and it should return the max of left path or right path of the subtree. Another smart point is that they return -1 in their code when there is nullptr, which simplifies the expression from 2 layer node classification to 1 layer node classification. </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxpath=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">childp</span>(root,maxpath);</span><br><span class="line">        <span class="keyword">return</span> maxpath;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">childp</span><span class="params">(TreeNode* root, <span class="type">int</span>&amp; maxpath)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// when connect with the root, the path length should increase 1</span></span><br><span class="line">        <span class="type">int</span> lpath = <span class="built_in">childp</span>(root-&gt;left,maxpath)+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rpath = <span class="built_in">childp</span>(root-&gt;right,maxpath)+<span class="number">1</span>;</span><br><span class="line">        maxpath = <span class="built_in">max</span>(maxpath, lpath+rpath);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(lpath,rpath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>687. Longest Univalue Path</strong></p>
<p>The idea of this question is not diffecult, it is a little bit similar with previous several questions, the key part is consider every situation clearly</p>
<p>For the version1, we calssify the node by null, leave node, one child, two children case. Then in the two children case, we further consider the relationship between the root node and the child node.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxpath;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">lup</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxpath;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lup</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="comment">//root null</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//leaf node</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//at least one child</span></span><br><span class="line">        <span class="type">int</span> lpath = <span class="built_in">lup</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> rpath = <span class="built_in">lup</span>(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//one child case</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val == root-&gt;left-&gt;val)&#123;</span><br><span class="line">               lpath++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               lpath=<span class="number">0</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            maxpath=<span class="built_in">max</span>(maxpath,lpath);</span><br><span class="line">            <span class="keyword">return</span> lpath;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right &amp;&amp; root-&gt;left==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val == root-&gt;right-&gt;val)&#123;</span><br><span class="line">                rpath++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                rpath=<span class="number">0</span>;</span><br><span class="line">            &#125;     </span><br><span class="line">            maxpath=<span class="built_in">max</span>(maxpath,rpath);</span><br><span class="line">            <span class="keyword">return</span> rpath;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//two children case</span></span><br><span class="line">        <span class="comment">//both left and right exist</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//if root node not equals to both side</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val != root-&gt;left-&gt;val &amp;&amp; root-&gt;val != root-&gt;right-&gt;val)&#123;</span><br><span class="line">            maxpath=<span class="built_in">max</span>(maxpath,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//root node equals to both side        </span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == root-&gt;left-&gt;val&amp;&amp;root-&gt;val == root-&gt;right-&gt;val)&#123;</span><br><span class="line">            maxpath=<span class="built_in">max</span>(maxpath,lpath+<span class="number">1</span>+rpath+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(lpath+<span class="number">1</span>, rpath+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//if root node eqauls to one side</span></span><br><span class="line">        <span class="comment">//left side</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == root-&gt;left-&gt;val)&#123;</span><br><span class="line">            maxpath=<span class="built_in">max</span>(maxpath,lpath+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> lpath+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//rside</span></span><br><span class="line">        maxpath=<span class="built_in">max</span>(maxpath,rpath+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> rpath+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>For the case2, we kind of merge the situation where there is one children and two<br>children case. Since when wen want to decide the situation of two children, we need to first decide the case when there is one children.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxpath;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">lup</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxpath;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lup</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> lpath = <span class="built_in">lup</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> rpath = <span class="built_in">lup</span>(root-&gt;right);</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val == root-&gt;left-&gt;val)&#123;</span><br><span class="line">               lpath++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               lpath=<span class="number">0</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            maxpath=<span class="built_in">max</span>(maxpath,lpath);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val == root-&gt;right-&gt;val)&#123;</span><br><span class="line">                rpath++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                rpath=<span class="number">0</span>;</span><br><span class="line">            &#125;     </span><br><span class="line">            maxpath=<span class="built_in">max</span>(maxpath,rpath);</span><br><span class="line">            <span class="comment">//consider the case that root equals to child</span></span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left&amp;&amp;root-&gt;val == root-&gt;left-&gt;val&amp;&amp;root-&gt;val == root-&gt;right-&gt;val)&#123;</span><br><span class="line">                maxpath=<span class="built_in">max</span>(maxpath,lpath+rpath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(lpath,rpath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>236(235). Lowest Common Ancestor of a Binary Tree</strong></p>
<p>The naive solution is to use the idea based on the 257 which can remember the path of the tree traverse based on the dfs. When the node comes to the p, remember the path. When the node comdes to the q, remember the path. Then compare two path to find the last one that  is same with each other. This node is the LCA node. For this solution, remember that we can not guarantee the sequence to find the p or q, it is possible to find p first or find the q first.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;TreeNode*&gt; m_pathp;</span><br><span class="line">    vector&lt;TreeNode*&gt; m_pathq;</span><br><span class="line">    vector&lt;TreeNode*&gt; m_currpath;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> findp = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> findq = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">helper</span>(root, p, q, findp, findq);</span><br><span class="line">        <span class="comment">//fill int the m_pathp and m_pathq</span></span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">min</span>(m_pathp.<span class="built_in">size</span>(), m_pathq.<span class="built_in">size</span>());</span><br><span class="line">        TreeNode* temp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//the unique value must exist</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d &quot;</span>, m_pathp[i]-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(m_pathp[i]-&gt;val!=m_pathq[i]-&gt;val)&#123;</span><br><span class="line">                <span class="comment">//find the first different node on the path</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=m_pathp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//the first one can be either p or q</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q, <span class="type">bool</span>&amp; findp, <span class="type">bool</span>&amp; findq)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(findp == <span class="literal">true</span> &amp;&amp; findq == <span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//visit node in path</span></span><br><span class="line">        m_currpath.<span class="built_in">push_back</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//when node comes to p</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==p-&gt;val)&#123;</span><br><span class="line">            <span class="comment">//find p</span></span><br><span class="line">            <span class="comment">//snapshot path</span></span><br><span class="line">            m_pathp = m_currpath;</span><br><span class="line">            findp = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//when node comes to q</span></span><br><span class="line">        <span class="comment">//compare with previous path</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==q-&gt;val)&#123;</span><br><span class="line">            <span class="comment">//find q</span></span><br><span class="line">            <span class="comment">//find the correct path</span></span><br><span class="line">            m_pathq = m_currpath;</span><br><span class="line">            findq = <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//left and right</span></span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;left, p, q, findp, findq);</span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;right, p, q, findp, findq);</span><br><span class="line">        <span class="comment">//remove last element</span></span><br><span class="line">        m_currpath.<span class="built_in">pop_back</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This is another solution for this question. It use the idea that combines both top to down and bottom to up, it uses both current value and the value of lchild or rchild to decide the least common node in the tree. This method can avoid some unnecessary recursion operations.</p>
<p>It can decrease some search path depending the position of p and q. Consider the three node, current node (c), p and q. There are several possibilities about their positions:</p>
<p>a)p and q are not at the subtree of the c, return null in this case.<br>b)p and q are at the left subtree and right subtree respectively, return c in this case.<br>c)p and q are at one subtree of the c.</p>
<p>There are two further situations for the case c), the first one is that the c equals to p or q, return the c direactly in this case. Another situation is that the c not equals to p or q, in this case, return the lchild or rchild that is not null.</p>
<p>Here is a good explanation for this question (<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=KobQcxdaZKY">https://www.youtube.com/watch?v=KobQcxdaZKY</a>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//check current node</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">//for processing the edge case</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//current is p or q, return direactly</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//lchild</span></span><br><span class="line">        TreeNode* lchild = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        <span class="comment">//rchild</span></span><br><span class="line">        TreeNode* rchild = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if both of them is null</span></span><br><span class="line">        <span class="keyword">if</span>(lchild == <span class="literal">nullptr</span> &amp;&amp; rchild ==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">// not contain p q in subtree</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//if both of them is not null</span></span><br><span class="line">        <span class="keyword">if</span>(lchild &amp;&amp; rchild)&#123;</span><br><span class="line">            <span class="comment">//current is the lsc</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//if one of them is null, return the specific one</span></span><br><span class="line">        <span class="comment">//use conditional operator if we must return sth</span></span><br><span class="line">        <span class="keyword">return</span> lchild==<span class="literal">nullptr</span>?rchild:lchild;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>968. Binary Tree Cameras</strong></p>
<p>It looks like a dp problem, since for each step, we can choose place camera or not</p>
<p>There is one answer looks a little bit complicated, but we considered things in a systamaticall way. Nameyly, null node, one child case and two children case. The status transfer between the two levels of the tree is important for solving the problem. </p>
<p>One tricky part is that when both left and right is the no camera but covered status, we have two options for the current node, either put camera here or weight for its parent. It looks that the dp approach is more general soluation. By analyzing this problem we can find that iftop is true, we prefer to put camera, other wise, we wait for the upper level node to put the camera.</p>
<p>I still did not figure out the how to compress the one child case, some code returns the camera monitored status when the node is null.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from top to down not right, for the case that medium node is monitored, we added more node</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">STATUS</span> &#123;CM = <span class="number">0</span>, NCM = <span class="number">1</span>, NCNM=<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//root is null</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//only one layer</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//at least two layers</span></span><br><span class="line">        <span class="built_in">helper</span>(root, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//when it is not at the top position, we can always postpone the choice</span></span><br><span class="line">    <span class="function">STATUS <span class="title">helper</span><span class="params">(TreeNode* root, <span class="type">bool</span> iftop)</span></span>&#123;</span><br><span class="line">        <span class="comment">//leaf node</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right ==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> STATUS::NCNM;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// check left status</span></span><br><span class="line">        STATUS lstatus;</span><br><span class="line">        STATUS rstatus;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">             lstatus = <span class="built_in">helper</span>(root-&gt;left, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">             rstatus = <span class="built_in">helper</span>(root-&gt;right,<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// left child</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">//check the right part</span></span><br><span class="line">            <span class="keyword">if</span>(rstatus == STATUS::NCNM)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">return</span> STATUS::CM;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rstatus == STATUS::NCM)&#123;</span><br><span class="line">                <span class="keyword">if</span>(iftop)&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">return</span> STATUS::CM;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> STATUS::NCNM;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> STATUS::NCM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">//check lstatus</span></span><br><span class="line">            <span class="keyword">if</span>(lstatus == STATUS::NCNM)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">return</span> STATUS::CM;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lstatus == STATUS::NCM)&#123;</span><br><span class="line">                <span class="keyword">if</span>(iftop)&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">return</span> STATUS::CM;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> STATUS::NCNM;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> STATUS::NCM;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// two children</span></span><br><span class="line">        <span class="keyword">if</span>(lstatus == STATUS::NCM &amp;&amp; rstatus == STATUS::NCM)&#123;</span><br><span class="line">            <span class="comment">//there are two options when both children are ncamera covered</span></span><br><span class="line">            <span class="keyword">if</span>(iftop)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">return</span> STATUS::CM;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> STATUS::NCNM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(lstatus == STATUS::NCNM || rstatus == STATUS::NCNM)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span> STATUS::CM;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//other cases</span></span><br><span class="line">        <span class="keyword">return</span> STATUS::NCM;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>After simplifying the code and assume the null node is the dummy node with the status NCM, we can get this simple code, although the code is simple, but the logical process to create this code is not simple, we need to consider all 3*3 possibilities and compress them into the simplified form as follows:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">STATUS</span> &#123;CM = <span class="number">0</span>, NCM = <span class="number">1</span>, NCNM=<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//root is null</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//at least two layers</span></span><br><span class="line">        <span class="built_in">helper</span>(root, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//when it is not at the top position, we can always postpone the choice</span></span><br><span class="line">    <span class="function">STATUS <span class="title">helper</span><span class="params">(TreeNode* root, <span class="type">bool</span> iftop)</span></span>&#123;</span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> STATUS::NCM;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        STATUS lstatus = <span class="built_in">helper</span>(root-&gt;left,  <span class="literal">false</span>);</span><br><span class="line">        STATUS rstatus = <span class="built_in">helper</span>(root-&gt;right, <span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// two children, the null node can be viewed as a dummy child</span></span><br><span class="line">        <span class="keyword">if</span>(lstatus == STATUS::NCM &amp;&amp; rstatus == STATUS::NCM)&#123;</span><br><span class="line">            <span class="comment">//there are two options when both children are ncamera covered</span></span><br><span class="line">            <span class="keyword">if</span>(iftop)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">return</span> STATUS::CM;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> STATUS::NCNM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(lstatus == STATUS::NCNM || rstatus == STATUS::NCNM)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span> STATUS::CM;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//other cases</span></span><br><span class="line">        <span class="keyword">return</span> STATUS::NCM;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>979. Distribute Coins in Binary Tree</strong></p>
<p>The code is easy, but the thinking perspective is important and it is not easy to get that point. We use the bottom to up method during the search, the return value for each layer represents how many coins is needed to make the current node and its subtree to satisfy the constraints (this idea is the key for solving the problem). For the simple case, such as the leaf node, the return value of the subtree is 0, they do not need extra coin move. For the case [3,0,0], at the node with value of 3, the return value of the left and right subtree is -1, we need move 1 conin to them. Then in order to make the node with value 3 become case that satisfies the requirements, we need to move 3-1 &#x3D; 2. Adding this value with two return results, they become 2-1-1&#x3D;0, so we do not need extra move. When we compute the move count, we use the abs value, no matter we move from current node or move to the current node, the move count through the edge should add one.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> moveNum=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distributeCoins</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">help</span>(root);</span><br><span class="line">        <span class="keyword">return</span> moveNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">help</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//need how many coins</span></span><br><span class="line">        <span class="comment">//the l and r can be balanced</span></span><br><span class="line">        <span class="type">int</span> lcc=<span class="built_in">help</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> rcc=<span class="built_in">help</span>(root-&gt;right);</span><br><span class="line">        <span class="comment">//if the nullptr is not 1, we need to consider more cases here</span></span><br><span class="line">        <span class="comment">//move one coin each time</span></span><br><span class="line">        moveNum = moveNum+<span class="built_in">abs</span>(lcc)+<span class="built_in">abs</span>(rcc);</span><br><span class="line">        <span class="type">int</span> currentNeed = lcc+rcc+(root-&gt;val<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> currentNeed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>530 and 700 are similar questions that use the bst tree. 501 is also a similar one, the idea of updating the most frequent elements and associated length is inspiring. We consider three exclusive cases when checking the current node.</p>
<p>One tricky case is sth like [1,null, 2,2] do not update the recorded value based on the principle such as if current elem eqauls to the previous one. Since we do not know if there are more subsequent elements. For each step, we assume it is the last element.</p>
<p>When there is [1,null, 2] the ans vector contains 1 and 2, then move to the next, update the count, then clear the ans, then push 2 again. The key point here is we actually push the element 2 into the vector twice. </p>
<p><strong>501. Find Mode in Binary Search Tree</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="type">int</span> recordLongest=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// the continuous value before visiting current node</span></span><br><span class="line">    <span class="type">int</span> tempk=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tempprev=INT_MIN;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;        </span><br><span class="line">        <span class="comment">//go through LNR</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;        </span><br><span class="line">        <span class="comment">//init values</span></span><br><span class="line">        <span class="built_in">help</span>(root,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;      </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">help</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// go through left</span></span><br><span class="line">        <span class="built_in">help</span>(root-&gt;left, ans);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val!=tempprev)&#123;</span><br><span class="line">            tempk=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tempk++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(tempk&gt;recordLongest)&#123;</span><br><span class="line">            ans.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="comment">//printf(&quot;tempk %d push %d &quot;, tempk, root-&gt;val);</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            recordLongest=tempk;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tempk==recordLongest)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//do nothing when the tempk&lt;recordLongest</span></span><br><span class="line">        &#125;</span><br><span class="line">        tempprev = root-&gt;val; </span><br><span class="line">        <span class="comment">// go through right</span></span><br><span class="line">        <span class="built_in">help</span>(root-&gt;right, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>230. Kth Smallest Element in a BST</strong></p>
<p>This is the updated version of the 700, the LNR traverse is important, in BST, the LNR is the sorted ascending sequence, therefore, we can confirm the position of the kth smallest elements conveniently by gradually decreasing its value.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">help</span>(root,k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">help</span><span class="params">(TreeNode* root, <span class="type">int</span>&amp; k)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//in order l n r</span></span><br><span class="line">        <span class="comment">//check left</span></span><br><span class="line">        <span class="built_in">help</span>(root-&gt;left, k);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check central   </span></span><br><span class="line">        <span class="comment">//check k and decrease?</span></span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">            ans = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check right</span></span><br><span class="line">        <span class="built_in">help</span>(root-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Modifing-tree-structure"><a href="#Modifing-tree-structure" class="headerlink" title="Modifing tree structure"></a>Modifing tree structure</h3><p><strong>814. Binary Tree Pruning</strong></p>
<p>Pruning the subtree with a particular properties. The common strategy is from bottom to up and let every subtree satisfies the requirments firstly. Be careful of the condition. If current node contains 0, and one of the child exist, it means that one of the subtree contains the 1, the current node and subtree satisfies the condition and should not be removed. <em><strong>The idea from bottom to up to reconstruct the whole tree is crutial for the problem that need to modify the tree structure.</strong></em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">TreeNode* <span class="title">pruneTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//the left subtree is already cleaned</span></span><br><span class="line">    <span class="comment">//it contains 1 if the left is not nullptr</span></span><br><span class="line">    root-&gt;left = <span class="built_in">pruneTree</span>(root-&gt;left);</span><br><span class="line">    <span class="comment">//the right part is already clearned</span></span><br><span class="line">    <span class="comment">//it contains the 1 if right is nullptr</span></span><br><span class="line">    root-&gt;right = <span class="built_in">pruneTree</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">//visit current node</span></span><br><span class="line">    <span class="comment">//if the subtree contains 1</span></span><br><span class="line">    <span class="comment">//keep it, otherwise, delete whole tree</span></span><br><span class="line">    <span class="comment">//or one of left or right exist, which means the subtree</span></span><br><span class="line">    <span class="comment">//contains the 1</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == <span class="number">1</span> || root-&gt;left || root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//delete current node</span></span><br><span class="line">    <span class="comment">//also delete left and right</span></span><br><span class="line">    <span class="comment">//this function is unnecessary for result correctness</span></span><br><span class="line">    <span class="built_in">removeTree</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">removeTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//remove left</span></span><br><span class="line">      <span class="built_in">removeTree</span>(root-&gt;left);</span><br><span class="line">      <span class="comment">//remove right</span></span><br><span class="line">      <span class="built_in">removeTree</span>(root-&gt;right);</span><br><span class="line">      <span class="comment">//remove current</span></span><br><span class="line">      <span class="keyword">delete</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>More complicated trim operation, we need to adjust tree structure</strong></p>
<p>The key strategy here is to consider the type of the node during the removal operation, if the removed node is leaf node or the node with one child or the node with two childern, etc. The code is more clear if considering things in this way.</p>
<p><strong>669. Trim a Binary Search Tree</strong></p>
<p>The operation is simple, just delete a node and adjust the tree structure. Be careful for the case discussion when we detected that the node should be removed.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">findLeftNode</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//if there is left node, move to the left</span></span><br><span class="line">        <span class="keyword">while</span>(root-&gt;left)&#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//left</span></span><br><span class="line">        TreeNode* lchild = <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">        <span class="comment">//right</span></span><br><span class="line">        TreeNode* rchild = <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//visit current</span></span><br><span class="line">        <span class="comment">//if the node need to be deleted</span></span><br><span class="line">        <span class="comment">//supposed to return if it is removed</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;low || root-&gt;val&gt;high)&#123;</span><br><span class="line">            <span class="comment">//remove node, there is bug for some case such as [1, null, 2] 2, 4</span></span><br><span class="line">            <span class="comment">//when add this, not sure the reason</span></span><br><span class="line">            <span class="comment">//delete root;</span></span><br><span class="line">            <span class="comment">//leaf</span></span><br><span class="line">            <span class="keyword">if</span>(lchild==<span class="literal">nullptr</span> &amp;&amp; rchild==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lchild || rchild)&#123;</span><br><span class="line">                <span class="comment">//one child</span></span><br><span class="line">                <span class="keyword">if</span>(lchild) <span class="keyword">return</span> lchild;</span><br><span class="line">                <span class="keyword">if</span>(rchild) <span class="keyword">return</span> rchild;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//two children</span></span><br><span class="line">                <span class="comment">//the left tree should be the</span></span><br><span class="line">                <span class="comment">//left side of the right tree</span></span><br><span class="line">                TreeNode* leftNode = <span class="built_in">findLeftNode</span>(rchild);</span><br><span class="line">                leftNode-&gt;left = lchild;</span><br><span class="line">                <span class="keyword">return</span> rchild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//current root satisfy condition</span></span><br><span class="line">        <span class="comment">//update left and right</span></span><br><span class="line">        root-&gt;left = lchild;</span><br><span class="line">        root-&gt;right= rchild;</span><br><span class="line">        <span class="keyword">return</span> root;            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Actually, this code can be further improved and we can notice that the case when there are two children if actaully not exist.</p>
<p>For example, if the current node value is c and it does not blongs to the [L,R], if c&lt;L, all the nodes in left of the c &lt; c &lt; L, so all of these nodes should be removed till the current step. Similarly, when the c&gt;R, all the right side nodes of the c &gt; c &gt; R, so the right side subtree should be removed before hand. This fact shows that there only exist two cases for the current recursion step, either c is the leaf node or have one side subtree.</p>
<p>1325 is a similar question, the constrains of removed node is more simple in this question.</p>
<p><strong>450. Delete Node in a BST</strong></p>
<p>The code framework and main considerations for this problem are similar with the previous one. Reuse the existing operation to deleted the selected node for the two children case is a smart point.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">help</span>(root, key, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">findMax</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">help</span><span class="params">(TreeNode* root, <span class="type">int</span> key, TreeNode*parent)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// edge case</span></span><br><span class="line">        <span class="comment">//root is nullptr</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//find targeted node</span></span><br><span class="line">        <span class="keyword">if</span>(key&lt; root-&gt;val)&#123;</span><br><span class="line">            <span class="built_in">help</span>(root-&gt;left, key, root);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; root-&gt;val)&#123;</span><br><span class="line">            <span class="built_in">help</span>(root-&gt;right, key, root);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">//case1 node is leaf node</span></span><br><span class="line">            <span class="keyword">if</span>(parent==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">//[1] 1 </span></span><br><span class="line">                <span class="built_in">delete</span>(root);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;val &gt; parent-&gt;val)&#123;</span><br><span class="line">                    <span class="comment">//rchild</span></span><br><span class="line">                    parent-&gt;right= <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    parent-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">delete</span>(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> || root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">//case2 one child</span></span><br><span class="line">            <span class="keyword">if</span>(parent==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">                    <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">delete</span>(root);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;val&gt;parent-&gt;val)&#123;</span><br><span class="line">                    <span class="comment">//reset the right pointer</span></span><br><span class="line">                    <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">                        parent-&gt;right=root-&gt;right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">                        parent-&gt;right=root-&gt;left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">delete</span>(root);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">                        parent-&gt;left=root-&gt;right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">                        parent-&gt;left=root-&gt;left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">delete</span>(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//case3 two children            </span></span><br><span class="line">            TreeNode* leftMaxNode = <span class="built_in">findMax</span>(root-&gt;left);</span><br><span class="line">            <span class="type">int</span> leftMaxValue = leftMaxNode-&gt;val;</span><br><span class="line">            <span class="built_in">help</span>(root-&gt;left, leftMaxValue, root);</span><br><span class="line">            root-&gt;val = leftMaxValue;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>701. Insert into a Binary Search Tree</strong></p>
<p>Using the bottom to up method and return the root of the sub tree after the modification.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> inserted=<span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//return the modifed tree structure</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//the situation to create new node and insert</span></span><br><span class="line">        <span class="comment">//return the root</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            TreeNode* nodenew = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            inserted = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> nodenew;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(inserted)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//val &gt; current</span></span><br><span class="line">        <span class="keyword">if</span>(val&lt;=root-&gt;val)&#123;</span><br><span class="line">            TreeNode* lroot = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">            root-&gt;left=lroot;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//val &lt; current</span></span><br><span class="line">        <span class="keyword">if</span>(val&gt;root-&gt;val)&#123;</span><br><span class="line">            TreeNode* rroot = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">            root-&gt;right=rroot;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>99. Recover Binary Search Tree</strong></p>
<p>This question utilizes two facts. The first is that when there is ascending sequence, there is LNR operation. Another fact is that in the ascending sequence, if we change two numbers, by checking all the elements, if there is one situation with a1&gt;a2, we know that we switch the adjacent numbers. When there are two these cases, we can make sure that these two numbers are not at the adjacent positions.</p>
<p>If we do not use the fact of LNR and ascending sequence, there is C(n,2) possibilities for two numbers, this is a huge searching space.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* node1=<span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* node2=<span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//search two points</span></span><br><span class="line">        <span class="built_in">help</span>(root);</span><br><span class="line">        <span class="comment">//the node1 and node2 should not be empty till this step</span></span><br><span class="line">        <span class="comment">//swap two points</span></span><br><span class="line">        <span class="comment">//only swap the value, keep the tree structure</span></span><br><span class="line">        <span class="built_in">swap</span>(node1-&gt;val, node2-&gt;val);</span><br><span class="line">        <span class="keyword">return</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//LNR find the two that does not satisfy the ascending sequence</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">help</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//left </span></span><br><span class="line">        <span class="built_in">help</span>(root-&gt;left);</span><br><span class="line">        <span class="comment">//central </span></span><br><span class="line">        <span class="keyword">if</span>(prev!=<span class="literal">nullptr</span> &amp;&amp; prev-&gt;val&gt;root-&gt;val)&#123;</span><br><span class="line">            <span class="comment">//assume there are only two error node</span></span><br><span class="line">            <span class="comment">//first one, prev position is error</span></span><br><span class="line">            <span class="comment">//second one current position is error</span></span><br><span class="line">            <span class="keyword">if</span>(node1==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">//printf(&quot;update node1, node1 %d node2 %d &quot;, node1, node2);</span></span><br><span class="line">                node1=prev;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//if there is only one diff case</span></span><br><span class="line">            <span class="comment">//two nodes are adjacent with each other</span></span><br><span class="line">            node2=root;                 </span><br><span class="line">        &#125;</span><br><span class="line">        prev=root;</span><br><span class="line">        <span class="comment">//right</span></span><br><span class="line">        <span class="built_in">help</span>(root-&gt;right);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>108. Convert Sorted Array to Binary Search Tree</strong></p>
<p>This is bascially the process of reconstructing the bst tree. The bst property simplifies the code a lot. More complex one is the case that decerilize from a random case, check the 297.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(nums, <span class="number">0</span>, len<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> lindex, <span class="type">int</span> rindex)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(lindex&gt;rindex)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//compute curr</span></span><br><span class="line">        <span class="type">int</span> currindex = (lindex+rindex)/<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//current</span></span><br><span class="line">        TreeNode* curr = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[currindex]);</span><br><span class="line">        <span class="comment">//build left</span></span><br><span class="line">        TreeNode* lroot = <span class="built_in">build</span>(nums, lindex, currindex<span class="number">-1</span>);   </span><br><span class="line">        <span class="comment">//build right</span></span><br><span class="line">        TreeNode* rroot = <span class="built_in">build</span>(nums, currindex+<span class="number">1</span>, rindex);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        curr-&gt;left = lroot;</span><br><span class="line">        curr-&gt;right= rroot;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> curr;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Tree-others"><a href="#Tree-others" class="headerlink" title="Tree + others"></a>Tree + others</h3><p>This type of questions use both the techniques used in tree and array (maybe map) to solve the problem. The key step here is to make sure what is the decision tree. In this blog, we only show some typical questions, such as serilization and using the map to do the accelaration. More general question that use the decision tree to do the search can be found in another article.</p>
<h4 id="tree-string-serilization"><a href="#tree-string-serilization" class="headerlink" title="tree+string (serilization)"></a>tree+string (serilization)</h4><p>The input of the function is a string in this type of question. And it may potentially use the tree structure to derive the property of the tree structure. The difficult part is how to map the string structure into the tree structure. That is way these questions looks tricky firstly, we should first try to transform it into a tree type problem logically.</p>
<p><strong>297 Serialize and Deserialize Binary Tree</strong></p>
<p>The idea of this question is not complecated, but it is really error-prone. We use the layered traversal here based on the queue, be careful about the condition that when there is the mix of the nullptr node and the actual solide node. This is a little bit different with the level order question such as 429, since the null node also need to be considered if current level contains both empty and solid node</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="comment">// the origianl way use the layer approach</span></span><br><span class="line">    <span class="comment">// it is also possible to use other approach</span></span><br><span class="line">    <span class="comment">// if using the NLR</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="comment">//nullnode       </span></span><br><span class="line">        <span class="type">int</span> levelSize = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//label if the next layer contains the solide node</span></span><br><span class="line">        <span class="comment">//if the next layer contains no solid node, return true</span></span><br><span class="line">        <span class="type">bool</span> nextcontainSolid = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">empty</span>()==<span class="literal">false</span> &amp;&amp; nextcontainSolid)&#123;</span><br><span class="line">            nextcontainSolid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(levelSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                levelSize--;</span><br><span class="line">                TreeNode *temp = q.<span class="built_in">front</span>();            </span><br><span class="line">                <span class="comment">//visit node</span></span><br><span class="line">                <span class="keyword">if</span>(temp!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    str+=<span class="built_in">to_string</span>(temp-&gt;val)+<span class="string">&quot;,&quot;</span>;    </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    str+=<span class="string">&quot;#,&quot;</span>;</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                    nextcontainSolid = <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="literal">nullptr</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">                    nextcontainSolid = <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="literal">nullptr</span>); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            levelSize = q.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//printf(&quot;%s&quot;, str.c_str());</span></span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// reconstruct based on the layered structure</span></span><br><span class="line">        <span class="keyword">if</span>(data==<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// split the str based on , </span></span><br><span class="line">        string delimiter = <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        <span class="type">int</span> delimLength = delimiter.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> posStart=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> posEnd=<span class="number">0</span>;</span><br><span class="line">        TreeNode* root = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* parent = <span class="literal">nullptr</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((posEnd = data.<span class="built_in">find</span>(delimiter,posStart)) != string::npos) &#123;</span><br><span class="line">            string token = data.<span class="built_in">substr</span>(posStart, posEnd-posStart);</span><br><span class="line">            <span class="comment">//check the element </span></span><br><span class="line">            <span class="comment">//printf(&quot;&lt;%s&gt;&quot;, token.c_str());</span></span><br><span class="line">            <span class="comment">//constructure by layered way</span></span><br><span class="line">            <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">//the first element</span></span><br><span class="line">                root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(token));</span><br><span class="line">                q.<span class="built_in">push</span>(root);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(index%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//update the parent</span></span><br><span class="line">                    <span class="comment">//when the current left and right are built ok</span></span><br><span class="line">                    parent = q.<span class="built_in">front</span>();</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// construct node</span></span><br><span class="line">                <span class="comment">// the parent is root for the first case</span></span><br><span class="line">                TreeNode* current=<span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">if</span>(token!=<span class="string">&quot;#&quot;</span>)&#123;</span><br><span class="line">                    current = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(token));</span><br><span class="line">                    <span class="comment">//printf(&quot;curr %d parr %d &quot;, current-&gt;val, parent-&gt;val);</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// left or right separately</span></span><br><span class="line">                <span class="keyword">if</span>(index%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    parent-&gt;left = current;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    parent-&gt;right = current;</span><br><span class="line">                &#125;                </span><br><span class="line">                </span><br><span class="line">                <span class="comment">// node is not null</span></span><br><span class="line">                <span class="comment">// push node into the queue</span></span><br><span class="line">                <span class="keyword">if</span>(current!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(current);</span><br><span class="line">                &#125;                </span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            posStart=posEnd+delimLength;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The similar one is the 449, we can also use the similar level traversal techniques.  Is there more efficient techniques for the bst structure?</p>
<h3 id="Tire-tree-or-dict-tree-for-accelaration"><a href="#Tire-tree-or-dict-tree-for-accelaration" class="headerlink" title="Tire tree or dict tree for accelaration"></a>Tire tree or dict tree for accelaration</h3><p>The 212 is a good exmaple, we need to do the similar search operations for multiple times, it can save time if we first trasfer the original structure into a tired tree for accelarating searching process to avoid the redouantant searching. The idea is to extract the common part of the tree. Look at more details for the details in the search part.</p>
<h4 id="tree-map-or-dp-using-map-to-optimize-the-code"><a href="#tree-map-or-dp-using-map-to-optimize-the-code" class="headerlink" title="tree+map or dp (using map to optimize the code)"></a>tree+map or dp (using map to optimize the code)</h4><p>Some complex path sum questions may use the map, such as the 437. The main idead that uses the map is to improve the performance of the searching. </p>
<p><strong>337. House Robber III</strong></p>
<p>This one is inspiring. There is some intersection between the traditional tree based strategy such as top to bottom or bottom to up with the thinking perspective of the dp.</p>
<p>For example, this is the code from the top to bottom. We make sure the status of the start node (parent node) and then considering the status of the child node.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 1 index of the node, 2 true or false</span></span><br><span class="line">    map&lt;TreeNode*, map&lt;<span class="type">bool</span>, <span class="type">int</span>&gt; &gt; cache;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//choose root</span></span><br><span class="line">        <span class="type">int</span> max1=<span class="built_in">help</span>(root,<span class="literal">true</span>);</span><br><span class="line">        <span class="type">int</span> max2=<span class="built_in">help</span>(root,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(max1,max2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return the max value when the current node is root</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">help</span><span class="params">(TreeNode* root, <span class="type">bool</span> ifrob)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cache.<span class="built_in">find</span>(root)!=cache.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cache[root].<span class="built_in">find</span>(ifrob)!=cache[root].<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> cache[root][ifrob];</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// add a cache here? </span></span><br><span class="line">        <span class="keyword">if</span>(ifrob)&#123;</span><br><span class="line">           <span class="type">int</span> lvalue=<span class="built_in">help</span>(root-&gt;left,<span class="literal">false</span>);</span><br><span class="line">           <span class="type">int</span> rvalue=<span class="built_in">help</span>(root-&gt;right,<span class="literal">false</span>); </span><br><span class="line">           <span class="keyword">return</span> lvalue+rvalue+root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//if current is false</span></span><br><span class="line">        <span class="comment">//the next level can be false or true</span></span><br><span class="line">        <span class="type">int</span> l1=<span class="built_in">help</span>(root-&gt;left,<span class="literal">false</span>);</span><br><span class="line">        <span class="type">int</span> l2=<span class="built_in">help</span>(root-&gt;right,<span class="literal">false</span>);</span><br><span class="line">        <span class="type">int</span> l3=<span class="built_in">help</span>(root-&gt;left,<span class="literal">true</span>);</span><br><span class="line">        <span class="type">int</span> l4=<span class="built_in">help</span>(root-&gt;right,<span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">max</span>(l1,l3)+<span class="built_in">max</span>(l2,l4);</span><br><span class="line">        </span><br><span class="line">        cache[root][ifrob]=result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>and this is the code from the bottom to up. We make sure the status of the child node and then refer to the status of the parent node.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> Vr, Vnr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">helper</span>(root, Vr, Vnr);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(Vr,Vnr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//return value is the status of the current</span></span><br><span class="line">    <span class="comment">//The Vcr and Vcnr are used to store the intermediate status</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="type">int</span>&amp; Vcr, <span class="type">int</span>&amp; Vcnr)</span></span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            Vcr = <span class="number">0</span>;</span><br><span class="line">            Vcnr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//l child status</span></span><br><span class="line">        <span class="type">int</span> Vlr, Vlnr =<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;left,Vlr,Vlnr);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//r child status</span></span><br><span class="line">        <span class="type">int</span> Vrr, Vrnr =<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;right,Vrr,Vrnr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//compute the Vcr and Vcnr</span></span><br><span class="line">        <span class="comment">//if current rub</span></span><br><span class="line">        Vcr = Vlnr+Vrnr+root-&gt;val;</span><br><span class="line">        <span class="comment">//if current not rub</span></span><br><span class="line">        Vcnr = <span class="built_in">max</span>(Vlr,Vlnr)+<span class="built_in">max</span>(Vrr,Vrnr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>If we consider the issue from the status transfer, the parent node and the child node mainatins a kind of relationship (depending on the context of the question), the status table is listed as follows from the child to the parent</p>
<p>L  R  C<br>R  NR NR<br>R  R  NR<br>NR NR R&#x2F;NR<br>NR R  NR</p>
<p>we could check the parent firstly or child firstly, there are two different programming paradigm. For the first version, we use the strategy from start to the end. For the second case, we fix the status of the leaf node firstly, then derive it from the bottom to the top. Even for previous questions that search the properties of the tree, we also use the similar ideas. These questions only have one variable and the status is also comparatively simple.</p>
<p>Inspired by the dp solution of the 337, we can write another dp solution of the <code>968. Binary Tree Cameras</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//root is null</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//at least two layers</span></span><br><span class="line">        <span class="type">int</span> Vcm, Vncm, Vncnm=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">helper</span>(root, Vcm, Vncm, Vncnm);</span><br><span class="line">        <span class="comment">//the result is 1 at least</span></span><br><span class="line">        <span class="keyword">if</span>(Vcm==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Vncm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Vncm==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Vcm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(Vcm,Vncm);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//when it is not at the top position, we can always postpone the choice</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="type">int</span>&amp; Vcm, <span class="type">int</span>&amp; Vncm, <span class="type">int</span>&amp; Vncnm)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">//the init status should be fixed, which is ncm</span></span><br><span class="line">            Vcm=<span class="number">9999</span>;</span><br><span class="line">            Vncm=<span class="number">0</span>;</span><br><span class="line">            Vncnm=<span class="number">9999</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> LVcm, LVncm, LVncnm=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;left,  LVcm, LVncm, LVncnm);</span><br><span class="line">        <span class="type">int</span> RVcm, RVncm, RVncnm=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">helper</span>(root-&gt;right, RVcm, RVncm, RVncnm);</span><br><span class="line">        </span><br><span class="line">        Vcm = <span class="number">1</span>+<span class="built_in">min</span>(LVcm, <span class="built_in">min</span>(LVncm, LVncnm))+<span class="built_in">min</span>(RVcm, <span class="built_in">min</span>(RVncm, RVncnm));</span><br><span class="line">        Vncm= <span class="built_in">min</span>(LVcm+RVcm, <span class="built_in">min</span>((LVcm+RVncm), (LVncm+RVcm)));</span><br><span class="line">        Vncnm=<span class="built_in">min</span>(LVcm,LVncm)+<span class="built_in">min</span>(RVcm, RVncm);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This code is easy to understand if we list the status transfer between children and the parent:</p>
<p>L——R——C<br>CM   CM   CM&#x2F;NCM&#x2F;NCNM<br>CM   NCM  CM&#x2F;NCM&#x2F;NCNM<br>CM   NCNM CM<br>NCM  CM   CM&#x2F;NCM&#x2F;NCNM<br>NCM  NCM  CM&#x2F;NCNM<br>NCM  NCNM CM<br>NCNM CM   CM<br>NCNM NCM  CM<br>NCNM NCNM CM</p>
<p>The tricky point is the status when there is nullptr, at that case, we should assume the node status is the NCM. For the origianl solution, it assume that when there is CM or NCM, it is always prefered to postpone the camera except the current node is the top layer, so we can guarantee the status of the tree by this analysis. But the dp solution is a more general case.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/04/21/Algorithm-8-Tree/" data-id="clt2dorm9000cyjjr5ymlejzx" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
 
<script src="/jquery/jquery.min.js"></script>

  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2022/04/24/GraphicsBasics/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          Graphics Basics
        
      </div>
    </a>
  
  
    <a href="/2022/03/20/phd-story/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">PhD story (in situ story)</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Key-techniques-and-considerations"><span class="toc-number">1.</span> <span class="toc-text">Key techniques and considerations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Traverse-tree"><span class="toc-number">2.</span> <span class="toc-text">Traverse tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tree-properties-whole-tree"><span class="toc-number">3.</span> <span class="toc-text">Tree properties (whole tree)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tree-properties-path-path-sum-nodes"><span class="toc-number">4.</span> <span class="toc-text">Tree properties (path, path sum, nodes)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modifing-tree-structure"><span class="toc-number">5.</span> <span class="toc-text">Modifing tree structure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tree-others"><span class="toc-number">6.</span> <span class="toc-text">Tree + others</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tree-string-serilization"><span class="toc-number">6.1.</span> <span class="toc-text">tree+string (serilization)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tire-tree-or-dict-tree-for-accelaration"><span class="toc-number">7.</span> <span class="toc-text">Tire tree or dict tree for accelaration</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tree-map-or-dp-using-map-to-optimize-the-code"><span class="toc-number">7.1.</span> <span class="toc-text">tree+map or dp (using map to optimize the code)</span></a></li></ol></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2024 zhe&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;godenwangzhe@gmail.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  



 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>