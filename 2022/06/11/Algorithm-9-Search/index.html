<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Algorithm(9) Search | AverageMind</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Find particular properties based on the abstracted decision tree or abstracted graph.">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithm(9) Search">
<meta property="og:url" content="http://yoursite.com/2022/06/11/Algorithm-9-Search/index.html">
<meta property="og:site_name" content="AverageMind">
<meta property="og:description" content="Find particular properties based on the abstracted decision tree or abstracted graph.">
<meta property="og:locale">
<meta property="article:published_time" content="2022-06-12T03:47:41.000Z">
<meta property="article:modified_time" content="2022-06-29T20:33:35.165Z">
<meta property="article:author" content="zhe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="AverageMind" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-165927341-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AverageMind</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Algorithm-9-Search" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/06/11/Algorithm-9-Search/" class="article-date">
  <time datetime="2022-06-12T03:47:41.000Z" itemprop="datePublished">2022-06-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Algorithm(9) Search
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>Find particular properties based on the abstracted decision tree or abstracted graph. </p>
<span id="more"></span>

<p>The input data is not the explicit tree with Tree node for questions listed in this blog. For the string structure, it may use some ideas like sliding window with loer bound and upper bound as the mechanism to search things, we do not list them here, we mainly list the question with the <strong>decision tree or graph in an logical way</strong> but the <strong>input is not the not the explicit tree structure</strong>.</p>
<table>
<thead>
<tr>
<th>Input data</th>
<th>DFS<br>(up to bottom)</th>
<th>DFS<br>(bottom to up)</th>
<th>Naive BFS</th>
<th>BFS with visited flag</th>
<th>BFS+DFS</th>
<th>Binary search</th>
<th>Accelaration by Map</th>
</tr>
</thead>
<tbody><tr>
<td>single number</td>
<td>(combination)<br>22</td>
<td></td>
<td></td>
<td>818</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>array of numbers</td>
<td>(combination)<br>39,40,77<br>78,90,216<br>(permuataion)<br> 46,47,996</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>string</td>
<td>(permutation)784<br>(expression)<br>856,726,301</td>
<td>(expression) 394</td>
<td></td>
<td>752</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2d Array</td>
<td>943,37,51,52<br> 79,212,</td>
<td></td>
<td>17,542(multisource)</td>
<td>127</td>
<td>126</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="Key-techniques-and-considerations"><a href="#Key-techniques-and-considerations" class="headerlink" title="Key techniques and considerations"></a>Key techniques and considerations</h3><ul>
<li><p>Extracting decision tree from the actual problem. One difficulty with the search problem is that we need to extract the decision tree logically from different problem contexts. Typical scenarios are 1&gt; the binary tree type, which decide add or not add current character. Each node represent choose or not choose here 2&gt; Each node represents an actual character as the tree node, such as the permulation problems or combination of different cases. 3&gt; Each node represents the derived results about the givin input, a little bit similar to the reduction opetaion. such as 241, the resutls can be a set contains all possible solutions.</p>
</li>
<li><p>Using DFS or BFS, we can decide to use BFS or DFS from several aspects:</p>
<ol>
<li><p>For the tree node expression, the BFS case might need to use a customized tree node (which is rarely used in leetcode questions), usually use the <strong>pair or tuple</strong> if we need multiple variables in the tree node. For the DFS code, there are less restrictions since we basically hide the tree node inexplicitly in the function call. We can transfer the necessary variables used in each call by function parameters. We can also set some varaibles as the class variables to avoid transfering them by tree node and simplify the code a little bit.</p>
</li>
<li><p>Time complexity and if there is explicit layered structure. Although both the time compexity is O(V+E), the DFS is suitable for the narrow long tree, ans the BFS is suitable for the wide and short tree. In practical case, we may need to evaluate the data scale of the leetcode question, this may decide which algorithm is used for the giving data sets. This is tricky and is easy to be neglected when we start to code in in a rush without considering time compexity in advance carefully.</p>
<p>If the question shows an obvious layered structure, the BFS can be more approporiate. For example, we find the minimal path with the particular constrians, we use the BFS, once find the path, we return it direactly. These type of questions are typical BFS style, and the BFS can ususlly save more efficient for solving these type of questions.</p>
<p>BFS is more approporiate for the question with the abstraction of the distance or shortest path. We try to find a shortest path from the root. For the question there is a cycle, the BFS might be suitable. Since there is no unique layered structure in the case where there is cycle, and the level can be different if we go through along the different path (such as 79).</p>
</li>
<li><p>For the DFS solution, pay attention that if we need return sth from the child tree. Namely make sure which is more convenient, either top to bottom operation (the previous informaion in the path can be used to determin the subsequent nodes in the path) or bottom to up operation. The core idea is to make sure what are computation processed in each node (is it merging two results from subtree or divide the current results to two subtree). It is worth noting that, for the bottom to up case, we can only use the DFS since it keep the status of the current node, so we can update the status when getting back results from the subtree. For the BFS, it just pop the parent out during the traverse process and we can not further update the previous status of the nodes.</p>
</li>
</ol>
<p>   For the DFS case, there are three typical design: (a) Check all solutions and return void, put the valid path into a separate ans (b) Return true or false, we only need to find one path in this case, if we find the valid path, just return true (such as 37) (c) Return a specific value for each dfs call, maybe a reduced integer or more complex results such as a set.</p>
<ol start="4">
<li>Set back the status. It is important to always check if we set the status back for the dfs operation. For example, a&gt; when we find specific path, remember to pop the current node back from the ans <strong>if we insert it for the current layer</strong> (make sure the <code>pop_back</code> match with the <code>insert</code>, otherwise, there might be the memory issue). b&gt; The status can also be the flag variable that label if a specific character is visited or not. c&gt; In the for loop scenarios, we need to make sure the status if set back to the parent case before calling the dfs operations each time.</li>
</ol>
<p>If there is no difference between the aspects discussed above, we can either use BFS or DFS. And using DFS might be more easier from coding’s perspective if we write it into a recursive way instead of using a stack.</p>
</li>
<li><p>Commonly used debug strategy. This part of question is easy prone and some small type of condition error can lead to totally different results. Start from the small scale case or print out the traverse path explicitly are commonly used strategies.</p>
</li>
<li><p>Commonly used optimization strategy or trimming strategy. Sort the input array. Using flag to label the status of associated elements. Using map to memorize existing path (if the key and values are clear). Avoid the unnecessary string copy.</p>
</li>
<li><p>Ensentially the bfs or dfs questions discussed this part can process the unweighted graph. For the question which can be abstracted as the weighted graph, we need to use more complex mechanism to do that such as the dp method to acclerate the searching process (such as dp approach of the 943)</p>
</li>
<li><p>Be careful about using the <code>vector&lt;bool&gt;</code> when you need to use a flag array. There are lots of discussion online, you may just use the <code>vector&lt;int&gt;</code> for simplicity or use the bit mask if the flag length is fixed. Using the <code>vector&lt;bool&gt;</code> can slow down the your code heavily (a least 10x times slower compared with usinig the <code>vector&lt;int&gt;</code>) 996 is a good example (three important conditions) to discuss about how to set the flag to make sure how the same node can be visited once in the same level.</p>
</li>
<li><p>A tip for checking the associated elements in 2d case. We might check the element at the different direaction such as up down left and right even for slash direaction sometimes, instead of go through each dimention separately, the good way is to initilize a 2d vector, such as <code>(-1,1),(1,-1)...</code> then we use one loop to range this vector and adjust the x and y coordinates accordingly. This method is more simple to check the different direction of the 2d grid (Related question: 51).</p>
</li>
</ul>
<h3 id="Naive-DFS-UpToBottom-Combination"><a href="#Naive-DFS-UpToBottom-Combination" class="headerlink" title="Naive DFS-UpToBottom-Combination"></a>Naive DFS-UpToBottom-Combination</h3><p>The nature of the combination is the cartision product, we may need to have an idea about the set. Then the results of the combination might be to do the cartision products between different sets. It is important to figure out what are avalible set for some questions with complex background.</p>
<p><strong>39. Combination Sum</strong></p>
<p>This is the recursion version, which is really fast. For this recursion version based on dfs, the pop out operation at the end of dfs call is really important. Sorting the input array is an important techniques, sometimes, it can trim the searching tree (when the target value is negative one we trim the tree). The key idea to make sure that the elements can be used multiple times is that for each step of creating the children node, we go through all possible options no matter it is visited or not.</p>
<p>Another key point is that, if we do not use the sort, we may have repeated resutls such as <code>[2,3,3] and [3,2,3]</code>. From the implementaion perspective, using the remain value, and we decrease it gradually (instead of sum value) can be more convenient. Otherwise, we need to check if the current path exists in the ans set (we need to sort the array and check back and forth, which is redundant)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">dfs</span>(candidates, target, <span class="number">0</span>, cur, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; cur, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans)</span></span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s;i&lt;candidates.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(candidates[i]&gt;target)&#123;</span><br><span class="line">                <span class="comment">//current path not valid</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target-candidates[i], i, cur, ans);</span><br><span class="line">            <span class="comment">//set back to original status</span></span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>We can also use the BFS for this simple context, but for this question, there is no obvious benifits for using the BFS, since we need to search all possible solutions. However, it needs some difficuties to process the intermidiate node. Using the targetNew value as the distinction for different strategies is important. (how to define the control block is important)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="built_in">Node</span>(vector&lt;<span class="type">int</span>&gt; path, <span class="type">int</span> target, <span class="type">int</span> index) : <span class="built_in">m_path</span>(path), <span class="built_in">m_target</span>(target), <span class="built_in">m_index</span>(index)&#123;&#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; m_path;</span><br><span class="line">    <span class="type">int</span> m_target;</span><br><span class="line">    <span class="type">int</span> m_index;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">    queue&lt;Node&gt; q;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="comment">//avoid the repeated answer such as [2,3,3] and [3,2,3]</span></span><br><span class="line">    <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> len = candidates.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// init the q</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="type">int</span> v = candidates[i];</span><br><span class="line">      <span class="type">int</span> targetnew = target - v;</span><br><span class="line">      <span class="function">Node <span class="title">d</span><span class="params">(&#123;v&#125;, targetnew, i)</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (targetnew &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(d);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetnew == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;v&#125;);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (q.<span class="built_in">empty</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="type">int</span> levelSize = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// go through the queue</span></span><br><span class="line">        <span class="keyword">while</span> (levelSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          Node node = q.<span class="built_in">front</span>();</span><br><span class="line">          <span class="comment">//there should not be the i</span></span><br><span class="line">          <span class="comment">//it should be the value of the parent</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> j = node.m_index; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="type">int</span> vnew = candidates[j];</span><br><span class="line">            <span class="type">int</span> targetNew = node.m_target - vnew;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; pathNew = node.m_path;</span><br><span class="line">            pathNew.<span class="built_in">push_back</span>(vnew);</span><br><span class="line">            <span class="comment">// push the satiafied results into the ans</span></span><br><span class="line">            <span class="comment">// push the valid results into the next level</span></span><br><span class="line">            <span class="keyword">if</span> (targetNew &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="function">Node <span class="title">nodnew</span><span class="params">(pathNew, targetNew, j)</span></span>;</span><br><span class="line">              q.<span class="built_in">push</span>(nodnew);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetNew == <span class="number">0</span>) &#123;</span><br><span class="line">              ans.<span class="built_in">push_back</span>(pathNew); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// targetNew &lt; 0</span></span><br><span class="line">            <span class="comment">// do nothing for this case</span></span><br><span class="line">            <span class="comment">// do not push subsequent nodes</span></span><br><span class="line">          &#125;</span><br><span class="line">          q.<span class="built_in">pop</span>();</span><br><span class="line">          levelSize--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>40. Combination Sum II</strong></p>
<p>This one is similar with previous one, but the only difference is that the element is not unique in the input string, we add some constrains to avoid the repeated ans. The sorting operation is still necessary, we just skip the current element if it has been visited.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; curr;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(ans,candidates,<span class="number">0</span>,target,curr, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans, vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> start, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; curr, <span class="type">bool</span> firstlayer)</span></span>&#123;</span><br><span class="line">        <span class="comment">//dfs children</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;candidates.<span class="built_in">size</span>();i++)&#123; </span><br><span class="line">            <span class="comment">// if i is in visited, jump</span></span><br><span class="line">            <span class="comment">// attention, it is the i&gt;start here</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;start &amp;&amp; candidates[i]==candidates[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> targetNew = target-candidates[i];</span><br><span class="line">            <span class="keyword">if</span>(targetNew&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(targetNew==<span class="number">0</span>)&#123;</span><br><span class="line">                curr.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(curr);</span><br><span class="line">                curr.<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//targetNew &gt;0</span></span><br><span class="line">                <span class="comment">//visit current node</span></span><br><span class="line">                curr.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">                <span class="comment">//dfs</span></span><br><span class="line">                <span class="built_in">dfs</span>(ans,candidates,i+<span class="number">1</span>,targetNew, curr, <span class="literal">false</span>);</span><br><span class="line">                curr.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>77. Combinations</strong></p>
<p>The idea is similar with previous one. Be careful the meaning of the n and k. This can be viewed as the basic one for this type of question. Using the dfs can make things much more easier. For the first layer, there are n possibilites, and then the next layer, there is n-1 combinations.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">        //k numbers</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        vector&lt;int&gt; curr;</span><br><span class="line">        //in the range of 1 to n</span><br><span class="line">        dfs(ans, curr, 1, k, n);</span><br><span class="line">        return ans;        </span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp;ans, vector&lt;int&gt;&amp;curr, int s, int k, int n)&#123;  </span><br><span class="line">        int currsize = curr.size();</span><br><span class="line">        if(currsize==k)&#123;</span><br><span class="line">            ans.push_back(curr);</span><br><span class="line">            return;</span><br><span class="line">        &#125;     </span><br><span class="line">        for(int i=s;i&lt;=n;i++)&#123;</span><br><span class="line">            curr.push_back(i);</span><br><span class="line">            dfs(ans, curr, i+1, k, n);</span><br><span class="line">            curr.pop_back();              </span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>78. Subsets</strong> </p>
<p>This is also comparatively easy and we can use the similar ideas to solve this questions. The difference is that is stores the results into the ans for every possibilities. For previous quesitons, it stores the value only when it satisfies specific constraints. This one is more generous without specific constraints.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        //the number in sets can be 1 to n</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        vector&lt;int&gt; cur;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        ans.push_back(&#123;&#125;);</span><br><span class="line">        dfs(ans, cur, nums, 0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp;ans, vector&lt;int&gt;&amp;curr, vector&lt;int&gt;&amp; nums, int s)&#123;       </span><br><span class="line">        for(int i=s;i&lt;nums.size();i++)&#123;</span><br><span class="line">            curr.push_back(nums[i]);</span><br><span class="line">            //for each possible results, put into ans</span><br><span class="line">            ans.push_back(curr);</span><br><span class="line">            dfs(ans,curr,nums,i+1);</span><br><span class="line">            curr.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>90. Subsets II</strong></p>
<p>There are some difference, it contains the repeated elements in queue, and results should not be repeative. We can solve this using the similar techniques used in 40</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">//the number in sets can be 1 to n</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">        <span class="built_in">dfs</span>(ans, cur, nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;ans, vector&lt;<span class="type">int</span>&gt;&amp;curr, vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> s)</span></span>&#123;       </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;s &amp;&amp; nums[i]==nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">//for each possible results, put into ans</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(curr);</span><br><span class="line">            <span class="built_in">dfs</span>(ans,curr,nums,i+<span class="number">1</span>);</span><br><span class="line">            curr.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>216. Combination Sum III</strong></p>
<p>There are not much differences compred with previous type, we put the curr into the ans when the constraints are satisfied.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="comment">//n is the targeted value</span></span><br><span class="line">        <span class="comment">//k represents the list from 1 to k </span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; curr;</span><br><span class="line">        <span class="built_in">dfs</span>(ans, curr, <span class="number">1</span>, k, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans,vector&lt;<span class="type">int</span>&gt;&amp; curr, <span class="type">int</span> s, <span class="type">int</span> k, <span class="type">int</span> target)</span></span>&#123;      </span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span> &amp;&amp; curr.<span class="built_in">size</span>()==k)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s;i&lt;=<span class="number">9</span>;i++)&#123;      </span><br><span class="line">            <span class="type">int</span> targetnew = target-i;</span><br><span class="line">            <span class="keyword">if</span>(targetnew&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//do not further go through along this path</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;        </span><br><span class="line">            <span class="comment">//for case targetnew &gt;0 or ==0 using dfs</span></span><br><span class="line">            <span class="comment">//we list the return point at the begining of the dfs</span></span><br><span class="line">            <span class="comment">//it can simplify the code a little bit compared with </span></span><br><span class="line">            <span class="comment">//processing every if condition separately</span></span><br><span class="line">            curr.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">dfs</span>(ans,curr,i+<span class="number">1</span>,k,targetnew);</span><br><span class="line">            curr.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>22. Generate Parentheses</strong></p>
<p>Evey node can be the left or right parentheses, and then we trim some results. From the top to bottom, the final path from the root to the leaf node is the actual ans we need to record. We can only place the right parathesis if the count of the left parathesis is larger than 0.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> totalLen=<span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        totalLen=n*<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">helper</span>(ans, <span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(vector&lt;string&gt;&amp; ans, string str, <span class="type">int</span> leftc)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> strlen = str.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(strlen == totalLen &amp;&amp; leftc==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//put string into ans</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(strlen&lt;totalLen)&#123;</span><br><span class="line">            <span class="comment">//can put leftc anyway, left child</span></span><br><span class="line">            <span class="built_in">helper</span>(ans,str+<span class="string">&quot;(&quot;</span>,leftc+<span class="number">1</span>);                </span><br><span class="line">            <span class="keyword">if</span>(leftc&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// can put right if there is remaining leftc</span></span><br><span class="line">                <span class="comment">// left child</span></span><br><span class="line">                <span class="built_in">helper</span>(ans,str+<span class="string">&quot;)&quot;</span>,leftc<span class="number">-1</span>);</span><br><span class="line">            &#125;              </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>37. Sudoku Solver</strong></p>
<p>the idea of checking the conflicts is just check it from the 1-9 and keep calling the next level, try to set the cell to a dot if there is no possible results. return the true if all cells are filled in.</p>
<p>The logic is not complex but it sill take me some time to figure it out. Originally we did not add return true or false, so it basically search all possibilities even if we find a valid results. The idea here is that we return it immediately if we find a valid ans. For the case when there is number at a specific position, we also need to add the return true or false.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// assume i and j is less then 9</span></span><br><span class="line">  <span class="comment">// assume value is from 1 to 9</span></span><br><span class="line">  <span class="comment">// the current one is .</span></span><br><span class="line">  <span class="comment">// make sure what are possible options for specific set</span></span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getOptions</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> column, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> boardDim = <span class="number">9</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="comment">// filter row i</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; boardDim; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j == column) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (board[row][j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// filter the conflict value</span></span><br><span class="line">      flag[board[row][j] - <span class="string">&#x27;0&#x27;</span>] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// filter column j</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; boardDim; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == row) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (board[i][column] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// filter out the conflict one</span></span><br><span class="line">      flag[board[i][column] - <span class="string">&#x27;0&#x27;</span>] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// filter box</span></span><br><span class="line">    <span class="type">int</span> rowBox = row / <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> columnBox = column / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = rowBox * <span class="number">3</span>; i &lt; (rowBox + <span class="number">1</span>) * <span class="number">3</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = columnBox * <span class="number">3</span>; j &lt; (columnBox + <span class="number">1</span>) * <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == row &amp;&amp; j == column) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        flag[board[i][j] - <span class="string">&#x27;0&#x27;</span>] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get option</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (flag[i]) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// using recursion based dfs</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, board);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> column, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> boardRow = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> boadColumn = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (row == boardRow) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nextRow = row;</span><br><span class="line">    <span class="keyword">if</span> (column == (boadColumn - <span class="number">1</span>)) &#123;</span><br><span class="line">      nextRow = row + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> nextColumn = (column + <span class="number">1</span>) % boadColumn;</span><br><span class="line">    <span class="keyword">if</span> (board[row][column] &gt;= <span class="string">&#x27;1&#x27;</span> &amp;&amp; board[row][column] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">dfs</span>(nextRow, nextColumn, board);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// current value node exist</span></span><br><span class="line">      <span class="comment">// get options</span></span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; options = <span class="built_in">getOptions</span>(row, column, board);</span><br><span class="line">      <span class="keyword">if</span> (options.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// current is conflict</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// range options</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; options.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        board[row][column] = options[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">bool</span> find = <span class="built_in">dfs</span>(nextRow, nextColumn, board);</span><br><span class="line">        <span class="keyword">if</span> (find==<span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// pop back (not necessary, there is valid answer anyway)</span></span><br><span class="line">        board[row][column] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>51. N-Queens</strong></p>
<p>This question is similar to previous one. The dfs need to go thrrough all possible combinations and store the valid results during the traverse. For each level, we can assume the possible options (namely the elements in the set) is the position for each one in different column. Then we use a function to decide if each position is conflict with the current grid results to decide if the current tree can move one step further. The recursion depth is the size of the grid.</p>
<p>Fur the current code, the meaning of each node means if the tree is at the specific row, column position. Since each row can only put one element, so we can simply use a for loop to detect each case and range it. (Every option is exclusive)</p>
<p>Origianlly, we consider a more general case and consider each cell separately. Each cell can put a queue or not, for that code, even though it can work, but we create too many recursions and the code become slow. The time complexity is <code>O(2^(n*n))</code> for that case, for the current case, the time complexity is <code>O(n*n)</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_gridDim;</span><br><span class="line">  vector&lt;vector&lt;string&gt;&gt; m_ans;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dir = &#123;&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"> </span><br><span class="line">  vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">initGrid</span><span class="params">(n)</span></span>;</span><br><span class="line">    m_gridDim = n;</span><br><span class="line">    <span class="comment">// init grid</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_gridDim; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        initGrid[j] += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(n, <span class="number">0</span>, initGrid);</span><br><span class="line">    <span class="keyword">return</span> m_ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//each row is a new level of the tree</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">conflict</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> column, vector&lt;string&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// edge case</span></span><br><span class="line">    <span class="keyword">if</span> (m_gridDim == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check row</span></span><br><span class="line">    <span class="keyword">if</span> (grid[row].<span class="built_in">find</span>(<span class="string">&quot;Q&quot;</span>) != string::npos) &#123;</span><br><span class="line">      <span class="comment">// there is Q in this row</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check column</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_gridDim; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (grid[i][column] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//check for dir</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> nextr = row+dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nextc = column+dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//if the results is in the boundry</span></span><br><span class="line">        <span class="keyword">while</span> (nextr &gt;= <span class="number">0</span> &amp;&amp; nextr &lt; m_gridDim &amp;&amp; nextc &gt;= <span class="number">0</span> &amp;&amp; nextc &lt; m_gridDim) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[nextr][nextc] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//continue move</span></span><br><span class="line">            nextr=nextr+dir[i][<span class="number">0</span>];</span><br><span class="line">            nextc = nextc+dir[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// put one queue for one row</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> remain, <span class="type">int</span> curRow, vector&lt;string&gt;&amp; currGrid)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//printf(&quot;r %d\n&quot;, curRow);</span></span><br><span class="line">    <span class="comment">//for (int i = 0; i &lt; m_gridDim; i++) &#123;</span></span><br><span class="line">    <span class="comment">//  printf(&quot;%s\n&quot;, currGrid[i].c_str());</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//printf(&quot;\n---\n&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (curRow == m_gridDim) &#123;</span><br><span class="line">      <span class="comment">// out of bound</span></span><br><span class="line">      <span class="comment">// the current ans might ok</span></span><br><span class="line">      <span class="keyword">if</span> (remain == <span class="number">0</span>) &#123;</span><br><span class="line">        m_ans.<span class="built_in">push_back</span>(currGrid);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>;c&lt;m_gridDim;c++)&#123;</span><br><span class="line">        <span class="comment">//if put at the current row and c</span></span><br><span class="line">        <span class="type">bool</span> ifconflict = <span class="built_in">conflict</span>(curRow, c, currGrid);</span><br><span class="line">        <span class="keyword">if</span>(ifconflict)&#123;</span><br><span class="line">            <span class="comment">//can not put at the current position</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//put it at the current position</span></span><br><span class="line">        currGrid[curRow][c] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(remain - <span class="number">1</span>, curRow+<span class="number">1</span>, currGrid);</span><br><span class="line">        <span class="comment">// set status back</span></span><br><span class="line">        currGrid[curRow][c] = <span class="string">&#x27;.&#x27;</span>;          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>52. N-Queens II</strong></p>
<p>The idea is similar with previous one, just change the ans when get the valid solution each time.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_gridDim;</span><br><span class="line">  <span class="type">int</span> m_ans=<span class="number">0</span>;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dir = &#123;&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">initGrid</span><span class="params">(n)</span></span>;</span><br><span class="line">        m_gridDim = n;</span><br><span class="line">        <span class="comment">// init grid</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_gridDim; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            initGrid[j] += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(n, <span class="number">0</span>, initGrid);</span><br><span class="line">        <span class="keyword">return</span> m_ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//each row is a new level of the tree</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">conflict</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> column, vector&lt;string&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// edge case</span></span><br><span class="line">    <span class="keyword">if</span> (m_gridDim == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check row</span></span><br><span class="line">    <span class="keyword">if</span> (grid[row].<span class="built_in">find</span>(<span class="string">&quot;Q&quot;</span>) != string::npos) &#123;</span><br><span class="line">      <span class="comment">// there is Q in this row</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check column</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_gridDim; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (grid[i][column] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//check for dir</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> nextr = row+dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nextc = column+dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//if the results is in the boundry</span></span><br><span class="line">        <span class="keyword">while</span> (nextr &gt;= <span class="number">0</span> &amp;&amp; nextr &lt; m_gridDim &amp;&amp; nextc &gt;= <span class="number">0</span> &amp;&amp; nextc &lt; m_gridDim) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[nextr][nextc] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//continue move</span></span><br><span class="line">            nextr=nextr+dir[i][<span class="number">0</span>];</span><br><span class="line">            nextc = nextc+dir[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// put one queue for one row</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> remain, <span class="type">int</span> curRow, vector&lt;string&gt;&amp; currGrid)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//printf(&quot;r %d\n&quot;, curRow);</span></span><br><span class="line">    <span class="comment">//for (int i = 0; i &lt; m_gridDim; i++) &#123;</span></span><br><span class="line">    <span class="comment">//  printf(&quot;%s\n&quot;, currGrid[i].c_str());</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//printf(&quot;\n---\n&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (curRow == m_gridDim) &#123;</span><br><span class="line">      <span class="comment">// out of bound</span></span><br><span class="line">      <span class="comment">// the current ans might ok</span></span><br><span class="line">      <span class="keyword">if</span> (remain == <span class="number">0</span>) &#123;</span><br><span class="line">        m_ans++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>;c&lt;m_gridDim;c++)&#123;</span><br><span class="line">        <span class="comment">//if put at the current row and c</span></span><br><span class="line">        <span class="type">bool</span> ifconflict = <span class="built_in">conflict</span>(curRow, c, currGrid);</span><br><span class="line">        <span class="keyword">if</span>(ifconflict)&#123;</span><br><span class="line">            <span class="comment">//can not put at the current position</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//put it at the current position</span></span><br><span class="line">        currGrid[curRow][c] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(remain - <span class="number">1</span>, curRow+<span class="number">1</span>, currGrid);</span><br><span class="line">        <span class="comment">// set status back</span></span><br><span class="line">        currGrid[curRow][c] = <span class="string">&#x27;.&#x27;</span>;          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The 52 can also be improved based on DP, we do not discuss it details here.</p>
<p>one optimization for 51 and 52 is to do the conflict checking, we may use more memory space and store if there are elements at specific row, column and dialogue to save the speed for checking the conflicts.</p>
<p>For example, <code>statesRow[i]</code> represents if there are queues at ith row, statesColumn[i] represents if there are elements at ith column, similarly for diagonalLeft and diagonalRight.</p>
<p>For the right side diagonal, the sum of the row and column is a fixed number<br>For the left side diagonal, the sum of the column - row is a fixed number<br>We can map the row and column to these two index.</p>
<p>The subsequent code shows how to use this optimization. We also do not need to store the grid explicitly in this way. The framework is similar with previous one and the operation for detecting the conflicts improves a lot. We just memorize the status based on several arrays explicitly.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_gridDim;</span><br><span class="line">  <span class="type">int</span> m_ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; m_rExist;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; m_cExist;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; m_dlExist;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; m_drExist;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        m_gridDim = n;</span><br><span class="line">        </span><br><span class="line">        m_rExist = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line">        m_cExist = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line">        m_dlExist = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        m_drExist = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> m_ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//each row is a new level of the tree</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">conflict</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> column)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_gridDim == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check row</span></span><br><span class="line">    <span class="keyword">if</span> (m_rExist[row]) &#123;</span><br><span class="line">      <span class="comment">// there is Q in this row</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check column</span></span><br><span class="line">    <span class="keyword">if</span> (m_cExist[column]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check right diagonal</span></span><br><span class="line">    <span class="keyword">if</span> (m_drExist[row + column]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check left diagonal</span></span><br><span class="line">    <span class="type">int</span> leftIndex = column - row + m_gridDim - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_dlExist[leftIndex]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// put one queue for one row</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> remain, <span class="type">int</span> curRow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (curRow == m_gridDim) &#123;</span><br><span class="line">      <span class="comment">// out of bound</span></span><br><span class="line">      <span class="comment">// the current ans might ok</span></span><br><span class="line">      <span class="keyword">if</span> (remain == <span class="number">0</span>) &#123;</span><br><span class="line">        m_ans++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>;c&lt;m_gridDim;c++)&#123;</span><br><span class="line">        <span class="comment">//if put at the current row and c</span></span><br><span class="line">        <span class="type">bool</span> ifconflict = <span class="built_in">conflict</span>(curRow, c);</span><br><span class="line">        <span class="keyword">if</span>(ifconflict)&#123;</span><br><span class="line">            <span class="comment">//can not put at the current position</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//put it at the current position</span></span><br><span class="line">        <span class="comment">//set the current status</span></span><br><span class="line">        m_rExist[curRow] = <span class="number">1</span>;</span><br><span class="line">        m_cExist[c] = <span class="number">1</span>;</span><br><span class="line">        m_drExist[curRow + c] = <span class="number">1</span>;</span><br><span class="line">        m_dlExist[c - curRow + m_gridDim - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(remain - <span class="number">1</span>, curRow+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// set status back</span></span><br><span class="line">        m_rExist[curRow] = <span class="number">0</span>;</span><br><span class="line">        m_cExist[c] = <span class="number">0</span>;</span><br><span class="line">        m_drExist[curRow + c] = <span class="number">0</span>;</span><br><span class="line">        m_dlExist[c - curRow + m_gridDim - <span class="number">1</span>] = <span class="number">0</span>;            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="Naive-DFS-UpToBottom-Permutation"><a href="#Naive-DFS-UpToBottom-Permutation" class="headerlink" title="Naive DFS-UpToBottom-Permutation"></a>Naive DFS-UpToBottom-Permutation</h3><p><strong>46. Permutations</strong> </p>
<p>Typical permutation question, we can reuse the similar framework and put things into the ans only when all elements are checked. Still go through the path as previous one, put the path into the ans only when it get to the end.</p>
<p>Maybe there are more efficient way to consider which path is unnecessary, in this example, we just check if the particular elements is in the curr, if it is already in the curr, we do not go through along that path. The start position in this question start from the 0 to end instead of customized start position to end (since the results can be any order). </p>
<p>We can use another flag vector to label if the element is used or not, if then when we pop the element out, we set the specific label into false. This can further improve the code a little bit.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; curr;</span><br><span class="line">        <span class="built_in">dfs</span>(ans,curr,nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp;curr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:curr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v==k)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;ans, vector&lt;<span class="type">int</span>&gt;&amp;curr,vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//if i is in the curr</span></span><br><span class="line">            <span class="comment">//do not go through along this path</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">exist</span>(nums[i],curr))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            curr.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(ans,curr,nums);</span><br><span class="line">            curr.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This is the code with the visited flag. It looks that the permutation related problem use the visited flag a lot (each ans is a complete path) and the combination problems use the sort a lot (the answer can be half of the path).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; curr;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(ans,curr,nums,visited);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;ans, vector&lt;<span class="type">int</span>&gt;&amp;curr,vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp;visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">//put current path into the ans</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//if i is in the curr</span></span><br><span class="line">            <span class="comment">//do not go through along this path</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            curr.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            visited[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(ans,curr,nums,visited);</span><br><span class="line">            <span class="comment">//set status back</span></span><br><span class="line">            curr.<span class="built_in">pop_back</span>();</span><br><span class="line">            visited[i]=<span class="literal">false</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>47. Permutations II</strong></p>
<p>Similar to the previous question, the input of this problem contains the repeated elements. In previous one, we solve this issue by sorting the input firstly and then compares nums[i] and nums[i-1], when they appears at the second time, we do not go through along that path. It use both the sorting strategy and the visited flag to trim the path</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; curr;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">label</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(ans,curr,nums,label);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;ans, vector&lt;<span class="type">int</span>&gt;&amp;curr,vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; label)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//if i is in the curr</span></span><br><span class="line">            <span class="comment">//do not go through along this path</span></span><br><span class="line">            <span class="keyword">if</span>(label[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//only in the current layer</span></span><br><span class="line">            <span class="comment">//if the previous same one is visited</span></span><br><span class="line">            <span class="comment">//we do not visit current one</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>] &amp;&amp; label[i<span class="number">-1</span>]==<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            curr.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            label[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(ans,curr,nums,label);</span><br><span class="line">            curr.<span class="built_in">pop_back</span>();</span><br><span class="line">            label[i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;        </span><br></pre></td></tr></table></figure>

<p><strong>943. Find the Shortest Superstring</strong></p>
<p>The original idea of this question is that, do all the permulations, and then remove the potential overlapping part.</p>
<p>The original idea to remove the overlapping part is to find if the start position of second string is in the first string. Assuming in the position i of the first string, then compare the i to the end, to see if it appears in the second string, it is possible there are multiple positions. This operation can be applied every time we add a new string. </p>
<p>this operation can be also done before searching (this is a good point), and we store the results explicitly. then we do not need to do the similar operation during the search (we store the information beforehand) This info is important to construct the final path, dfs call is n! for every node, we call n nodes.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//this is the naive search solution</span></span><br><span class="line"><span class="comment">//did not pass all the tests, time limit issue</span></span><br><span class="line"><span class="comment">//56 / 83 test cases passed.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">overlappingLen2</span><span class="params">(string&amp; first, string&amp; second)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> upperBound = <span class="built_in">min</span>(first.<span class="built_in">length</span>(), second.<span class="built_in">length</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= upperBound; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.<span class="built_in">substr</span>(first.<span class="built_in">length</span>() - k) == second.<span class="built_in">substr</span>(<span class="number">0</span>, k)) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">shortestSuperstring</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;        </span><br><span class="line">        string ans;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">labelUsed</span><span class="params">(words.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> wordsLen = words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(words,wordsLen,<span class="string">&quot;&quot;</span>,ans,labelUsed,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//we use the parent Str to remember last steps results</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;string&gt;&amp; words, <span class="type">int</span>&amp; wordsSize, string parentStr, string&amp; ans, vector&lt;<span class="type">bool</span>&gt;&amp; labelUsed, <span class="type">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="comment">//check all the possible of strings here</span></span><br><span class="line">        <span class="keyword">if</span>(count==wordsSize)&#123;</span><br><span class="line">            <span class="comment">//update ans when all string is counted</span></span><br><span class="line">            <span class="keyword">if</span>(ans.<span class="built_in">length</span>()==<span class="number">0</span> || (parentStr.<span class="built_in">length</span>()&lt;ans.<span class="built_in">length</span>()))&#123;</span><br><span class="line">                ans = parentStr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wordsSize;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(labelUsed[i]==<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> overlapLen = <span class="built_in">overlappingLen2</span>(parentStr,words[i]);       </span><br><span class="line">            string currStr = parentStr+words[i].<span class="built_in">substr</span>(overlapLen);</span><br><span class="line">            labelUsed[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//dfs check</span></span><br><span class="line">            <span class="built_in">dfs</span>(words,wordsSize,currStr,ans,labelUsed,count+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//udpate status of the current layer</span></span><br><span class="line">            labelUsed[i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This is the version that computes the prior information about the overlap length between each two pairs.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//use shared part for the ans</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; m_priorInfo;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; m_bestPath;</span><br><span class="line">    <span class="type">int</span> m_bestLen;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">overlappingLen</span><span class="params">(string&amp; first, string&amp; second)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> upperBound = <span class="built_in">min</span>(first.<span class="built_in">length</span>(), second.<span class="built_in">length</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= upperBound; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.<span class="built_in">substr</span>(first.<span class="built_in">length</span>() - k) == second.<span class="built_in">substr</span>(<span class="number">0</span>, k)) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">shortestSuperstring</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;        </span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> wordsLen = words.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        m_priorInfo =vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; (wordsLen, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(wordsLen,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//process the prior info</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wordsLen;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;wordsLen;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">                    m_priorInfo[i][j]=words[i].<span class="built_in">length</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    m_priorInfo[i][j]=<span class="built_in">overlappingLen</span>(words[i],words[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//printf(&quot;info i %d j %d len %d\n&quot;,i,j,priorInfo[i][j]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">labelUsed</span><span class="params">(words.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; currPath;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//do the dfs</span></span><br><span class="line">        <span class="built_in">dfs</span>(words,wordsLen,labelUsed,<span class="number">0</span>,<span class="number">0</span>,currPath);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//recover the string from the bestPath</span></span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_bestPath.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//printf(&quot;path i %d %d\n&quot;,i,m_bestPath[i]);</span></span><br><span class="line">            <span class="type">int</span> currIndex = m_bestPath[i];</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                ans+=words[currIndex];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> lastIndex = m_bestPath[i<span class="number">-1</span>];</span><br><span class="line">                ans+=words[currIndex].<span class="built_in">substr</span>(m_priorInfo[lastIndex][currIndex]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//we use the parent Str to remember last steps results</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;string&gt;&amp; words, <span class="type">int</span>&amp; wordsSize, vector&lt;<span class="type">bool</span>&gt;&amp; labelUsed, <span class="type">int</span> count, <span class="type">int</span> currLen, vector&lt;<span class="type">int</span>&gt;&amp; currPath)</span></span>&#123;</span><br><span class="line">        <span class="comment">//check all the possible of strings here</span></span><br><span class="line">        <span class="keyword">if</span>(m_bestLen&gt;<span class="number">0</span> &amp;&amp; currLen&gt;=m_bestLen)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(count==wordsSize)&#123;</span><br><span class="line">            <span class="comment">//update best path and best len</span></span><br><span class="line">            m_bestLen=currLen;</span><br><span class="line">            m_bestPath=currPath;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wordsSize;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(labelUsed[i]==<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> currLenNew = currLen;</span><br><span class="line">            <span class="keyword">if</span>(currPath.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//the first one</span></span><br><span class="line">                currLenNew=words[i].<span class="built_in">length</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> overlapLen = m_priorInfo[currPath.<span class="built_in">back</span>()][i];</span><br><span class="line">                <span class="comment">//overlappingLen2(words[currPath.back()],words[i]);</span></span><br><span class="line">                currLenNew = currLen+(words[i].<span class="built_in">length</span>()-overlapLen);              </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currPath.<span class="built_in">push_back</span>(i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//string currStr = parentStr+words[i].substr(overlapLen);</span></span><br><span class="line">            labelUsed[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//dfs check</span></span><br><span class="line">            <span class="built_in">dfs</span>(words,wordsSize,labelUsed, count+<span class="number">1</span>, currLenNew, currPath);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//udpate status of the current layer</span></span><br><span class="line">            labelUsed[i]=<span class="literal">false</span>;</span><br><span class="line">            currPath.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="comment">//make sure currLen do not change </span></span><br><span class="line">            <span class="comment">//after each iteration in the for loop</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This code can not pass all tests because and exceeds the limited time. The ideal way is still to view the problem as a weighted graph and find the shortest path. Refer to the graph listed in <a target="_blank" rel="noopener" href="https://zxi.mytechroad.com/blog/searching/leetcode-943-find-the-shortest-superstring/">huahua’s blog</a> and the official solution <a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-the-shortest-superstring/solution/">here</a>. Using the mask to remember the existing visited nodes is a little bit tricky. The 1 or 0 in each bit position of the mask represents that if the associated value is visited or not. The <code>mask ^ (1&lt;&lt;j)</code> represents that we set jth position as 1 and put it into the mask. (The <code>^</code> is the xor opertaion, if the original bit is 0 and current one <code>1&lt;&lt;j</code> is 1, the results here for specific bit is 1). Using <code>s &amp; (1 &lt;&lt; j)</code> operation can check if the specific bit is set. If it is set, the results is a non zero number, otherwise, the result is zero. We do not discuss the dp solution here. The dp solution can be written into the recursive way or not. The core ideas is that we keeping the intermidiate status during the search. How to memorise that information is key point to improve the speed.</p>
<p><strong>996. Number of Squareful Arrays</strong></p>
<p>This is a permutation operation pluse the constraint. The idea is a little bit similar with previous one. Same to the previous one, the naive searching method is still time consuming and the dp method can improve the code a lot, but it is not easy to figure out that dp solution. There are several small points, for example, 0 is also a square number. We can also sort the array and compute the prefix sum to see if the results is squere number. We can avoid the repeated solutions by this way.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; m_priorInfo;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">squareNum</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i*i&lt;=num;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*i==num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquarefulPerms</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> numSize = nums.<span class="built_in">size</span>();</span><br><span class="line">        m_priorInfo = vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; (numSize,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(numSize,<span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">//do the search</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">labels</span><span class="params">(numSize, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(ans,nums,labels,path);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span>&amp; ans, vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; labels, vector&lt;<span class="type">int</span>&gt;&amp; path)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check the results</span></span><br><span class="line">        <span class="comment">//if valid</span></span><br><span class="line">        <span class="comment">//how to remove the repeated one?</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//we need to start from the 0 since we need to go through </span></span><br><span class="line">        <span class="comment">//all permutations</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(labels[i]==<span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>] &amp;&amp; labels[i<span class="number">-1</span>]==<span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!path.<span class="built_in">empty</span>() &amp;&amp; !<span class="built_in">squareNum</span>(path.<span class="built_in">back</span>()+nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//all situation need to put the elements</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            labels[i]=<span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//dfs for children layers</span></span><br><span class="line">            <span class="built_in">dfs</span>(ans,nums,labels,path);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//back to current layer</span></span><br><span class="line">            labels[i]=<span class="literal">false</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This is the version to utilize the prior knoledge, maybe the good strategy is not to compute them all at once, we can cache them during the searching process.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">squareNum</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="built_in">sqrt</span>(num);</span><br><span class="line">    <span class="keyword">return</span> s * s == num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquarefulPerms</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> numSize = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">//do the search</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">labels</span><span class="params">(numSize, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(ans,nums,labels,path);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span>&amp; ans, vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; labels, vector&lt;<span class="type">int</span>&gt;&amp; path)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check the results</span></span><br><span class="line">        <span class="comment">//if valid</span></span><br><span class="line">        <span class="comment">//how to remove the repeated one?</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//we need to start from the 0 since we need to go through </span></span><br><span class="line">        <span class="comment">//all permutations</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(labels[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//be carefule here</span></span><br><span class="line">            <span class="comment">//if there are multiple same elements</span></span><br><span class="line">            <span class="comment">//only the first can be used in the same level, the third one is important</span></span><br><span class="line">            <span class="comment">//only when the labels for previous one is 0</span></span><br><span class="line">            <span class="comment">//we can make sure its dfs complete</span></span><br><span class="line">            <span class="comment">//otherwise, it might be the condition during the dfs process</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>] &amp;&amp; labels[i<span class="number">-1</span>]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!path.<span class="built_in">empty</span>() &amp;&amp; !<span class="built_in">squareNum</span>(path.<span class="built_in">back</span>()+nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//all situation need to put the elements</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            labels[i]=<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//dfs for children layers</span></span><br><span class="line">            <span class="built_in">dfs</span>(ans,nums,labels,path);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//back to current layer</span></span><br><span class="line">            labels[i]=<span class="number">0</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The efficient way is still to use the dp method, it is ensentially a hamitonion path in the graphy theory, refer to this explanation (<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=ISnktonx7rY">https://www.youtube.com/watch?v=ISnktonx7rY</a>). When there two numbers are prefect squre, there is a path between them.</p>
<h3 id="Naive-DFS-UpToBottom-Expression"><a href="#Naive-DFS-UpToBottom-Expression" class="headerlink" title="Naive DFS-UpToBottom-Expression"></a>Naive DFS-UpToBottom-Expression</h3><p>This type of question provide a expression, then maybe we need to compute some properties according to the expression. There usually exist the inserted structure which can be abstracted into a tree. The question in this type is a little bit like decoding the string into a tree structure with layered information, even if we do not use an actually tree structure, we still need to keep a layer variable to trace current part is at which layer. The 856 is a good example.</p>
<p><strong>856 Score of Parentheses</strong></p>
<p>the code looks super easy we do not even write it into a recursion way, but it is not straightforward to figure out why it works. The whole idea for solving this problem is to emulate a tree structure, different with the previous one, every node is a () pair.</p>
<p>For example, if the input is <code>(())</code>, the imaginary tree is as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">()</span><br><span class="line">|</span><br><span class="line">()</span><br></pre></td></tr></table></figure>
<p>If there is <code>(()())</code>, the imaginary tree (or the decision tree) is as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">()</span><br><span class="line">| \</span><br><span class="line">() ()</span><br></pre></td></tr></table></figure>
<p>The key is that we do not consider the implementaion, we consider the abstraction first. Then according to the rule of the score, for each leaf node, its score is 2^depth, then we accumulate all the scores of leaf node together. Although the description of the question is to compute the score from the bottom to top, it is much easier to compute scores from the top to the bottom.</p>
<p>Regarding to the implementation, when there is <code>(</code>, the depth increase, when there is <code>)</code> the depth decrease, and if the previous one is <code>(</code>, we assume that we met the leaf node. The whole sequence is just like the LRN traversal of the tree</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int scoreOfParentheses(string s) &#123;</span><br><span class="line">        int score =0;</span><br><span class="line">        int len = s.length();</span><br><span class="line">        int depth=0;</span><br><span class="line">        //range s</span><br><span class="line">        for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">            if(s[i] == &#x27;(&#x27;)&#123;</span><br><span class="line">                depth++;</span><br><span class="line">            &#125;else if(s[i] == &#x27;)&#x27;)&#123;</span><br><span class="line">                if(i&gt;0 &amp;&amp; s[i-1]==&#x27;(&#x27;)&#123;</span><br><span class="line">                    score+=pow(2,depth-1);</span><br><span class="line">                &#125;</span><br><span class="line">                depth--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Another way is to find the balanced outlayer strcutre, and then use the recursion to call the inner layer, which is like the tree taversal from the top to the bottom, in the string case, it can use the left and right index to label the each layer of the structure, when you find each layer, the tree depth increase one.</p>
<p>Enssentially, it like the process of decoding the string into the tree and then compute some properties of the tree. For the <code>394. Decode String</code>, this idea is more obvious, and we basically use the bottom to up strategy of the tree based approach and we decode each subtree recursively. For each level, we just need a function to let it return the reuslts of the subtree. For the tree structure in logically, the leaf node is the character and the parent node is the number. The issue is that in the string structure, we basically flatten everything and not knwo when it end. So that’s why we also return a right index. That right index labels when the current level moves to the end. And then we start from the next segment (which is the node at the same level with the current node)</p>
<p><strong>726. Number of Atoms</strong></p>
<p>This is the a hard one, the main reason is that the rules are a liitle bit complex. The idea is same with previous one, the different place is that we read the string from right side to the left side, it might be easier to consider things in this way. By this way, we check the number first (the non leaf node) then the atom (the leaf node). The code can be further optimized. Although current code can work, it is still a little bit unclear for when to put the information into the map.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map &lt;string, <span class="type">int</span>&gt; atomMap;</span><br><span class="line">    <span class="function">string <span class="title">countOfAtoms</span><span class="params">(string formula)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ordered map to store the atom and its number</span></span><br><span class="line">        string str;</span><br><span class="line">        <span class="type">int</span> len = formula.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> lindex=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">helper</span>(formula,lindex,len<span class="number">-1</span>,len,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//output the value from map into string</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : atomMap)&#123;</span><br><span class="line">            string key = it.first;</span><br><span class="line">            <span class="comment">//std::cout &lt;&lt; &quot;key&quot; &lt;&lt; key &lt;&lt;std::endl;</span></span><br><span class="line">            <span class="type">int</span> value = it.second;</span><br><span class="line">            str+=key;</span><br><span class="line">            <span class="keyword">if</span>(value!=<span class="number">1</span>)&#123;</span><br><span class="line">                str+=<span class="built_in">to_string</span>(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//paras: formular, start position, len of the formula</span></span><br><span class="line">    <span class="comment">//read it from right to left for simplicity</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(string&amp; f, <span class="type">int</span>&amp; lindex, <span class="type">int</span> rindex, <span class="type">int</span>&amp; len, <span class="type">int</span> multiplier)</span></span>&#123;</span><br><span class="line">        string atomName;</span><br><span class="line">        <span class="type">int</span> fNum=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i=rindex;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//std::cout &lt;&lt; &quot;i &quot; &lt;&lt; i &lt;&lt; std::endl;</span></span><br><span class="line">            <span class="comment">//number</span></span><br><span class="line">            <span class="keyword">if</span>(f[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; f[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// H2O case, it can be a new started atom</span></span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;len &amp;&amp; f[i+<span class="number">1</span>]&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; f[i+<span class="number">1</span>]&lt;=<span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">//this condition is prior than case where there is (</span></span><br><span class="line">                    <span class="comment">//when this executed, we do not check ( further</span></span><br><span class="line">                    <span class="comment">//this is a new atom</span></span><br><span class="line">                    <span class="comment">//std::cout&lt;&lt;&quot;anmed &quot;&lt;&lt;atomName &lt;&lt; &quot;fnum &quot; &lt;&lt; fNum &lt;&lt; &quot;multi &quot; &lt;&lt; multiplier&lt;&lt;std::endl;</span></span><br><span class="line">                    atomMap[atomName]+=fNum*multiplier;</span><br><span class="line">                    <span class="comment">//reset key variables</span></span><br><span class="line">                    atomName=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                    fNum=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//current number</span></span><br><span class="line">                <span class="type">int</span> tempNum = f[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="comment">//read from right to left</span></span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span> &lt; len &amp;&amp; f[i+<span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; f[i+<span class="number">1</span>]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                    fNum = tempNum*<span class="number">10</span>+fNum;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    fNum = tempNum;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//character(multiple)</span></span><br><span class="line">            <span class="keyword">if</span>((f[i]&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; f[i]&lt;=<span class="string">&#x27;Z&#x27;</span>) || (f[i]&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; f[i]&lt;=<span class="string">&#x27;z&#x27;</span>))&#123;</span><br><span class="line">                <span class="comment">//reset the fNum if there are two upper case</span></span><br><span class="line">                <span class="comment">//the 1 is omitted in expression</span></span><br><span class="line">                <span class="comment">//also update in this case</span></span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;len &amp;&amp; f[i+<span class="number">1</span>]&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; f[i+<span class="number">1</span>]&lt;=<span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">//this condition is prior than case where there is (</span></span><br><span class="line">                    <span class="comment">//when this executed, we do not check ( further</span></span><br><span class="line">                    <span class="comment">//this is a new atom</span></span><br><span class="line">                    <span class="comment">//std::cout&lt;&lt;&quot;anmec &quot;&lt;&lt;atomName&lt;&lt;std::endl;</span></span><br><span class="line">                    atomMap[atomName]+=fNum*multiplier;</span><br><span class="line">                    <span class="comment">//reset key variables</span></span><br><span class="line">                    atomName=f[i];</span><br><span class="line">                    fNum=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    atomName=f[i]+atomName;</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(f[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//recursion, process multiple elements inserted</span></span><br><span class="line">                <span class="comment">//in current section</span></span><br><span class="line">                <span class="comment">//update l index</span></span><br><span class="line">                <span class="built_in">helper</span>(f, lindex, i<span class="number">-1</span>, len, multiplier*fNum);</span><br><span class="line">                <span class="comment">//remember to set new fNum, from this point, it is a new segment</span></span><br><span class="line">                fNum=<span class="number">1</span>;</span><br><span class="line">                i=lindex<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// can start with chracter</span></span><br><span class="line">            <span class="comment">// when i==0 also insert</span></span><br><span class="line">            <span class="keyword">if</span>(f[i]==<span class="string">&#x27;(&#x27;</span> || i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//return point</span></span><br><span class="line">                <span class="comment">//put thing into map</span></span><br><span class="line">                <span class="comment">//std::cout&lt;&lt;&quot;anmeb &quot;&lt;&lt;atomName&lt;&lt;std::endl;</span></span><br><span class="line">                <span class="keyword">if</span>(atomName!=<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">                    atomMap[atomName]+=fNum*multiplier;</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">                <span class="comment">//reset key variables</span></span><br><span class="line">                atomName=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                fNum=<span class="number">1</span>;</span><br><span class="line">                lindex=i--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//process the first one</span></span><br><span class="line">        <span class="keyword">if</span>(atomName!=<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">//std::cout&lt;&lt;&quot;anmea &quot;&lt;&lt;atomName&lt;&lt; &quot; fNum &quot; &lt;&lt; fNum &lt;&lt; &quot; multi &quot; &lt;&lt; multiplier &lt;&lt; std::endl;</span></span><br><span class="line">            atomMap[atomName]+=fNum*multiplier;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Another example is 736, which is a little bit complex. (we will solve it in future)</p>
<p><strong>301. Remove Invalid Parentheses</strong></p>
<p>For this type of question, we need to generate new expression based on given expression. The naive way is to use the binaray tree, if the results increase the specific character or not. Without the trim, the complexity is 2^n, every time we map the status array into a new case.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    set&lt;string&gt; m_ans;</span><br><span class="line">    <span class="type">int</span> minUpdated = INT_MAX;</span><br><span class="line">    string inputStr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                depth++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                depth--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//do nothing for the letter</span></span><br><span class="line">            <span class="keyword">if</span>(depth&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//there are extra right parenthesis</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if the results is 0 all match</span></span><br><span class="line">        <span class="keyword">return</span> depth==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">removeInvalidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        inputStr = s;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">removedLabel</span><span class="params">(s.length(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,removedLabel);</span><br><span class="line">        vector&lt;string&gt; ansvec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v:m_ans)&#123;</span><br><span class="line">            ansvec.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ansvec.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            ansvec.<span class="built_in">push_back</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansvec;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">getNewStr</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; removedLabel)</span></span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inputStr.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//keep the string where there is false labels</span></span><br><span class="line">            <span class="keyword">if</span>(removedLabel[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                ans+=inputStr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> removedNum, <span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; removedLabel)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;inputStr.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">if</span>(removedNum&gt;minUpdated)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//maybe add a cache here</span></span><br><span class="line">        string currStr=<span class="built_in">getNewStr</span>(removedLabel);</span><br><span class="line">        <span class="comment">//printf(&quot;currStr %s label %d %d\n&quot;,currStr.c_str(),removedLabel[0],removedLabel[1]);</span></span><br><span class="line">        <span class="keyword">if</span>(removedNum==minUpdated)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">valid</span>(currStr))&#123;</span><br><span class="line">                m_ans.<span class="built_in">insert</span>(currStr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(removedNum&lt;minUpdated)&#123;</span><br><span class="line">            <span class="comment">//removedNum &lt; minUpdated</span></span><br><span class="line">            <span class="comment">//update resutls</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">valid</span>(currStr))&#123;</span><br><span class="line">                m_ans.<span class="built_in">clear</span>();</span><br><span class="line">                m_ans.<span class="built_in">insert</span>(currStr);  </span><br><span class="line">                minUpdated = removedNum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//todo reorganize the code, the s position mayber larger than</span></span><br><span class="line">        <span class="comment">//length in previous section</span></span><br><span class="line">        <span class="keyword">if</span>(s&gt;=inputStr.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//trim cases</span></span><br><span class="line">        <span class="comment">//if letters </span></span><br><span class="line">        <span class="keyword">if</span>(inputStr[s]!=<span class="string">&#x27;(&#x27;</span> &amp;&amp; inputStr[s]!=<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            removedLabel[s] = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(removedNum,s+<span class="number">1</span>,removedLabel);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;    </span><br><span class="line">            <span class="comment">//remove current or not</span></span><br><span class="line">            removedLabel[s]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//do the dfs, removed current</span></span><br><span class="line">            <span class="built_in">dfs</span>(removedNum+<span class="number">1</span>,s+<span class="number">1</span>,removedLabel);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//next is </span></span><br><span class="line">            removedLabel[s]=<span class="number">0</span>;</span><br><span class="line">            <span class="type">char</span> c = inputStr[s];</span><br><span class="line">            <span class="comment">//skip the repeated elements</span></span><br><span class="line">            <span class="keyword">while</span>(s&lt;inputStr.<span class="built_in">length</span>() &amp;&amp; inputStr[s]==c) s++; <span class="comment">//if not take then don&#x27;t take it until the same char</span></span><br><span class="line">            <span class="built_in">dfs</span>(removedNum,s,removedLabel);     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This is the version based on the bit mask and the cache, it does not improve the performance a lot, it however slows down the code, not sure the reason. (maybe the cache is not necessary)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    set&lt;string&gt; m_ans;</span><br><span class="line">    <span class="type">int</span> minUpdated = INT_MAX;</span><br><span class="line">    string inputStr;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; cache; <span class="comment">// map the mask into the string</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                depth++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                depth--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//do nothing for the letter</span></span><br><span class="line">            <span class="keyword">if</span>(depth&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//there are extra right parenthesis</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if the results is 0 all match</span></span><br><span class="line">        <span class="keyword">return</span> depth==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">removeInvalidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        inputStr = s;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">removedLabel</span><span class="params">(s.length(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> mask=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,mask);</span><br><span class="line">        vector&lt;string&gt; ansvec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v:m_ans)&#123;</span><br><span class="line">            ansvec.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ansvec.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            ansvec.<span class="built_in">push_back</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansvec;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//mask labels the removed part</span></span><br><span class="line">    <span class="function">string <span class="title">getNewStr</span><span class="params">(<span class="type">int</span> mask)</span></span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inputStr.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//keep the string where there is false labels</span></span><br><span class="line">            <span class="keyword">if</span>((mask &amp; (<span class="number">1</span>&lt;&lt;i))==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//if not labeled as removed</span></span><br><span class="line">                <span class="comment">//added into the ans</span></span><br><span class="line">                ans+=inputStr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//void dfs(int removedNum, int s, vector&lt;int&gt;&amp; removedLabel)&#123;</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> removedNum, <span class="type">int</span> s, <span class="type">int</span> mask)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;inputStr.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">if</span>(removedNum&gt;minUpdated)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//maybe add a cache here</span></span><br><span class="line">        string currStr;</span><br><span class="line">        <span class="keyword">if</span>(cache.<span class="built_in">count</span>(mask)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            currStr=cache[mask];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            currStr=<span class="built_in">getNewStr</span>(mask);</span><br><span class="line">            cache[mask]=currStr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//string currStr=getNewStr(removedLabel);</span></span><br><span class="line">        <span class="comment">//printf(&quot;currStr %s label %d %d\n&quot;,currStr.c_str(),removedLabel[0],removedLabel[1]);</span></span><br><span class="line">        <span class="keyword">if</span>(removedNum==minUpdated)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">valid</span>(currStr))&#123;</span><br><span class="line">                m_ans.<span class="built_in">insert</span>(currStr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(removedNum&lt;minUpdated)&#123;</span><br><span class="line">            <span class="comment">//removedNum &lt; minUpdated</span></span><br><span class="line">            <span class="comment">//update resutls</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">valid</span>(currStr))&#123;</span><br><span class="line">                m_ans.<span class="built_in">clear</span>();</span><br><span class="line">                m_ans.<span class="built_in">insert</span>(currStr);  </span><br><span class="line">                minUpdated = removedNum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//todo reorganize the code, the s position mayber larger than</span></span><br><span class="line">        <span class="comment">//length in previous section</span></span><br><span class="line">        <span class="keyword">if</span>(s&gt;=inputStr.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//trim cases</span></span><br><span class="line">        <span class="comment">//if letters </span></span><br><span class="line">        <span class="keyword">if</span>(inputStr[s]!=<span class="string">&#x27;(&#x27;</span> &amp;&amp; inputStr[s]!=<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//removedLabel[s] = false;</span></span><br><span class="line">            <span class="comment">//do not need to set, it is 0 initially</span></span><br><span class="line">            mask = (mask &amp; ~(<span class="number">1</span> &lt;&lt; s));</span><br><span class="line">            <span class="built_in">dfs</span>(removedNum,s+<span class="number">1</span>,mask);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;    </span><br><span class="line">            <span class="comment">//remove current or not</span></span><br><span class="line">            <span class="comment">//removedLabel[s]=1;</span></span><br><span class="line">            mask = (mask | (<span class="number">1</span>&lt;&lt;s));</span><br><span class="line">            <span class="comment">//do the dfs, removed current</span></span><br><span class="line">            <span class="built_in">dfs</span>(removedNum+<span class="number">1</span>,s+<span class="number">1</span>,mask);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//next is </span></span><br><span class="line">            <span class="comment">//removedLabel[s]=0;</span></span><br><span class="line">            mask = (mask &amp; ~(<span class="number">1</span>&lt;&lt;s));</span><br><span class="line">            <span class="type">char</span> c = inputStr[s];</span><br><span class="line">            <span class="comment">//skip the repeated elements</span></span><br><span class="line">            <span class="keyword">while</span>(s&lt;inputStr.<span class="built_in">length</span>() &amp;&amp; inputStr[s]==c) s++; <span class="comment">//if not take then don&#x27;t take it until the same char</span></span><br><span class="line">            <span class="built_in">dfs</span>(removedNum,s,mask);     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>394. Decode String</strong></p>
<p>We write this code into a recursion way, once we got the bracket, we do a recursion call. It actually use the bottom to up way to do the dfs</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">        string str = <span class="built_in">getSubstr</span>(s, <span class="number">0</span>, len, len);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">getSubstr</span><span class="params">(string&amp; s, <span class="type">int</span> l, <span class="type">int</span> len, <span class="type">int</span>&amp; rindex)</span></span>&#123;</span><br><span class="line">        string fullstr;</span><br><span class="line">        <span class="type">int</span> depth=<span class="number">0</span>;        </span><br><span class="line">        <span class="type">int</span> i=l;</span><br><span class="line">        <span class="type">int</span> repeat=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">            <span class="keyword">if</span>( s[i]==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                rindex=i;</span><br><span class="line">                repeat=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> fullstr;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i]&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">                fullstr+=s[i];</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> tempRepeat = (s[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; s[i<span class="number">-1</span>]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i<span class="number">-1</span>]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">//consider previous one only when</span></span><br><span class="line">                    <span class="comment">//there are adjacent digits</span></span><br><span class="line">                    repeat = repeat*<span class="number">10</span>+tempRepeat;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    repeat = tempRepeat;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            string tempstr;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                tempstr = <span class="built_in">getSubstr</span>(s,i+<span class="number">1</span>,len,rindex);</span><br><span class="line">                i=rindex+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;repeat;j++)&#123;</span><br><span class="line">                fullstr+=tempstr;</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fullstr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>79. Word Search</strong></p>
<p>The naive idea is to go through every cell and use each cell as the start position and then call the dfs, if find a specific path during the call, return the true and do not further do the dfs call. The operation to start the search one by one is a imporatant thinking perspective. We need to confirm the start position anyway.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; m_board;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; m_boardFlag;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m_rowNum;</span><br><span class="line">    <span class="type">int</span> m_colmNum;</span><br><span class="line">    string m_word;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        m_board = board;</span><br><span class="line">        m_word = word;</span><br><span class="line">        m_rowNum = board.<span class="built_in">size</span>();</span><br><span class="line">        m_colmNum = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        m_boardFlag = <span class="built_in">vector</span>(m_rowNum, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m_colmNum,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_rowNum;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m_colmNum;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==word[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="comment">//reset the flag</span></span><br><span class="line">                    m_boardFlag = <span class="built_in">vector</span>(m_rowNum, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m_colmNum,<span class="literal">false</span>));</span><br><span class="line">                    <span class="type">bool</span> find = <span class="built_in">dfs</span>(i,j,<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(find) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//start from r c find adjacent sequence match with word</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> windex)</span></span>&#123;</span><br><span class="line">        <span class="comment">//find the word</span></span><br><span class="line">        <span class="comment">//return</span></span><br><span class="line">        <span class="keyword">if</span>(windex==m_word.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//get out of the bound, return not found</span></span><br><span class="line">        <span class="keyword">if</span>(r&gt;=m_rowNum || r&lt;<span class="number">0</span> || c&gt;=m_colmNum || c&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//this cell is visited</span></span><br><span class="line">        <span class="keyword">if</span>(m_boardFlag[r][c]==<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//we may start to search word from the scratch for this</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment">//check current</span></span><br><span class="line">        <span class="comment">//windex ++ if current is equal</span></span><br><span class="line">        <span class="keyword">if</span>(m_board[r][c]==m_word[windex])&#123;</span><br><span class="line">            <span class="comment">//current one equal word index position</span></span><br><span class="line">            <span class="comment">//check the next</span></span><br><span class="line">            windex++;</span><br><span class="line">            m_boardFlag[r][c] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//right</span></span><br><span class="line">            <span class="type">bool</span> find = <span class="built_in">dfs</span>(r,c+<span class="number">1</span>,windex);</span><br><span class="line">            <span class="keyword">if</span>(find) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//left</span></span><br><span class="line">            find = <span class="built_in">dfs</span>(r,c<span class="number">-1</span>,windex);</span><br><span class="line">            <span class="keyword">if</span>(find) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//up</span></span><br><span class="line">            find = <span class="built_in">dfs</span>(r<span class="number">-1</span>,c,windex);</span><br><span class="line">            <span class="keyword">if</span>(find) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//down</span></span><br><span class="line">            find = <span class="built_in">dfs</span>(r+<span class="number">1</span>,c,windex);</span><br><span class="line">            <span class="keyword">if</span>(find) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//set current back, the current position is not ok</span></span><br><span class="line">            m_boardFlag[r][c] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//if all direaction fail false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                 </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>It is interesting to ask, if it is ok to use the bfs as a kernel to do the path finding. We can not use the bfs for this question, look at this exmaple:<code>[[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;E&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]] &quot;ABCESEEEFS&quot;</code> Since we need to set the label position of the cell to 1 if we put it into the queue, however, in this case, for the correct path, it need to go back to find the node in the higher layer that have been visited. However, these nodes have been visited. So we could not get correct answer anyway. Be careful about using the bfs, it is suitable for the case that there is the abstraction about the shortest path or the distance to the root node. And the node that is visited can not be visited anymore during the path search. If there is a cycle in the graph, it is not suitable to use the bfs.</p>
<p><strong>212. Word Search II</strong></p>
<p>There is time limit excedded issue if we just use the similar ideas compared with previous one, namely reuse the previous code and then add another for loop outside of it, since the list of the words can be really large (3*10^4).</p>
<p>The idea is to use a tire tree to extract the common part of the input list. The direactly using of the tire tree is similar to the auto typing when we search things. The keep point is that we use each edge to represent one of the 26 characters and also label the origianl word (if it exist) at the end of the searching path.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// using the Tire tree</span></span><br><span class="line"><span class="comment">// refer to huahua&#x27;s code for the tire tree</span></span><br><span class="line"><span class="comment">// this data structure saves the actual value</span></span><br><span class="line"><span class="comment">// and use the path to represents the which character it is</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TrieNode*&gt; nodes; <span class="comment">// children for this nodes</span></span><br><span class="line">    string rawWord; <span class="comment">// point to the original word</span></span><br><span class="line">    <span class="built_in">TrieNode</span>():<span class="built_in">nodes</span>(<span class="number">26</span>), <span class="built_in">rawWord</span>(<span class="string">&quot;&quot;</span>) &#123;&#125;; <span class="comment">//the edge represents the letter</span></span><br><span class="line">    ~<span class="built_in">TrieNode</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> node:nodes) <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; m_board;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; m_boardFlag;</span><br><span class="line">    set&lt;string&gt; m_ans;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m_rowNum;</span><br><span class="line">    <span class="type">int</span> m_colNum;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//make sure to fully use the trie tree</span></span><br><span class="line">        <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        TrieNode root;        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//put words into the tree</span></span><br><span class="line">        <span class="comment">//construct the tree</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word:words)&#123;</span><br><span class="line">            <span class="comment">//check each word</span></span><br><span class="line">            <span class="comment">//the root should always be the top level, all words should in same level</span></span><br><span class="line">            TrieNode* cur = &amp;root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c:word)&#123;</span><br><span class="line">                <span class="comment">//printf(&quot;c %c\n&quot;,c);</span></span><br><span class="line">                <span class="comment">//attebtion to this one make sure it is r reference</span></span><br><span class="line">                TrieNode*&amp; next = cur-&gt;nodes[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="comment">//if next is empty, there might be repeated letter in word</span></span><br><span class="line">                <span class="keyword">if</span>(next==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="comment">//printf(&quot;new node %c\n&quot;,c);</span></span><br><span class="line">                    next=<span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//if the cur is at the end of tree</span></span><br><span class="line">            cur -&gt; rawWord = word;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        m_board = board;</span><br><span class="line">        m_rowNum = board.<span class="built_in">size</span>();</span><br><span class="line">        m_colNum = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        m_boardFlag = <span class="built_in">vector</span>(m_rowNum, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m_colNum,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//call the dfs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_rowNum;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m_colNum;j++)&#123;</span><br><span class="line">                <span class="comment">//reset the flag, this is not necessary</span></span><br><span class="line">                <span class="comment">//m_boardFlag = vector(m_rowNum, vector&lt;bool&gt;(m_colNum,false));</span></span><br><span class="line">                <span class="built_in">dfs</span>(i,j,&amp;root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:m_ans)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, TrieNode* root)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check the boundry</span></span><br><span class="line">        <span class="keyword">if</span>(r&gt;=m_rowNum || r&lt;<span class="number">0</span> || c&gt;=m_colNum || c&lt;<span class="number">0</span> || m_boardFlag[r][c]==<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check current node</span></span><br><span class="line">        <span class="type">char</span> curr = m_board[r][c];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//choose specific path to get next node</span></span><br><span class="line">        TrieNode* next = root-&gt;nodes[curr-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if the next is nullptr, the trie root does not </span></span><br><span class="line">        <span class="comment">//contains this character, move to the next</span></span><br><span class="line">        <span class="comment">//current value not exist in the trie tree, there is not match</span></span><br><span class="line">        <span class="keyword">if</span>(next == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//for the subsequent part, current char</span></span><br><span class="line">        <span class="comment">//exist in the trie tree</span></span><br><span class="line">        <span class="comment">//check the current nodes</span></span><br><span class="line">        <span class="comment">//if at the ends of the words</span></span><br><span class="line">        <span class="comment">//printf(&quot;check word %s\n&quot;,next-&gt;rawWord.c_str());</span></span><br><span class="line">        <span class="keyword">if</span>(next-&gt;rawWord!=<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">            <span class="comment">//there is raw word till this stage</span></span><br><span class="line">            m_ans.<span class="built_in">insert</span>(next-&gt;rawWord);   </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//if there is actual word </span></span><br><span class="line">        <span class="comment">//check the whole trie tree</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//process the current node</span></span><br><span class="line">        m_boardFlag[r][c]=<span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//right</span></span><br><span class="line">        <span class="built_in">dfs</span>(r,c+<span class="number">1</span>,next);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//left</span></span><br><span class="line">        <span class="built_in">dfs</span>(r,c<span class="number">-1</span>,next);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//up</span></span><br><span class="line">        <span class="built_in">dfs</span>(r<span class="number">-1</span>,c,next);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//down</span></span><br><span class="line">        <span class="built_in">dfs</span>(r+<span class="number">1</span>,c,next);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//set the flag back</span></span><br><span class="line">        m_boardFlag[r][c]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>In the previous code, there is always repeated answer, so we use a set to store the results, the key issue is here <code>next-&gt;rawWord=&quot;&quot;;</code> If we set the rawWord to empty after visiting it each time, we can save lots of time, this is code that is less than 1000ms</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// using the Tire tree</span></span><br><span class="line"><span class="comment">// refer to huahua&#x27;s code for the tire tree</span></span><br><span class="line"><span class="comment">// this data structure saves the actual value</span></span><br><span class="line"><span class="comment">// and use the path to represents the which character it is</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TrieNode*&gt; nodes; <span class="comment">// children for this nodes</span></span><br><span class="line">    string rawWord; <span class="comment">// point to the original word</span></span><br><span class="line">    <span class="built_in">TrieNode</span>():<span class="built_in">nodes</span>(<span class="number">26</span>), <span class="built_in">rawWord</span>(<span class="string">&quot;&quot;</span>) &#123;&#125;; <span class="comment">//the edge represents the letter</span></span><br><span class="line">    ~<span class="built_in">TrieNode</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> node:nodes) <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; m_board;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; m_boardFlag;</span><br><span class="line">    vector&lt;string&gt; m_ans;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m_rowNum;</span><br><span class="line">    <span class="type">int</span> m_colNum;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//make sure to fully use the trie tree</span></span><br><span class="line">        <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        TrieNode root;        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//put words into the tree</span></span><br><span class="line">        <span class="comment">//construct the tree</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word:words)&#123;</span><br><span class="line">            <span class="comment">//check each word</span></span><br><span class="line">            <span class="comment">//the root should always be the top level, all words should in same level</span></span><br><span class="line">            TrieNode* cur = &amp;root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c:word)&#123;</span><br><span class="line">                <span class="comment">//printf(&quot;c %c\n&quot;,c);</span></span><br><span class="line">                <span class="comment">//attebtion to this one make sure it is r reference</span></span><br><span class="line">                TrieNode*&amp; next = cur-&gt;nodes[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="comment">//if next is empty, there might be repeated letter in word</span></span><br><span class="line">                <span class="keyword">if</span>(next==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="comment">//printf(&quot;new node %c\n&quot;,c);</span></span><br><span class="line">                    next=<span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//if the cur is at the end of tree</span></span><br><span class="line">            cur -&gt; rawWord = word;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        m_board = board;</span><br><span class="line">        m_rowNum = board.<span class="built_in">size</span>();</span><br><span class="line">        m_colNum = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        m_boardFlag = <span class="built_in">vector</span>(m_rowNum, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m_colNum,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//call the dfs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_rowNum;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m_colNum;j++)&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i,j,&amp;root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> m_ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, TrieNode* root)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check the boundry</span></span><br><span class="line">        <span class="keyword">if</span>(r&gt;=m_rowNum || r&lt;<span class="number">0</span> || c&gt;=m_colNum || c&lt;<span class="number">0</span> || m_boardFlag[r][c]==<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check current node</span></span><br><span class="line">        <span class="type">char</span> curr = m_board[r][c];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//choose specific path to get next node</span></span><br><span class="line">        TrieNode* next = root-&gt;nodes[curr-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if the next is nullptr, the trie root does not </span></span><br><span class="line">        <span class="comment">//contains this character, move to the next</span></span><br><span class="line">        <span class="comment">//current value not exist in the trie tree, there is not match</span></span><br><span class="line">        <span class="keyword">if</span>(next == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//for the subsequent part, current char</span></span><br><span class="line">        <span class="comment">//exist in the trie tree</span></span><br><span class="line">        <span class="comment">//check the current nodes</span></span><br><span class="line">        <span class="comment">//if at the ends of the words</span></span><br><span class="line">        <span class="comment">//printf(&quot;check word %s\n&quot;,next-&gt;rawWord.c_str());</span></span><br><span class="line">        <span class="keyword">if</span>(next-&gt;rawWord!=<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">            <span class="comment">//there is raw word till this stage</span></span><br><span class="line">            m_ans.<span class="built_in">push_back</span>(next-&gt;rawWord);</span><br><span class="line">            next-&gt;rawWord=<span class="string">&quot;&quot;</span>;         &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//if there is actual word </span></span><br><span class="line">        <span class="comment">//check the whole trie tree</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//process the current node</span></span><br><span class="line">        m_boardFlag[r][c]=<span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//right</span></span><br><span class="line">        <span class="built_in">dfs</span>(r,c+<span class="number">1</span>,next);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//left</span></span><br><span class="line">        <span class="built_in">dfs</span>(r,c<span class="number">-1</span>,next);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//up</span></span><br><span class="line">        <span class="built_in">dfs</span>(r<span class="number">-1</span>,c,next);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//down</span></span><br><span class="line">        <span class="built_in">dfs</span>(r+<span class="number">1</span>,c,next);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//set the flag back</span></span><br><span class="line">        m_boardFlag[r][c]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="Partition-DFS"><a href="#Partition-DFS" class="headerlink" title="Partition DFS"></a>Partition DFS</h3><h3 id="Naive-BFS"><a href="#Naive-BFS" class="headerlink" title="Naive BFS"></a>Naive BFS</h3><p><strong>17 Output all possible combinations.</strong></p>
<p>We basically need to output all the paths, each number represents a new level for each all possible nodes. Essentailly, there is a tree structure and it is good to use the bfs method to search all the tree and only put the results in vector at the last layer. We do not need to put the value in ans at the first several layers and we just need to put the value into the ans at the final layer. The code structure is same with the tree based version, the difference is that the node is not the actual tree node, it is just the imaginary tree node.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;    </span><br><span class="line">        <span class="type">int</span> len = digits.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//init dial table</span></span><br><span class="line">        map&lt;<span class="type">int</span>,vector&lt;string&gt;&gt; dialMap;</span><br><span class="line">        dialMap[<span class="number">2</span>]=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">        dialMap[<span class="number">3</span>]=&#123;<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;f&quot;</span>&#125;;</span><br><span class="line">        dialMap[<span class="number">4</span>]=&#123;<span class="string">&quot;g&quot;</span>,<span class="string">&quot;h&quot;</span>,<span class="string">&quot;i&quot;</span>&#125;;</span><br><span class="line">        dialMap[<span class="number">5</span>]=&#123;<span class="string">&quot;j&quot;</span>,<span class="string">&quot;k&quot;</span>,<span class="string">&quot;l&quot;</span>&#125;;</span><br><span class="line">        dialMap[<span class="number">6</span>]=&#123;<span class="string">&quot;m&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;o&quot;</span>&#125;;</span><br><span class="line">        dialMap[<span class="number">7</span>]=&#123;<span class="string">&quot;p&quot;</span>,<span class="string">&quot;q&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="string">&quot;s&quot;</span>&#125;;</span><br><span class="line">        dialMap[<span class="number">8</span>]=&#123;<span class="string">&quot;t&quot;</span>,<span class="string">&quot;u&quot;</span>,<span class="string">&quot;v&quot;</span>&#125;;</span><br><span class="line">        dialMap[<span class="number">9</span>]=&#123;<span class="string">&quot;w&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;y&quot;</span>,<span class="string">&quot;z&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//init the q</span></span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        <span class="type">int</span> initkey = digits[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:dialMap[initkey])&#123;</span><br><span class="line">            <span class="keyword">if</span>(len&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="comment">//construct all possible results at current layer</span></span><br><span class="line">            <span class="type">int</span> key = digits[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">//fetch the value at i-1 layer</span></span><br><span class="line">            <span class="type">int</span> qsize = q.<span class="built_in">size</span>(); </span><br><span class="line">            <span class="keyword">while</span>(qsize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                string preStr=q.<span class="built_in">front</span>();</span><br><span class="line">                <span class="comment">//put new nodes into the queue</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> v:dialMap[key])&#123;                </span><br><span class="line">                    string currStr = preStr+v;</span><br><span class="line">                    <span class="comment">//put value into the q if i&lt;len-1</span></span><br><span class="line">                    <span class="comment">//put the q value into the ans i ==len-1</span></span><br><span class="line">                    <span class="keyword">if</span>(i&lt;len<span class="number">-1</span>)&#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(currStr);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==(len<span class="number">-1</span>))&#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(currStr);</span><br><span class="line">                    &#125;                  </span><br><span class="line">                &#125;             </span><br><span class="line">                <span class="comment">//pop out old nodes</span></span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                qsize--;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>784. Letter Case Permutation</strong></p>
<p>This is the sample code, the framework is still same with previous one (dfs split the current string into the current part and the remaning part). We just classifiy the type of each elements can consider each operations gradually. the idea is still the recursion based on dfs manner.</p>
<p>The goal of algorithm is to find all the combinations, for each character which is a letter, it can be either a small case or large case, so there are two options for current layer</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCasePermutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        string curr;</span><br><span class="line">        <span class="built_in">dfs</span>(ans, s, curr, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;string&gt;&amp; ans, string&amp;sample, string curr, <span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==sample.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="comment">//all elements are pushed into the curr</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//if not letter, move to next</span></span><br><span class="line">        <span class="type">char</span> temp = sample[index];     </span><br><span class="line">        <span class="keyword">if</span>(temp&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; temp&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//if letter</span></span><br><span class="line">            <span class="comment">//dfs results with the change</span></span><br><span class="line">            <span class="type">char</span> letterNew = temp-<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            string currLower=curr+temp;</span><br><span class="line">            string currUpper=curr+letterNew;</span><br><span class="line">            <span class="built_in">dfs</span>(ans, sample, currLower, index+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(ans, sample, currUpper, index+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; temp&lt;=<span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">char</span> letterNew = temp-<span class="string">&#x27;A&#x27;</span> + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            string currUpper=curr+temp;</span><br><span class="line">            string currLower=curr+letterNew;</span><br><span class="line">            <span class="built_in">dfs</span>(ans, sample, currLower, index+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(ans, sample, currUpper, index+<span class="number">1</span>);            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//not letter</span></span><br><span class="line">            curr=curr+temp;</span><br><span class="line">            <span class="built_in">dfs</span>(ans, sample, curr, index+<span class="number">1</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="BFS-with-visited-flag"><a href="#BFS-with-visited-flag" class="headerlink" title="BFS with visited flag"></a>BFS with visited flag</h3><p>One key issue here is the defination of the visited flag, how to define it. There are two definations. The first one is that, once the node is checked, we assume it is visited. Another case is that, once the adjacent nodes around current nodes have been checked, we think it is visited. </p>
<p>The 126 is the case that visited nodes is checked out not</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c </span><br><span class="line">  \</span><br><span class="line">a - b</span><br></pre></td></tr></table></figure>

<p>For this case, if a and c are in the queue during the bst search, we then check the b and label b as visited. Then when we pop out the c from the queue, we do not further put the b into the queue, since it has been labeled as visited. In this case, the edge <code>c-&gt;b</code> is not checked. The 127 is a simple case for it. </p>
<p>Another case is check the node after the adjacent nodes is checked. In this case, the operation of setting the flag as true after checking all adjacent nodes. We also list the assocaited code in 127. For the 126 question, this is more suitable solution, since for the one critical nodes, it can be the adjacent node of multiple nodes, so we need to make sure every edge is visited. </p>
<p>In summary, if we need only search the shortest path, we can use the first defination, otherwise, if we need to record all possible path, we need to use the second defination about the visit flags.</p>
<p><strong>127. Word Ladder</strong></p>
<p>The <code>shortest</code> is a kind of key word to remind people to use the BFS. Although we can use dfs (maybe easy for programming), but it is easy to extends the time limit in general cases. If we look at the size of the input list, it is really large, so the dfs is easy to create a really deep recurtion tree.</p>
<p>This is the dfs version, for each time, we go through the list and find one wich is one different with the current one (this is time consuming)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;string&gt; m_wordList;</span><br><span class="line">    string m_beginWord;</span><br><span class="line">    string m_endWord;</span><br><span class="line">    <span class="type">int</span> m_bestPath = INT_MAX; <span class="comment">// do not account the start and the end</span></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; m_flag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">inlist</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> w:m_wordList)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w==m_endWord)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        m_wordList = wordList;</span><br><span class="line">        m_beginWord=beginWord;</span><br><span class="line">        m_endWord=endWord;</span><br><span class="line">        m_flag = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m_wordList.<span class="built_in">size</span>(),<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//make sure the end word is in list</span></span><br><span class="line">        <span class="type">bool</span> ifinlist = <span class="built_in">inlist</span>();</span><br><span class="line">        <span class="keyword">if</span>(ifinlist==<span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(beginWord,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(m_bestPath&gt;<span class="number">0</span> &amp;&amp; m_bestPath!=INT_MAX)&#123;</span><br><span class="line">            <span class="keyword">return</span> m_bestPath+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//function compare 1 letter diff</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">oneDiff</span><span class="params">(<span class="type">const</span> string&amp; str1, <span class="type">const</span> string&amp; str2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//can the str1 and str2 in different length</span></span><br><span class="line">        <span class="type">int</span> len1 = str1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> len2 = str2.<span class="built_in">length</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> lenDiff = <span class="built_in">abs</span>(len1-len2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(lenDiff&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> diff=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">min</span>(len1,len2);i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[i]!=str2[i])&#123;</span><br><span class="line">                diff++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(diff&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((diff+lenDiff)==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string curr, <span class="type">int</span> currPath)</span></span>&#123;</span><br><span class="line">        <span class="comment">//if wordsNum&gt;1</span></span><br><span class="line">        <span class="comment">//current word is one letter diff with endWord</span></span><br><span class="line">        <span class="comment">//return true</span></span><br><span class="line">        <span class="keyword">if</span>(currPath&gt;=<span class="number">1</span> &amp;&amp; curr == m_endWord)&#123;</span><br><span class="line">            m_bestPath = <span class="built_in">min</span>(m_bestPath,currPath);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check all avaliable words</span></span><br><span class="line">        <span class="comment">//this can be very large and up to 3000</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_wordList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m_flag[i])&#123;</span><br><span class="line">                <span class="comment">//this word have been used</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//word is not used</span></span><br><span class="line">            <span class="comment">//check if it is one letter diff with current</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">oneDiff</span>(curr,m_wordList[i]))&#123;</span><br><span class="line">                <span class="comment">//this one is a potential one</span></span><br><span class="line">                m_flag[i]=<span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(m_wordList[i],currPath+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//set flag back after dfs search</span></span><br><span class="line">                m_flag[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The reason that we need to use the visited flag is because there is a graph in the given data structure, we try to use the visited flag to avoid the repeated visit. This visit flag checking is usually happens at the step when we decide if we put the new nodes into the queue.</p>
<p>There are several small places we need to take care of. The idea of the pattern map, which represents the how we move to the next layer. (This idea comes from this <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=h9iTnkgv05E">video</a>). We enssentially use this data structure to construct a graph based on the input data. Understanding this idea is very important, we need to have a logical graph firstly (not the tree in this question) and then use bfs to search the distance.</p>
<ul>
<li><p>When processing status, one case is that when pushing the element into the queue, we label it as visited, another case is that when extract it from the queue, we label it as visited. If we label it as visited when we put things into the queue, otherwise, there is repeated path, we may take actual jumps between the brother nodes in one layer.</p>
</li>
<li><p>The ++ operation should be put at the position when one layer is finished processing instead of when there is new elements is extracted from the pattern.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check if the endword is in the list</span></span><br><span class="line">    <span class="type">bool</span> endExist = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : wordList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (v == endWord) &#123;</span><br><span class="line">        endExist = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (endExist == <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// end not exist</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build the dic (grpah) with the pattern</span></span><br><span class="line">    <span class="comment">// key is pattern, value is assocaited string</span></span><br><span class="line">    <span class="comment">// We can use this info to check the adjacent nodes in the graph each time</span></span><br><span class="line">    unordered_map&lt;string, set&lt;string&gt;&gt; patternMap;</span><br><span class="line">    string pattern;</span><br><span class="line">    wordList.<span class="built_in">push_back</span>(beginWord);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> word : wordList) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        pattern = word;</span><br><span class="line">        pattern[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        patternMap[pattern].<span class="built_in">insert</span>(word);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set&lt;string&gt; visited;</span><br><span class="line">    visited.<span class="built_in">insert</span>(beginWord);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bfs</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    queue&lt;string&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(beginWord);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">empty</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// visit current layer</span></span><br><span class="line">      <span class="comment">// for the new layer</span></span><br><span class="line">      <span class="type">int</span> qsize = q.<span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">while</span> (qsize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// get current</span></span><br><span class="line">        string currw = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        qsize--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check all patterns</span></span><br><span class="line">        <span class="comment">// get to the end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// check words in pattern map</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; currw.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">          pattern = currw;</span><br><span class="line">          pattern[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">auto</span> pattenw : patternMap[pattern]) &#123;</span><br><span class="line">            <span class="comment">//find the adjactent nodes based on the pattern we extracted</span></span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">find</span>(pattenw) == visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">              <span class="comment">// not exist</span></span><br><span class="line">              <span class="comment">// set flag when put things into the queue</span></span><br><span class="line">              <span class="comment">// if the word haved been used, we do not iterate it further</span></span><br><span class="line">              visited.<span class="built_in">insert</span>(pattenw);</span><br><span class="line">              q.<span class="built_in">push</span>(pattenw);</span><br><span class="line">              <span class="keyword">if</span> (pattenw == endWord) &#123;</span><br><span class="line">                <span class="comment">// the first finded one is the shortest one</span></span><br><span class="line">                <span class="comment">// we do not need to iterate all possibilities</span></span><br><span class="line">                <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// finsh processing one layer</span></span><br><span class="line">      res++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// did not get to the res</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This is the version of the code we set the flag after checking all adjacent nodes. There are some major differences compared with previous version</p>
<p>(1) We do not need to set the root node into the queue before bfs</p>
<p>(2) We check the visited status before the bfs checking</p>
<p>(3) We set the flag after checking the all status of the current nodes, the previous one is to check the flag in the for loop when check each status. we also check the flag here, we insert it only if it is not visited.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check if the endword is in the list</span></span><br><span class="line">    <span class="type">bool</span> endExist = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : wordList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (v == endWord) &#123;</span><br><span class="line">        endExist = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (endExist == <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// end not exist</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build the dic with the pattern</span></span><br><span class="line">    unordered_map&lt;string, set&lt;string&gt;&gt; patternMap;</span><br><span class="line">    string pattern;</span><br><span class="line">    wordList.<span class="built_in">push_back</span>(beginWord);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> word : wordList) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        pattern = word;</span><br><span class="line">        pattern[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        patternMap[pattern].<span class="built_in">insert</span>(word);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//only when the nodes are put into the queue, then labeled it as visited</span></span><br><span class="line">    set&lt;string&gt; visited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bfs</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    queue&lt;string&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(beginWord);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">empty</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// visit current layer</span></span><br><span class="line">      <span class="comment">// for the new layer</span></span><br><span class="line">      <span class="type">int</span> qsize = q.<span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">while</span> (qsize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// get current</span></span><br><span class="line">        string currw = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        qsize--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jump the first case</span></span><br><span class="line">        <span class="keyword">if</span>(visited.<span class="built_in">find</span>(currw) != visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">//this one is visited</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;            </span><br><span class="line"></span><br><span class="line">        <span class="comment">// check words in pattern map</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; currw.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">          pattern = currw;</span><br><span class="line">          pattern[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">auto</span> pattenw : patternMap[pattern]) &#123;</span><br><span class="line">              <span class="comment">// not exist</span></span><br><span class="line">              <span class="comment">// set flag when put things into the queue</span></span><br><span class="line">              <span class="comment">// if the word haved been used, we do not iterate it further</span></span><br><span class="line">              <span class="keyword">if</span>(pattenw==currw) <span class="keyword">continue</span>;</span><br><span class="line">              q.<span class="built_in">push</span>(pattenw);</span><br><span class="line">              <span class="keyword">if</span> (pattenw == endWord) &#123;</span><br><span class="line">                <span class="comment">// the first finded one is the shortest one</span></span><br><span class="line">                <span class="comment">// we do not need to iterate all possibilities</span></span><br><span class="line">                <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        visited.<span class="built_in">insert</span>(currw);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// finsh processing one layer</span></span><br><span class="line">      res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// did not get to the res</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>752. Open the Lock</strong></p>
<p>This is the typical bfs + flag question, this will be a typical one and can be solved with the common framework. We use the getAdjacent to get the possible adjacent nodes (<code>2*4</code> possibilities) at each step. All poissible nodes for next layer are stored in an array.</p>
<p>If the new one is the deadends(constrains giving by the question) or the node that have been visited previously. We do not visit them again. </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">getAdjacent</span><span class="params">(string curr, set&lt;string&gt;&amp; visited, set&lt;string&gt;&amp; deadSets)</span></span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            string strnew = curr;</span><br><span class="line">            <span class="comment">//back </span></span><br><span class="line">            <span class="type">char</span> back = curr[i]<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(curr[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                back = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            strnew[i] = back;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//check the deadends</span></span><br><span class="line">            <span class="keyword">if</span>(deadSets.<span class="built_in">find</span>(strnew) == deadSets.<span class="built_in">end</span>() &amp;&amp; visited.<span class="built_in">find</span>(strnew) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="comment">//not exist in dead end</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(strnew);</span><br><span class="line">            &#125;     </span><br><span class="line">                  </span><br><span class="line">            <span class="comment">//forward</span></span><br><span class="line">            <span class="type">char</span> next = curr[i]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(curr[i]==<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                next = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            strnew[i] = next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//check visited, if visited, do not push into the q</span></span><br><span class="line">            <span class="keyword">if</span>(deadSets.<span class="built_in">find</span>(strnew) == deadSets.<span class="built_in">end</span>() &amp;&amp; visited.<span class="built_in">find</span>(strnew) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="comment">//not visited</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(strnew);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">openLock</span><span class="params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//set to store the dead ends</span></span><br><span class="line">        <span class="function">set&lt;string&gt; <span class="title">deadSets</span><span class="params">(deadends.begin(),deadends.end())</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//a flag to label the visited nodes</span></span><br><span class="line">        <span class="comment">//visit flag only represents if the node is visited or not</span></span><br><span class="line">        set&lt;string&gt; visited;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//edge cases</span></span><br><span class="line">        <span class="keyword">if</span>(deadSets.<span class="built_in">find</span>(target)!=deadSets.<span class="built_in">end</span>() || deadSets.<span class="built_in">find</span>(<span class="string">&quot;0000&quot;</span>)!=deadSets.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">//if the target or start is in deadSets</span></span><br><span class="line">            <span class="comment">//could not find anyway</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(target==<span class="string">&quot;0000&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//bfs</span></span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        visited.<span class="built_in">insert</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//for current nodes</span></span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">empty</span>()==<span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="type">int</span> qsize = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(qsize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//get the front one</span></span><br><span class="line">                string curr = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                qsize--;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//compute the all possible adjacent nodes</span></span><br><span class="line">                <span class="comment">//merge the process of getAdjacent and deadSets/visited check </span></span><br><span class="line">                <span class="comment">//can improve the speed</span></span><br><span class="line">                vector&lt;string&gt; adjStrs = <span class="built_in">getAdjacent</span>(curr, deadSets, visited);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> v:adjStrs)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(v==target)&#123;</span><br><span class="line">                        <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//not exist in deadends and not visited</span></span><br><span class="line">                    visited.<span class="built_in">insert</span>(v);</span><br><span class="line">                    <span class="comment">//not the target, push into the queue</span></span><br><span class="line">                    <span class="comment">//printf(&quot;push %s\n&quot;,v.c_str());</span></span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    <span class="comment">//parent[v]=curr;</span></span><br><span class="line">                &#125;<span class="comment">//for all adjacents</span></span><br><span class="line">            &#125;<span class="comment">//while q size</span></span><br><span class="line">            <span class="comment">//update ans for each layer</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;<span class="comment">//while q empty</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//did not find target</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>818. Race Car</strong></p>
<p>The bfs part is similar with previous framework, there are two options for each step. The tricky part is the trimming operation. The nodes number is <code>2^k</code> if we do not do the trimming operation, which make the bfs operation become redoundant quickly. This question also shows another way to use the flag array. We basically code it based on customized way such as <code>pos_speed</code> in this question and put the coded str into the set. </p>
<p>Another strategy for this kind of problem is to use the dp programming. We do not disucss it here, bascially for each position, we need to consider how many possibilities can get to associated position.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//this is an example of customized node</span></span><br><span class="line"><span class="comment">//if we do not use the pair, we can define it by this way</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="built_in">Node</span> (<span class="type">int</span> pos, <span class="type">int</span> speed):<span class="built_in">m_pos</span>(pos),<span class="built_in">m_speed</span>(speed)&#123;&#125;;</span><br><span class="line">    <span class="type">int</span> m_pos;</span><br><span class="line">    <span class="type">int</span> m_speed;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Node&amp; obj) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>-&gt;m_pos &lt; obj.m_pos) || (<span class="keyword">this</span>-&gt;m_speed &lt; obj.m_speed)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">racecar</span><span class="params">(<span class="type">int</span> target)</span> </span>&#123;        </span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">//visited position (still exceeds the limitation)</span></span><br><span class="line">        </span><br><span class="line">        set&lt;string&gt; visited;</span><br><span class="line">        <span class="comment">//serilize the pair</span></span><br><span class="line">        visited.<span class="built_in">insert</span>(<span class="string">&quot;0_1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//bfs</span></span><br><span class="line">        <span class="comment">//the first of pair is pos</span></span><br><span class="line">        <span class="comment">//the second of pair is speed</span></span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">empty</span>()==<span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="comment">//process current layer</span></span><br><span class="line">            <span class="type">int</span> qsize = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(qsize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                qsize--;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//check move case</span></span><br><span class="line">                <span class="comment">//if A move</span></span><br><span class="line">                <span class="type">int</span> np = node.first+node.second;</span><br><span class="line">                <span class="type">int</span> ns = node.second*<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(np==target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//if current is in visited set</span></span><br><span class="line">                <span class="comment">//continue, do not further move it</span></span><br><span class="line">                <span class="function">Node <span class="title">nextA</span><span class="params">(np,ns)</span></span>;</span><br><span class="line">                string nextAKey = <span class="built_in">to_string</span>(np)+<span class="string">&quot;_&quot;</span>+<span class="built_in">to_string</span>(ns);</span><br><span class="line">                    <span class="comment">//if the position is positive, moving to the target is meaningful</span></span><br><span class="line">                    <span class="comment">//the second condition is not sure, we refer huahua&#x27;s code (1.5 is also ok)</span></span><br><span class="line">                    <span class="keyword">if</span>(np &gt; <span class="number">0</span> &amp;&amp; ns&lt; <span class="number">1.5</span>*target)&#123;</span><br><span class="line">                        <span class="comment">//do nothing</span></span><br><span class="line">                        q.<span class="built_in">push</span>(&#123;np,ns&#125;);</span><br><span class="line">                        <span class="comment">//printf(&quot;(%d,%d)\n&quot;,nextA.m_pos,nextA.m_speed);  </span></span><br><span class="line">                &#125;</span><br><span class="line">                  </span><br><span class="line">                <span class="comment">//if R move</span></span><br><span class="line">                <span class="comment">//pos does not change, do not need to check target</span></span><br><span class="line">                np = node.first;</span><br><span class="line">                <span class="keyword">if</span>(node.second&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    ns = <span class="number">-1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ns = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                string nextRKey = <span class="built_in">to_string</span>(np)+<span class="string">&quot;_&quot;</span>+<span class="built_in">to_string</span>(ns);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(visited.<span class="built_in">find</span>(nextRKey)==visited.<span class="built_in">end</span>())&#123;                </span><br><span class="line">                    <span class="comment">//only put the node into the queue if it is not visited</span></span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;np,ns&#125;);</span><br><span class="line">                    visited.<span class="built_in">insert</span>(nextRKey);</span><br><span class="line">                    <span class="comment">//printf(&quot;(%d,%d)\n&quot;,nextR.m_pos,nextR.m_speed);</span></span><br><span class="line">                &#125;</span><br><span class="line">                                </span><br><span class="line">            &#125;<span class="comment">//while current qsize</span></span><br><span class="line">            ans++;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="comment">//while q empty</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//does not find the target</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>542. 01 Matrix</strong></p>
<p>The naive thoughts that call the bfs that use each cell at the start position is easy to exceeds the time. Here we use the multisource bfs. The idea is simple, we just insert all source into the queue, and then start the normal bfs operation. Just assumping there are multiple trees, and if we want to do the bfs at the same time, we just need to put them into the queue. For each layer, the node we processed can be on the different tree, but they are in the same level. We need another metrix to record the distance and we just add 1 if we visit a new node.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_row;</span><br><span class="line">    <span class="type">int</span> m_col;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> X[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> Y[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> x&gt;=<span class="number">0</span> &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; x&lt;m_row &amp;&amp; y&lt;m_col;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat) &#123;</span><br><span class="line">        <span class="comment">//range the matrix</span></span><br><span class="line">        <span class="comment">//for each position</span></span><br><span class="line">        </span><br><span class="line">        m_row=mat.<span class="built_in">size</span>();</span><br><span class="line">        m_col=mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(m_row, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m_col,<span class="number">-1</span>));   </span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m_col;j++)&#123;</span><br><span class="line">                <span class="comment">//put the case with 0 value into the queue</span></span><br><span class="line">                <span class="keyword">if</span>(mat[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(i,j));</span><br><span class="line">                    ans[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;         </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//start the bfs</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> cr = p.first;</span><br><span class="line">            <span class="type">int</span> cc = p.second;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//do not need to consider layer explicitly</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="type">int</span> nr = cr+X[i];</span><br><span class="line">                <span class="type">int</span> nc = cc+Y[i];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">valid</span>(nr,nc) &amp;&amp; ans[nr][nc]==<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="comment">//start to propagate from the source</span></span><br><span class="line">                    ans[nr][nc]=ans[cr][cc]+<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;nr,nc&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="BFS-DFS"><a href="#BFS-DFS" class="headerlink" title="BFS+DFS"></a>BFS+DFS</h3><p><strong>126. Word Ladder II</strong></p>
<p>Compared with the 127, this question requires us to print out the shortest path in explicit way. For bfs, we only remember the distance and the link between two edges, but it does not keep the whole path. We need to use the dfs to trace the whole path. For each time of checking the adjacent nodes, we put them into a map that store the relationship. The key of the map is the current node, the value of the map is a set to store the parent node of the current one.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">findLadders</span>(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)&#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; pathAns;</span><br><span class="line">    <span class="comment">// check if the endword is in the list</span></span><br><span class="line">    <span class="type">bool</span> endExist = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : wordList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (v == endWord) &#123;</span><br><span class="line">        endExist = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (endExist == <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// end not exist</span></span><br><span class="line">      <span class="keyword">return</span> pathAns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build the dic with the pattern</span></span><br><span class="line">    unordered_map&lt;string, set&lt;string&gt;&gt; patternMap;</span><br><span class="line">    string pattern;</span><br><span class="line">    wordList.<span class="built_in">push_back</span>(beginWord);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> word : wordList) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        pattern = word;</span><br><span class="line">        pattern[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        patternMap[pattern].<span class="built_in">insert</span>(word);</span><br><span class="line">        <span class="comment">// printf(&quot;build graph pattern %s word</span></span><br><span class="line">        <span class="comment">// %s\n&quot;,pattern.c_str(),word.c_str());</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check graph</span></span><br><span class="line">    </span><br><span class="line">    set&lt;string&gt; visited;</span><br><span class="line">    <span class="comment">// bfs</span></span><br><span class="line">    <span class="comment">// key is the current nodes</span></span><br><span class="line">    <span class="comment">// value is the parrent node</span></span><br><span class="line">    unordered_map &lt;string, set&lt;string&gt;&gt; pathRecord;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    queue&lt;string&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(beginWord);</span><br><span class="line">    <span class="type">int</span> bestRes = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">empty</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// visit current layer</span></span><br><span class="line">      <span class="comment">// for the new layer</span></span><br><span class="line">      <span class="comment">// if jump to the wordEnd direactly the res is 1</span></span><br><span class="line">      <span class="type">int</span> qsize = q.<span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">while</span> (qsize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// get current</span></span><br><span class="line">        string currw = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        qsize--;</span><br><span class="line">        <span class="keyword">if</span>(visited.<span class="built_in">find</span>(currw)!=visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">//this node is visited previously</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        visited.<span class="built_in">insert</span>(currw);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//printf(&quot;currw %s remain num %d\n&quot;, currw.c_str(), qsize);</span></span><br><span class="line">        <span class="keyword">if</span> (currw == endWord) &#123;</span><br><span class="line">        	<span class="comment">// the first finded one is the shortest one</span></span><br><span class="line">          <span class="comment">// we do not need to iterate all possibilities</span></span><br><span class="line">          <span class="comment">// update the path once find it</span></span><br><span class="line">          bestRes = <span class="built_in">min</span>(bestRes,res);</span><br><span class="line">          vector&lt;string&gt; path;</span><br><span class="line">          path.<span class="built_in">push_back</span>(endWord);</span><br><span class="line">          <span class="built_in">getPathDfs</span>(endWord,beginWord,path,pathAns,pathRecord,<span class="number">1</span>,bestRes);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// check all patterns</span></span><br><span class="line">        <span class="comment">// get to the end</span></span><br><span class="line">        <span class="comment">// check words in pattern map</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; currw.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">          pattern = currw;</span><br><span class="line">          pattern[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">auto</span> pattenw : patternMap[pattern]) &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;pattern %s pattenw</span></span><br><span class="line">            <span class="comment">// %s\n&quot;,pattern.c_str(),pattenw.c_str());</span></span><br><span class="line">            <span class="comment">//if (pathRecord[pattenw].find(pattenw) == pathRecord[pattenw].end()) &#123;</span></span><br><span class="line">              <span class="keyword">if</span>(visited.<span class="built_in">find</span>(pattenw) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">              q.<span class="built_in">push</span>(pattenw);</span><br><span class="line">              <span class="keyword">if</span>(currw!=pattenw)&#123;</span><br><span class="line">                  <span class="comment">//do not insert self</span></span><br><span class="line">                  <span class="comment">//printf(&quot;insert %s\n&quot;,currw.c_str());</span></span><br><span class="line">                  pathRecord[pattenw].<span class="built_in">insert</span>(currw);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="comment">// after while</span></span><br><span class="line">      <span class="comment">// finsh processing one layer</span></span><br><span class="line">      res++;</span><br><span class="line">      <span class="keyword">if</span>(res&gt;bestRes)&#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pathAns;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">getPathDfs</span><span class="params">(string current, string&amp; beginStr, vector&lt;string&gt;&amp; path, vector&lt;vector&lt;string&gt;&gt;&amp; ans, unordered_map &lt;string, set&lt;string&gt;&gt;&amp; pathRecord, <span class="type">int</span> layer, <span class="type">int</span> bestLayer)</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(layer&gt;bestLayer)&#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(current == beginStr)&#123;</span><br><span class="line">          <span class="comment">//put the path into the results</span></span><br><span class="line">          vector&lt;string&gt; revPath = path;</span><br><span class="line">          <span class="built_in">reverse</span>(revPath.<span class="built_in">begin</span>(),revPath.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">          ans.<span class="built_in">push_back</span>(revPath);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//for current node</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v:pathRecord[current])&#123;</span><br><span class="line">            <span class="comment">//next dfs</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(v);</span><br><span class="line">            <span class="built_in">getPathDfs</span>(v,beginStr,path,ans,pathRecord, layer+<span class="number">1</span>, bestLayer);</span><br><span class="line">            <span class="comment">//set back</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Binary-search"><a href="#Binary-search" class="headerlink" title="Binary search"></a>Binary search</h3><h3 id="Accelartion-by-map"><a href="#Accelartion-by-map" class="headerlink" title="Accelartion by map"></a>Accelartion by map</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/06/11/Algorithm-9-Search/" data-id="clcnv8qbf000davjr61qy8bdi" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
 
<script src="/jquery/jquery.min.js"></script>

  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2022/06/13/Cuda-programming-1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          Cuda programming (1)
        
      </div>
    </a>
  
  
    <a href="/2022/06/11/Mac-Story/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Mac Story</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Key-techniques-and-considerations"><span class="toc-number">1.</span> <span class="toc-text">Key techniques and considerations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Naive-DFS-UpToBottom-Combination"><span class="toc-number">2.</span> <span class="toc-text">Naive DFS-UpToBottom-Combination</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Naive-DFS-UpToBottom-Permutation"><span class="toc-number">3.</span> <span class="toc-text">Naive DFS-UpToBottom-Permutation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Naive-DFS-UpToBottom-Expression"><span class="toc-number">4.</span> <span class="toc-text">Naive DFS-UpToBottom-Expression</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Partition-DFS"><span class="toc-number">5.</span> <span class="toc-text">Partition DFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Naive-BFS"><span class="toc-number">6.</span> <span class="toc-text">Naive BFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFS-with-visited-flag"><span class="toc-number">7.</span> <span class="toc-text">BFS with visited flag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFS-DFS"><span class="toc-number">8.</span> <span class="toc-text">BFS+DFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-search"><span class="toc-number">9.</span> <span class="toc-text">Binary search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Accelartion-by-map"><span class="toc-number">10.</span> <span class="toc-text">Accelartion by map</span></a></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2023 zhe&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;godenwangzhe@gmail.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  



 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>