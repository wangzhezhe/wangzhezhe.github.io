<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Algorithm(9) Search (BFS, DFS) | AverageMind</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Find particular properties based on the abstracted decision tree or abstracted graph.">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithm(9) Search (BFS, DFS)">
<meta property="og:url" content="http://yoursite.com/2022/06/12/Algorithm-9-Search-BFSDFS/index.html">
<meta property="og:site_name" content="AverageMind">
<meta property="og:description" content="Find particular properties based on the abstracted decision tree or abstracted graph.">
<meta property="og:locale">
<meta property="article:published_time" content="2022-06-12T03:47:41.000Z">
<meta property="article:modified_time" content="2023-11-24T00:26:39.053Z">
<meta property="article:author" content="zhe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="AverageMind" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-165927341-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
<!-- Google adds -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5642436380582343"
     crossorigin="anonymous">
</script>
<!-- End Google adds -->




<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AverageMind</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Algorithm-9-Search-BFSDFS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/06/12/Algorithm-9-Search-BFSDFS/" class="article-date">
  <time datetime="2022-06-12T03:47:41.000Z" itemprop="datePublished">2022-06-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Algorithm(9) Search (BFS, DFS)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>Find particular properties based on the abstracted decision tree or abstracted graph. </p>
<span id="more"></span>

<p>The input data is not the explicit tree with Tree node for questions listed in this blog. For the string structure, it may use some ideas like sliding window with loer bound and upper bound as the mechanism to search things, we do not list them here, we mainly list the question with the <strong>decision tree or graph in an logical way</strong> but the <strong>input is not the not the explicit tree structure</strong>.</p>
<table>
<thead>
<tr>
<th>Input data</th>
<th>DFS<br>(up to bottom)</th>
<th>DFS<br>(bottom to up)</th>
<th>BFS with visited flag and levelSize</th>
<th>BFS+DFS</th>
<th>BFS+Sorting</th>
<th>BFS multi sources</th>
</tr>
</thead>
<tbody><tr>
<td>single number</td>
<td>(combination)<br>22</td>
<td></td>
<td>818</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>array of numbers</td>
<td>(combination)<br>39,40,77<br>78,90,216<br>(permuataion)<br> 46,47,996</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>string</td>
<td>(permutation)784<br>(expression)<br>856,726,301 <br> 282 (partition) 842</td>
<td>(expression) 394 (partition,expression) 241</td>
<td>752</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2d Array</td>
<td>943,37,51,52<br> 79,212,698(partition,mem) <br> partition: 93, 131</td>
<td></td>
<td>17,542(multisource) 127, 1091</td>
<td>126</td>
<td>675</td>
<td>934</td>
</tr>
</tbody></table>
<h3 id="Key-techniques-and-considerations"><a href="#Key-techniques-and-considerations" class="headerlink" title="Key techniques and considerations"></a>Key techniques and considerations</h3><ul>
<li><p>Extracting decision tree from the actual problem. One difficulty with the search problem is that we need to extract the decision tree logically from different problem contexts. Typical scenarios are 1&gt; the binary tree type, which decide add or not add current character. Each node represent choose or not choose here 2&gt; Each node represents an actual character as the tree node, such as the permulation problems or combination of different cases. 4&gt; Each intermediat node can represents the path, or part of the answer, such as 17, when moving to the leaf node, then inserting answer. 5&gt; Each node represents the derived results about the given input, a little bit similar to the reduction opetaion, such as 241, the resutls can be a set contains all possible solutions.</p>
</li>
<li><p>Using DFS or BFS, we can decide to use BFS or DFS from several aspects:</p>
<ol>
<li><p>For the tree node expression, the BFS case might need to use a customized tree node (which is rarely used in leetcode questions), usually use the <strong>pair or tuple</strong> if we need multiple variables in the tree node. For the DFS code, there are less restrictions since we basically hide the tree node inexplicitly in the function call. We can transfer the necessary variables used in each call by function parameters. We can also set some varaibles as the class variables to avoid transfering them by tree node and simplify the code a little bit.</p>
</li>
<li><p>Time complexity and if there is explicit layered structure. Although both the time compexity is O(V+E), the DFS is suitable for the narrow long tree, ans the BFS is suitable for the wide and short tree. In practical case, we may need to evaluate the data scale of the leetcode question, this may decide which algorithm is used for the giving data sets. This is tricky and is easy to be neglected when we start to code in in a rush without considering time compexity in advance carefully.</p>
<p>If the question shows an obvious layered structure, the BFS can be more approporiate. For example, we find the minimal path with the particular constrians, we use the BFS, once find the path, we return it direactly. These type of questions are typical BFS style, and the BFS can ususlly save more efficient for solving these type of questions.</p>
<p>BFS is more approporiate for the question with the abstraction of the distance or shortest path. We try to find a shortest path from the root. For the question there is a cycle, the BFS might be suitable. Since there is no unique layered structure in the case where there is cycle, and the level can be different if we go through along the different path (such as 79). </p>
</li>
<li><p>For the DFS solution, pay attention that if we need return sth from the child tree. Namely make sure which is more convenient, either top to bottom operation (the previous informaion in the path can be used to determin the subsequent nodes in the path) or bottom to up operation. The core idea is to make sure what are computation processed in each node (is it merging two results from subtree or divide the current results to two subtree). It is worth noting that, for the bottom to up case, we can only use the DFS since it keep the status of the current node, so we can update the status when getting back results from the subtree. For the BFS, it just pop the parent out during the traverse process and we can not further update the previous status of the nodes. For the DFS case, there are <strong>three typical design</strong>: (a) Check all solutions and return void, put the valid path into a separate ans (b) Return true or false, we only need to find one path in this case, if we find the valid path, just return true (such as 37) (c) Return a specific value for each dfs call, maybe a reduced integer or more complex results such as a set. </p>
</li>
<li><p>Set back the status. It is important to always check if we set the status back for the dfs operation. For example, a&gt; when we find specific path, remember to pop the current node back from the ans <strong>if we insert it for the current layer</strong> (make sure the <code>pop_back</code> match with the <code>insert</code>, otherwise, there might be the memory issue). b&gt; The status can also be the flag variable that label if a specific character is visited or not. c&gt; In the for loop scenarios, we need to make sure the status if set back to the parent case before calling the dfs operations each time.</p>
</li>
</ol>
<p>If there is no difference between the aspects discussed above, we can either use BFS or DFS. And using DFS might be more easier from coding’s perspective if we write it into a recursive way instead of using a stack.</p>
</li>
<li><p>One typical type of question based on dfs or backtracking, 77 and 282 are two typical one (how current solution can come from previous solutions in small scale). The general framework for decomposing is to use a for loop, and each time in the for loop for processing element, the principle is the start position or end position of the string. For 77, we compute all combination, the start position is the root node, the end position can be each element in the string. For 282, we extract all possible operand, the start position of operand can be current index and the end position can be 1 to the end of the whole string.</p>
</li>
<li><p>TODO, two basic use case for bfs, the shortest path, the visited flag(no flag, might be the infinity loop in matrix search) , the queue size is the number of element in current layer !! 675 is good one that includes all typical problems. </p>
</li>
<li><p>Commonly used debug strategy. This part of question is error prone and some small type of condition error can lead to totally different results. Start from the small scale case or print out the traverse path explicitly are commonly used strategies.</p>
</li>
<li><p>Commonly used optimization strategy or trimming strategy. Sort the input array. Using flag to label the status of associated elements. Using map to memorize existing path (if the key and values are clear). Avoid the unnecessary string copy.</p>
</li>
<li><p>Ensentially the bfs or dfs questions discussed this part can process the unweighted graph. For the question which can be abstracted as the weighted graph, we need to use more complex mechanism to do that such as the dp method to acclerate the searching process (such as dp approach of the 943), refer to this <a target="_blank" rel="noopener" href="https://zxi.mytechroad.com/blog/searching/leetcode-675-cut-off-trees-for-golf-event/">https://zxi.mytechroad.com/blog/searching/leetcode-675-cut-off-trees-for-golf-event/</a>, when there is no new node, then layer ++, we can save one variable by this way, otherwise, we need to save it in the bfs node each time we traverse the tree. (this is really important), maybe using 1091 as a templaete question </p>
</li>
<li><p>Be careful about using the <code>vector&lt;bool&gt;</code> when you need to use a flag array. There are lots of discussion online, you may just use the <code>vector&lt;int&gt;</code> for simplicity or use the bit mask if the flag length is fixed. Using the <code>vector&lt;bool&gt;</code> can slow down the your code heavily (a least 10x times slower compared with usinig the <code>vector&lt;int&gt;</code>) 996 is a good example (three important conditions) to discuss about how to set the flag to make sure how the same node can be visited once in the same level.</p>
</li>
<li><p>A tip for checking the associated elements in 2d case. We might check the element at the different direaction such as up down left and right even for slash direaction sometimes, instead of go through each dimention separately, the good way is to initilize a 2d vector, such as <code>(-1,1),(1,-1)...</code> , in cpp it is <code>vector&lt;vector&lt;int&gt;&gt; dir = &#123;&#123;-1,1&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;1,-1&#125;&#125;;</code> then we use one loop to range this vector and adjust the x and y coordinates accordingly. This method is more simple to check the different direction of the 2d grid (Related question: 51).</p>
</li>
</ul>
<h3 id="Naive-DFS-UpToBottom-Combination"><a href="#Naive-DFS-UpToBottom-Combination" class="headerlink" title="Naive DFS-UpToBottom-Combination"></a>Naive DFS-UpToBottom-Combination</h3><p>The nature of the combination is the cartision product, we may need to have an idea about the set. Then the results of the combination might be to do the cartision products between different sets. It is important to figure out what are avalible set for some questions with complex background.</p>
<p><strong>39. Combination Sum</strong></p>
<p>This is the recursion version, which is really fast. For this recursion version based on dfs, the pop out operation at the end of dfs call is really important. Sorting the input array is an important techniques, sometimes, it can trim the searching tree (when the target value is negative one we trim the tree). The key idea to make sure that the elements can be used multiple times is that for each step of creating the children node, we go through all possible options no matter it is visited or not.</p>
<p>Another key point is that, if we do not use the sort, we may have repeated resutls such as <code>[2,3,3] and [3,2,3]</code>. From the implementaion perspective, using the remain value, and we decrease it gradually (instead of sum value) can be more convenient. Otherwise, we need to check if the current path exists in the ans set (we need to sort the array and check back and forth, which is redundant)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">    <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">dfs</span>(candidates, target, <span class="number">0</span>, cur, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; cur, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans)</span></span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s;i&lt;candidates.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(candidates[i]&gt;target)&#123;</span><br><span class="line">                <span class="comment">//current path not valid</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target-candidates[i], i, cur, ans);</span><br><span class="line">            <span class="comment">//set back to original status</span></span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>We can also use the BFS for this simple context, but for this question, there is no obvious benifits for using the BFS, since we need to search all possible solutions. However, it needs some difficuties to process the intermidiate node. Using the targetNew value as the distinction for different strategies is important. (how to define the control block is important)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="built_in">Node</span>(vector&lt;<span class="type">int</span>&gt; path, <span class="type">int</span> target, <span class="type">int</span> index) : <span class="built_in">m_path</span>(path), <span class="built_in">m_target</span>(target), <span class="built_in">m_index</span>(index)&#123;&#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; m_path;</span><br><span class="line">    <span class="type">int</span> m_target;</span><br><span class="line">    <span class="type">int</span> m_index;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">    queue&lt;Node&gt; q;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="comment">//avoid the repeated answer such as [2,3,3] and [3,2,3]</span></span><br><span class="line">    <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> len = candidates.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// init the q</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="type">int</span> v = candidates[i];</span><br><span class="line">      <span class="type">int</span> targetnew = target - v;</span><br><span class="line">      <span class="function">Node <span class="title">d</span><span class="params">(&#123;v&#125;, targetnew, i)</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (targetnew &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(d);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetnew == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;v&#125;);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (q.<span class="built_in">empty</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="type">int</span> levelSize = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// go through the queue</span></span><br><span class="line">        <span class="keyword">while</span> (levelSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          Node node = q.<span class="built_in">front</span>();</span><br><span class="line">          <span class="comment">//there should not be the i</span></span><br><span class="line">          <span class="comment">//it should be the value of the parent</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> j = node.m_index; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="type">int</span> vnew = candidates[j];</span><br><span class="line">            <span class="type">int</span> targetNew = node.m_target - vnew;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; pathNew = node.m_path;</span><br><span class="line">            pathNew.<span class="built_in">push_back</span>(vnew);</span><br><span class="line">            <span class="comment">// push the satiafied results into the ans</span></span><br><span class="line">            <span class="comment">// push the valid results into the next level</span></span><br><span class="line">            <span class="keyword">if</span> (targetNew &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="function">Node <span class="title">nodnew</span><span class="params">(pathNew, targetNew, j)</span></span>;</span><br><span class="line">              q.<span class="built_in">push</span>(nodnew);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetNew == <span class="number">0</span>) &#123;</span><br><span class="line">              ans.<span class="built_in">push_back</span>(pathNew); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// targetNew &lt; 0</span></span><br><span class="line">            <span class="comment">// do nothing for this case</span></span><br><span class="line">            <span class="comment">// do not push subsequent nodes</span></span><br><span class="line">          &#125;</span><br><span class="line">          q.<span class="built_in">pop</span>();</span><br><span class="line">          levelSize--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>40. Combination Sum II</strong></p>
<p>This one is similar with previous one, but the only difference is that the element is not unique in the input string, we add some constrains to avoid the repeated ans. The sorting operation is still necessary, we just skip the current element if it has been visited.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; curr;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(ans,candidates,<span class="number">0</span>,target,curr, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans, vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> start, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; curr, <span class="type">bool</span> firstlayer)</span></span>&#123;</span><br><span class="line">        <span class="comment">//dfs children</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;candidates.<span class="built_in">size</span>();i++)&#123; </span><br><span class="line">            <span class="comment">// if i is in visited, jump</span></span><br><span class="line">            <span class="comment">// attention, it is the i&gt;start here</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;start &amp;&amp; candidates[i]==candidates[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> targetNew = target-candidates[i];</span><br><span class="line">            <span class="keyword">if</span>(targetNew&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(targetNew==<span class="number">0</span>)&#123;</span><br><span class="line">                curr.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(curr);</span><br><span class="line">                curr.<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//targetNew &gt;0</span></span><br><span class="line">                <span class="comment">//visit current node</span></span><br><span class="line">                curr.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">                <span class="comment">//dfs</span></span><br><span class="line">                <span class="built_in">dfs</span>(ans,candidates,i+<span class="number">1</span>,targetNew, curr, <span class="literal">false</span>);</span><br><span class="line">                curr.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>77. Combinations</strong></p>
<p>The idea is similar with previous one. Be careful the meaning of the n and k. This can be viewed as the basic one for this type of question. Using the dfs can make things much more easier. For the first layer, there are n possibilites, and then the next layer, there is n-1 combinations.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">        //k numbers</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        vector&lt;int&gt; curr;</span><br><span class="line">        //in the range of 1 to n</span><br><span class="line">        dfs(ans, curr, 1, k, n);</span><br><span class="line">        return ans;        </span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp;ans, vector&lt;int&gt;&amp;curr, int s, int k, int n)&#123;  </span><br><span class="line">        int currsize = curr.size();</span><br><span class="line">        if(currsize==k)&#123;</span><br><span class="line">            ans.push_back(curr);</span><br><span class="line">            //do not go to a further depth</span><br><span class="line">            return;</span><br><span class="line">        &#125;     </span><br><span class="line">        for(int i=s;i&lt;=n;i++)&#123;</span><br><span class="line">            curr.push_back(i);</span><br><span class="line">            dfs(ans, curr, i+1, k, n);</span><br><span class="line">            curr.pop_back();              </span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>78. Subsets</strong> </p>
<p>This is also comparatively easy and we can use the similar ideas to solve this questions. The difference is that is stores the results into the ans for every possibilities. For previous quesitons, it stores the value only when it satisfies specific constraints. This one is more generous without specific constraints.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">//the number in sets can be 1 to n</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">        <span class="built_in">dfs</span>(ans, cur, nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;ans, vector&lt;<span class="type">int</span>&gt;&amp;curr, vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> s)</span></span>&#123;       </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            curr.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">//for each possible results, put into ans</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(curr);</span><br><span class="line">            <span class="built_in">dfs</span>(ans,curr,nums,i+<span class="number">1</span>);</span><br><span class="line">            curr.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>90. Subsets II</strong></p>
<p>There are some difference, it contains the repeated elements in queue, and results should not be repeative. We can solve this using the similar techniques used in 40</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">//the number in sets can be 1 to n</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">        <span class="built_in">dfs</span>(ans, cur, nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;ans, vector&lt;<span class="type">int</span>&gt;&amp;curr, vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> s)</span></span>&#123;       </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;s &amp;&amp; nums[i]==nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">//for each possible results, put into ans</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(curr);</span><br><span class="line">            <span class="built_in">dfs</span>(ans,curr,nums,i+<span class="number">1</span>);</span><br><span class="line">            curr.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>216. Combination Sum III</strong></p>
<p>There are not much differences compred with previous type, we put the curr into the ans when the constraints are satisfied.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="comment">//n is the targeted value</span></span><br><span class="line">        <span class="comment">//k represents the list from 1 to k </span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; curr;</span><br><span class="line">        <span class="built_in">dfs</span>(ans, curr, <span class="number">1</span>, k, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans,vector&lt;<span class="type">int</span>&gt;&amp; curr, <span class="type">int</span> s, <span class="type">int</span> k, <span class="type">int</span> target)</span></span>&#123;      </span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span> &amp;&amp; curr.<span class="built_in">size</span>()==k)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s;i&lt;=<span class="number">9</span>;i++)&#123;      </span><br><span class="line">            <span class="type">int</span> targetnew = target-i;</span><br><span class="line">            <span class="keyword">if</span>(targetnew&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//do not further go through along this path</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;        </span><br><span class="line">            <span class="comment">//for case targetnew &gt;0 or ==0 using dfs</span></span><br><span class="line">            <span class="comment">//we list the return point at the begining of the dfs</span></span><br><span class="line">            <span class="comment">//it can simplify the code a little bit compared with </span></span><br><span class="line">            <span class="comment">//processing every if condition separately</span></span><br><span class="line">            curr.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">dfs</span>(ans,curr,i+<span class="number">1</span>,k,targetnew);</span><br><span class="line">            curr.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>22. Generate Parentheses</strong></p>
<p>Evey node can be the left or right parentheses, and then we trim some results. From the top to bottom, the final path from the root to the leaf node is the actual ans we need to record. We can only place the right parathesis if the count of the left parathesis is larger than 0.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> totalLen=<span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        totalLen=n*<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">helper</span>(ans, <span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(vector&lt;string&gt;&amp; ans, string str, <span class="type">int</span> leftc)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> strlen = str.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(strlen == totalLen &amp;&amp; leftc==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//put string into ans</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(strlen&lt;totalLen)&#123;</span><br><span class="line">            <span class="comment">//can put leftc anyway, left child</span></span><br><span class="line">            <span class="built_in">helper</span>(ans,str+<span class="string">&quot;(&quot;</span>,leftc+<span class="number">1</span>);                </span><br><span class="line">            <span class="keyword">if</span>(leftc&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// can put right if there is remaining leftc</span></span><br><span class="line">                <span class="comment">// left child</span></span><br><span class="line">                <span class="built_in">helper</span>(ans,str+<span class="string">&quot;)&quot;</span>,leftc<span class="number">-1</span>);</span><br><span class="line">            &#125;              </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>37. Sudoku Solver</strong></p>
<p>the idea of checking the conflicts is just check it from the 1-9 and keep calling the next level, try to set the cell to a dot if there is no possible results. return the true if all cells are filled in.</p>
<p>The logic is not complex but it sill take me some time to figure it out. Originally we did not add return true or false, so it basically search all possibilities even if we find a valid results. The idea here is that we return it immediately if we find a valid ans. For the case when there is number at a specific position, we also need to add the return true or false.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// assume i and j is less then 9</span></span><br><span class="line">  <span class="comment">// assume value is from 1 to 9</span></span><br><span class="line">  <span class="comment">// the current one is .</span></span><br><span class="line">  <span class="comment">// make sure what are possible options for specific set</span></span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getOptions</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> column, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> boardDim = <span class="number">9</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="comment">// filter row i</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; boardDim; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j == column) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (board[row][j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// filter the conflict value</span></span><br><span class="line">      flag[board[row][j] - <span class="string">&#x27;0&#x27;</span>] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// filter column j</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; boardDim; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == row) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (board[i][column] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// filter out the conflict one</span></span><br><span class="line">      flag[board[i][column] - <span class="string">&#x27;0&#x27;</span>] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// filter box</span></span><br><span class="line">    <span class="type">int</span> rowBox = row / <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> columnBox = column / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = rowBox * <span class="number">3</span>; i &lt; (rowBox + <span class="number">1</span>) * <span class="number">3</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = columnBox * <span class="number">3</span>; j &lt; (columnBox + <span class="number">1</span>) * <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == row &amp;&amp; j == column) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        flag[board[i][j] - <span class="string">&#x27;0&#x27;</span>] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get option</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (flag[i]) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// using recursion based dfs</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, board);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> column, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> boardRow = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> boadColumn = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (row == boardRow) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nextRow = row;</span><br><span class="line">    <span class="keyword">if</span> (column == (boadColumn - <span class="number">1</span>)) &#123;</span><br><span class="line">      nextRow = row + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> nextColumn = (column + <span class="number">1</span>) % boadColumn;</span><br><span class="line">    <span class="keyword">if</span> (board[row][column] &gt;= <span class="string">&#x27;1&#x27;</span> &amp;&amp; board[row][column] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">dfs</span>(nextRow, nextColumn, board);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// current value node exist</span></span><br><span class="line">      <span class="comment">// get options</span></span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; options = <span class="built_in">getOptions</span>(row, column, board);</span><br><span class="line">      <span class="keyword">if</span> (options.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// current is conflict</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// range options</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; options.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        board[row][column] = options[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">bool</span> find = <span class="built_in">dfs</span>(nextRow, nextColumn, board);</span><br><span class="line">        <span class="keyword">if</span> (find==<span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// pop back (not necessary, there is valid answer anyway)</span></span><br><span class="line">        board[row][column] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>51. N-Queens</strong></p>
<p>I got this question in one interview, it is comparatively easy to come up with a solution but it is not easy to make it right. When checking the conflicts, I remember to check the row, the column, the left side diagnal but <strong>I forget to check the right side diagonal direaction(not sure why)</strong> So it adds more possibilities in the output. Another thing is that I try to set the value of status matrix as 0 after each time we found a new solution (which is incorrect and may introduce a lot of empty output). Since the code is recursive way, so it is possible that the last several position is different but the start position is same. If we set the status as the empty, it will also remove the previous status position, which introduce error. This is the version I write in the interview. Which is easy to understand but can be improved further (the process to decide the conflict is a little bit redoundant here).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkConflict</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; status, <span class="type">int</span>&amp; n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//if there is queen on row </span></span><br><span class="line">    <span class="comment">//checking s[i][0]-s[i][n-1] is there is queen</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(status[i][k]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//if there is queen on column</span></span><br><span class="line">    <span class="comment">//checking s[0][j]-s[n][j] is there is queen </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(status[k][j]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//left diagonal</span></span><br><span class="line">    <span class="type">int</span> k1=<span class="built_in">min</span>(i,j);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=k1;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(status[i-k][j-k]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;n;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i+k&gt;=n || j+k &gt;=n)&#123;</span><br><span class="line">            <span class="comment">//out of bound</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(status[i+k][j+k]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//right diagonal, try to move one grid, break when oob</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;n;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i-k&lt;<span class="number">0</span> || j+k&gt;=n )&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(status[i-k][j+k]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">        <span class="comment">// out of bounds</span></span><br><span class="line">        <span class="keyword">if</span>(i+k&gt;=n || j-k&lt;<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(status[i+k][j-k]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">ToOutput</span><span class="params">(<span class="type">int</span>&amp;n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; status)</span></span>&#123;</span><br><span class="line">    string outputStr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        outputStr=outputStr+<span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(status[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                outputStr+=<span class="string">&quot;Q&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                outputStr+=<span class="string">&quot;.&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=n<span class="number">-1</span>)&#123;</span><br><span class="line">            outputStr=outputStr+<span class="string">&quot;\&quot;,&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            outputStr=outputStr+<span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> outputStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(<span class="type">int</span> remain, <span class="type">int</span> &amp;n, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; status, vector&lt;string&gt;&amp; output)</span></span>&#123;</span><br><span class="line">    <span class="comment">//exit </span></span><br><span class="line">    <span class="keyword">if</span>(remain==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//change status to output</span></span><br><span class="line">        string outputStr = <span class="built_in">ToOutput</span>(n, status);</span><br><span class="line">        <span class="comment">//save answer</span></span><br><span class="line">        output.<span class="built_in">push_back</span>(outputStr);</span><br><span class="line">        <span class="comment">//clear status</span></span><br><span class="line">        <span class="comment">//status.clear();</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//where can we place queen</span></span><br><span class="line">    <span class="comment">//status[remain][0]-status[remian][n-1]</span></span><br><span class="line">    <span class="type">bool</span> setq=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="comment">//check conflicts</span></span><br><span class="line">        <span class="type">bool</span> ifconflict=<span class="built_in">checkConflict</span>(n-remain,j, status, n);</span><br><span class="line">        <span class="keyword">if</span>(ifconflict)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//put current queen</span></span><br><span class="line">            status[n-remain][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//continue recursion</span></span><br><span class="line">            setq=<span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">helper</span>(remain<span class="number">-1</span>,n,status,output);</span><br><span class="line">            <span class="comment">//set back status</span></span><br><span class="line">            status[n-remain][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setq==<span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//given n return all solutions</span></span><br><span class="line"><span class="comment">//testing</span></span><br><span class="line"><span class="type">int</span> n=<span class="number">4</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">status</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">vector&lt;string&gt; output;</span><br><span class="line"><span class="comment">//void helper(int remain, int &amp;n, vector&lt;vector&lt;int&gt;&gt;&amp; status, vector&lt;string&gt;&amp; output)&#123;</span></span><br><span class="line"><span class="built_in">helper</span>(n,n,status,output);</span><br><span class="line"><span class="comment">//checking results</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;output.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    std::cout &lt;&lt;output[i]&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This question is similar to previous one. The dfs need to go thrrough all possible combinations and store the valid results during the traverse. For each level, we can assume the possible options (namely the elements in the set) is the position for each one in different column. Then we use a function to decide if each position is conflict with the current grid results to decide if the current tree can move one step further. The recursion depth is the size of the grid.</p>
<p>Fur the current code, the meaning of each node means if the tree is at the specific row, column position. Since each row can only put one element, so we can simply use a for loop to detect each case and range it. (Every option is exclusive)</p>
<p>Origianlly, we consider a more general case and consider each cell separately. Each cell can put a queue or not, for that code, even though it can work, but we create too many recursions and the code become slow. The time complexity is <code>O(2^(n*n))</code> for that case, for the current case, the time complexity is <code>O(n*n)</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_gridDim;</span><br><span class="line">  vector&lt;vector&lt;string&gt;&gt; m_ans;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dir = &#123;&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"> </span><br><span class="line">  vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">initGrid</span><span class="params">(n)</span></span>;</span><br><span class="line">    m_gridDim = n;</span><br><span class="line">    <span class="comment">// init grid</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_gridDim; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        initGrid[j] += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(n, <span class="number">0</span>, initGrid);</span><br><span class="line">    <span class="keyword">return</span> m_ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//each row is a new level of the tree</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">conflict</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> column, vector&lt;string&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// edge case</span></span><br><span class="line">    <span class="keyword">if</span> (m_gridDim == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check row</span></span><br><span class="line">    <span class="keyword">if</span> (grid[row].<span class="built_in">find</span>(<span class="string">&quot;Q&quot;</span>) != string::npos) &#123;</span><br><span class="line">      <span class="comment">// there is Q in this row</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check column</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_gridDim; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (grid[i][column] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//check for dir</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> nextr = row+dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nextc = column+dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//if the results is in the boundry</span></span><br><span class="line">        <span class="keyword">while</span> (nextr &gt;= <span class="number">0</span> &amp;&amp; nextr &lt; m_gridDim &amp;&amp; nextc &gt;= <span class="number">0</span> &amp;&amp; nextc &lt; m_gridDim) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[nextr][nextc] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//continue move</span></span><br><span class="line">            nextr=nextr+dir[i][<span class="number">0</span>];</span><br><span class="line">            nextc = nextc+dir[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// put one queue for one row</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> remain, <span class="type">int</span> curRow, vector&lt;string&gt;&amp; currGrid)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//printf(&quot;r %d\n&quot;, curRow);</span></span><br><span class="line">    <span class="comment">//for (int i = 0; i &lt; m_gridDim; i++) &#123;</span></span><br><span class="line">    <span class="comment">//  printf(&quot;%s\n&quot;, currGrid[i].c_str());</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//printf(&quot;\n---\n&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (curRow == m_gridDim) &#123;</span><br><span class="line">      <span class="comment">// out of bound</span></span><br><span class="line">      <span class="comment">// the current ans might ok</span></span><br><span class="line">      <span class="keyword">if</span> (remain == <span class="number">0</span>) &#123;</span><br><span class="line">        m_ans.<span class="built_in">push_back</span>(currGrid);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>;c&lt;m_gridDim;c++)&#123;</span><br><span class="line">        <span class="comment">//if put at the current row and c</span></span><br><span class="line">        <span class="type">bool</span> ifconflict = <span class="built_in">conflict</span>(curRow, c, currGrid);</span><br><span class="line">        <span class="keyword">if</span>(ifconflict)&#123;</span><br><span class="line">            <span class="comment">//can not put at the current position</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//put it at the current position</span></span><br><span class="line">        currGrid[curRow][c] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(remain - <span class="number">1</span>, curRow+<span class="number">1</span>, currGrid);</span><br><span class="line">        <span class="comment">// set status back</span></span><br><span class="line">        currGrid[curRow][c] = <span class="string">&#x27;.&#x27;</span>;          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>52. N-Queens II</strong></p>
<p>The idea is similar with previous one, just change the ans when get the valid solution each time.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_gridDim;</span><br><span class="line">  <span class="type">int</span> m_ans=<span class="number">0</span>;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dir = &#123;&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">initGrid</span><span class="params">(n)</span></span>;</span><br><span class="line">        m_gridDim = n;</span><br><span class="line">        <span class="comment">// init grid</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_gridDim; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            initGrid[j] += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(n, <span class="number">0</span>, initGrid);</span><br><span class="line">        <span class="keyword">return</span> m_ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//each row is a new level of the tree</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">conflict</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> column, vector&lt;string&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// edge case</span></span><br><span class="line">    <span class="keyword">if</span> (m_gridDim == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check row</span></span><br><span class="line">    <span class="keyword">if</span> (grid[row].<span class="built_in">find</span>(<span class="string">&quot;Q&quot;</span>) != string::npos) &#123;</span><br><span class="line">      <span class="comment">// there is Q in this row</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check column</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_gridDim; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (grid[i][column] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//check for dir</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> nextr = row+dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nextc = column+dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//if the results is in the boundry</span></span><br><span class="line">        <span class="keyword">while</span> (nextr &gt;= <span class="number">0</span> &amp;&amp; nextr &lt; m_gridDim &amp;&amp; nextc &gt;= <span class="number">0</span> &amp;&amp; nextc &lt; m_gridDim) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[nextr][nextc] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//continue move</span></span><br><span class="line">            nextr=nextr+dir[i][<span class="number">0</span>];</span><br><span class="line">            nextc = nextc+dir[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// put one queue for one row</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> remain, <span class="type">int</span> curRow, vector&lt;string&gt;&amp; currGrid)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//printf(&quot;r %d\n&quot;, curRow);</span></span><br><span class="line">    <span class="comment">//for (int i = 0; i &lt; m_gridDim; i++) &#123;</span></span><br><span class="line">    <span class="comment">//  printf(&quot;%s\n&quot;, currGrid[i].c_str());</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//printf(&quot;\n---\n&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (curRow == m_gridDim) &#123;</span><br><span class="line">      <span class="comment">// out of bound</span></span><br><span class="line">      <span class="comment">// the current ans might ok</span></span><br><span class="line">      <span class="keyword">if</span> (remain == <span class="number">0</span>) &#123;</span><br><span class="line">        m_ans++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>;c&lt;m_gridDim;c++)&#123;</span><br><span class="line">        <span class="comment">//if put at the current row and c</span></span><br><span class="line">        <span class="type">bool</span> ifconflict = <span class="built_in">conflict</span>(curRow, c, currGrid);</span><br><span class="line">        <span class="keyword">if</span>(ifconflict)&#123;</span><br><span class="line">            <span class="comment">//can not put at the current position</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//put it at the current position</span></span><br><span class="line">        currGrid[curRow][c] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(remain - <span class="number">1</span>, curRow+<span class="number">1</span>, currGrid);</span><br><span class="line">        <span class="comment">// set status back</span></span><br><span class="line">        currGrid[curRow][c] = <span class="string">&#x27;.&#x27;</span>;          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The 52 can also be improved based on DP, we do not discuss it details here.</p>
<p>one optimization for 51 and 52 is to do the conflict checking, we may use more memory space and store if there are elements at specific row, column and dialogue to save the speed for checking the conflicts.</p>
<p>For example, <code>statesRow[i]</code> represents if there are queues at ith row, statesColumn[i] represents if there are elements at ith column, similarly for diagonalLeft and diagonalRight.</p>
<p>For the right side diagonal, the sum of the row and column is a fixed number<br>For the left side diagonal, the sum of the column - row is a fixed number<br>We can map the row and column to these two index.</p>
<p>The subsequent code shows how to use this optimization. We also do not need to store the grid explicitly in this way. The framework is similar with previous one and the operation for detecting the conflicts improves a lot. We just memorize the status based on several arrays explicitly.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_gridDim;</span><br><span class="line">  <span class="type">int</span> m_ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; m_rExist;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; m_cExist;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; m_dlExist;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; m_drExist;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        m_gridDim = n;</span><br><span class="line">        </span><br><span class="line">        m_rExist = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line">        m_cExist = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line">        m_dlExist = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        m_drExist = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> m_ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//each row is a new level of the tree</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">conflict</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> column)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_gridDim == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check row</span></span><br><span class="line">    <span class="keyword">if</span> (m_rExist[row]) &#123;</span><br><span class="line">      <span class="comment">// there is Q in this row</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check column</span></span><br><span class="line">    <span class="keyword">if</span> (m_cExist[column]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check right diagonal</span></span><br><span class="line">    <span class="keyword">if</span> (m_drExist[row + column]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check left diagonal</span></span><br><span class="line">    <span class="type">int</span> leftIndex = column - row + m_gridDim - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_dlExist[leftIndex]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// put one queue for one row</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> remain, <span class="type">int</span> curRow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (curRow == m_gridDim) &#123;</span><br><span class="line">      <span class="comment">// out of bound</span></span><br><span class="line">      <span class="comment">// the current ans might ok</span></span><br><span class="line">      <span class="keyword">if</span> (remain == <span class="number">0</span>) &#123;</span><br><span class="line">        m_ans++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>;c&lt;m_gridDim;c++)&#123;</span><br><span class="line">        <span class="comment">//if put at the current row and c</span></span><br><span class="line">        <span class="type">bool</span> ifconflict = <span class="built_in">conflict</span>(curRow, c);</span><br><span class="line">        <span class="keyword">if</span>(ifconflict)&#123;</span><br><span class="line">            <span class="comment">//can not put at the current position</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//put it at the current position</span></span><br><span class="line">        <span class="comment">//set the current status</span></span><br><span class="line">        m_rExist[curRow] = <span class="number">1</span>;</span><br><span class="line">        m_cExist[c] = <span class="number">1</span>;</span><br><span class="line">        m_drExist[curRow + c] = <span class="number">1</span>;</span><br><span class="line">        m_dlExist[c - curRow + m_gridDim - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(remain - <span class="number">1</span>, curRow+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// set status back</span></span><br><span class="line">        m_rExist[curRow] = <span class="number">0</span>;</span><br><span class="line">        m_cExist[c] = <span class="number">0</span>;</span><br><span class="line">        m_drExist[curRow + c] = <span class="number">0</span>;</span><br><span class="line">        m_dlExist[c - curRow + m_gridDim - <span class="number">1</span>] = <span class="number">0</span>;            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="Naive-DFS-UpToBottom-Permutation"><a href="#Naive-DFS-UpToBottom-Permutation" class="headerlink" title="Naive DFS-UpToBottom-Permutation"></a>Naive DFS-UpToBottom-Permutation</h3><p><strong>46. Permutations</strong> </p>
<p>Typical permutation question, we can reuse the similar framework and put things into the ans only when all elements are checked. Still go through the path as previous one, put the path into the ans only when it get to the end.</p>
<p>Maybe there are more efficient way to consider which path is unnecessary, in this example, we just check if the particular elements is in the curr, if it is already in the curr, we do not go through along that path. The start position in this question start from the 0 to end instead of customized start position to end (since the results can be any order). </p>
<p>We can use another flag vector to label if the element is used or not, if then when we pop the element out, we set the specific label into false. This can further improve the code a little bit.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; curr;</span><br><span class="line">        <span class="built_in">dfs</span>(ans,curr,nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp;curr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:curr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v==k)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;ans, vector&lt;<span class="type">int</span>&gt;&amp;curr,vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//if i is in the curr</span></span><br><span class="line">            <span class="comment">//do not go through along this path</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">exist</span>(nums[i],curr))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            curr.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(ans,curr,nums);</span><br><span class="line">            curr.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This is the code with the visited flag (recomended version, we do not need to check existance each time). It looks that the permutation related problem use the visited flag a lot (each ans is a complete path) and the combination problems use the sort a lot (the answer can be half of the path).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; curr;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(ans,curr,nums,visited);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;ans, vector&lt;<span class="type">int</span>&gt;&amp;curr,vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp;visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">//put current path into the ans</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//if i is in the curr</span></span><br><span class="line">            <span class="comment">//do not go through along this path</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            curr.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            visited[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(ans,curr,nums,visited);</span><br><span class="line">            <span class="comment">//set status back</span></span><br><span class="line">            curr.<span class="built_in">pop_back</span>();</span><br><span class="line">            visited[i]=<span class="literal">false</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>47. Permutations II</strong></p>
<p>Similar to the previous question, the input of this problem contains the repeated elements. In previous one, we solve this issue by sorting the input firstly and then compares nums[i] and nums[i-1], when they appears at the second time, we do not go through along that path. It use both the sorting strategy and the visited flag to trim the path</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; curr;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">label</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(ans,curr,nums,label);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;ans, vector&lt;<span class="type">int</span>&gt;&amp;curr,vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; label)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//if i is in the curr</span></span><br><span class="line">            <span class="comment">//do not go through along this path</span></span><br><span class="line">            <span class="keyword">if</span>(label[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//only in the current layer</span></span><br><span class="line">            <span class="comment">//if the previous same one is visited</span></span><br><span class="line">            <span class="comment">//we do not visit current one</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>] &amp;&amp; label[i<span class="number">-1</span>]==<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            curr.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            label[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(ans,curr,nums,label);</span><br><span class="line">            curr.<span class="built_in">pop_back</span>();</span><br><span class="line">            label[i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;        </span><br></pre></td></tr></table></figure>

<p><strong>943. Find the Shortest Superstring</strong></p>
<p>The original idea of this question is that, do all the permulations, and then remove the potential overlapping part.</p>
<p>The original idea to remove the overlapping part is to find if the start position of second string is in the first string. Assuming in the position i of the first string, then compare the i to the end, to see if it appears in the second string, it is possible there are multiple positions. This operation can be applied every time we add a new string. </p>
<p>this operation can be also done before searching (this is a good point), and we store the results explicitly. then we do not need to do the similar operation during the search (we store the information beforehand) This info is important to construct the final path, dfs call is n! for every node, we call n nodes.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//this is the naive search solution</span></span><br><span class="line"><span class="comment">//did not pass all the tests, time limit issue</span></span><br><span class="line"><span class="comment">//56 / 83 test cases passed.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">overlappingLen2</span><span class="params">(string&amp; first, string&amp; second)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> upperBound = <span class="built_in">min</span>(first.<span class="built_in">length</span>(), second.<span class="built_in">length</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= upperBound; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.<span class="built_in">substr</span>(first.<span class="built_in">length</span>() - k) == second.<span class="built_in">substr</span>(<span class="number">0</span>, k)) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">shortestSuperstring</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;        </span><br><span class="line">        string ans;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">labelUsed</span><span class="params">(words.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> wordsLen = words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(words,wordsLen,<span class="string">&quot;&quot;</span>,ans,labelUsed,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//we use the parent Str to remember last steps results</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;string&gt;&amp; words, <span class="type">int</span>&amp; wordsSize, string parentStr, string&amp; ans, vector&lt;<span class="type">bool</span>&gt;&amp; labelUsed, <span class="type">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="comment">//check all the possible of strings here</span></span><br><span class="line">        <span class="keyword">if</span>(count==wordsSize)&#123;</span><br><span class="line">            <span class="comment">//update ans when all string is counted</span></span><br><span class="line">            <span class="keyword">if</span>(ans.<span class="built_in">length</span>()==<span class="number">0</span> || (parentStr.<span class="built_in">length</span>()&lt;ans.<span class="built_in">length</span>()))&#123;</span><br><span class="line">                ans = parentStr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wordsSize;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(labelUsed[i]==<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> overlapLen = <span class="built_in">overlappingLen2</span>(parentStr,words[i]);       </span><br><span class="line">            string currStr = parentStr+words[i].<span class="built_in">substr</span>(overlapLen);</span><br><span class="line">            labelUsed[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//dfs check</span></span><br><span class="line">            <span class="built_in">dfs</span>(words,wordsSize,currStr,ans,labelUsed,count+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//udpate status of the current layer</span></span><br><span class="line">            labelUsed[i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This is the version that computes the prior information about the overlap length between each two pairs.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//use shared part for the ans</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; m_priorInfo;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; m_bestPath;</span><br><span class="line">    <span class="type">int</span> m_bestLen;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">overlappingLen</span><span class="params">(string&amp; first, string&amp; second)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> upperBound = <span class="built_in">min</span>(first.<span class="built_in">length</span>(), second.<span class="built_in">length</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= upperBound; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.<span class="built_in">substr</span>(first.<span class="built_in">length</span>() - k) == second.<span class="built_in">substr</span>(<span class="number">0</span>, k)) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">shortestSuperstring</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;        </span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> wordsLen = words.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        m_priorInfo =vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; (wordsLen, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(wordsLen,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//process the prior info</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wordsLen;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;wordsLen;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">                    m_priorInfo[i][j]=words[i].<span class="built_in">length</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    m_priorInfo[i][j]=<span class="built_in">overlappingLen</span>(words[i],words[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//printf(&quot;info i %d j %d len %d\n&quot;,i,j,priorInfo[i][j]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">labelUsed</span><span class="params">(words.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; currPath;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//do the dfs</span></span><br><span class="line">        <span class="built_in">dfs</span>(words,wordsLen,labelUsed,<span class="number">0</span>,<span class="number">0</span>,currPath);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//recover the string from the bestPath</span></span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_bestPath.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//printf(&quot;path i %d %d\n&quot;,i,m_bestPath[i]);</span></span><br><span class="line">            <span class="type">int</span> currIndex = m_bestPath[i];</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                ans+=words[currIndex];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> lastIndex = m_bestPath[i<span class="number">-1</span>];</span><br><span class="line">                ans+=words[currIndex].<span class="built_in">substr</span>(m_priorInfo[lastIndex][currIndex]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//we use the parent Str to remember last steps results</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;string&gt;&amp; words, <span class="type">int</span>&amp; wordsSize, vector&lt;<span class="type">bool</span>&gt;&amp; labelUsed, <span class="type">int</span> count, <span class="type">int</span> currLen, vector&lt;<span class="type">int</span>&gt;&amp; currPath)</span></span>&#123;</span><br><span class="line">        <span class="comment">//check all the possible of strings here</span></span><br><span class="line">        <span class="keyword">if</span>(m_bestLen&gt;<span class="number">0</span> &amp;&amp; currLen&gt;=m_bestLen)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(count==wordsSize)&#123;</span><br><span class="line">            <span class="comment">//update best path and best len</span></span><br><span class="line">            m_bestLen=currLen;</span><br><span class="line">            m_bestPath=currPath;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wordsSize;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(labelUsed[i]==<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> currLenNew = currLen;</span><br><span class="line">            <span class="keyword">if</span>(currPath.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//the first one</span></span><br><span class="line">                currLenNew=words[i].<span class="built_in">length</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> overlapLen = m_priorInfo[currPath.<span class="built_in">back</span>()][i];</span><br><span class="line">                <span class="comment">//overlappingLen2(words[currPath.back()],words[i]);</span></span><br><span class="line">                currLenNew = currLen+(words[i].<span class="built_in">length</span>()-overlapLen);              </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currPath.<span class="built_in">push_back</span>(i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//string currStr = parentStr+words[i].substr(overlapLen);</span></span><br><span class="line">            labelUsed[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//dfs check</span></span><br><span class="line">            <span class="built_in">dfs</span>(words,wordsSize,labelUsed, count+<span class="number">1</span>, currLenNew, currPath);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//udpate status of the current layer</span></span><br><span class="line">            labelUsed[i]=<span class="literal">false</span>;</span><br><span class="line">            currPath.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="comment">//make sure currLen do not change </span></span><br><span class="line">            <span class="comment">//after each iteration in the for loop</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This code can not pass all tests because and exceeds the limited time. The ideal way is still to view the problem as a weighted graph and find the shortest path. Refer to the graph listed in <a target="_blank" rel="noopener" href="https://zxi.mytechroad.com/blog/searching/leetcode-943-find-the-shortest-superstring/">huahua’s blog</a> and the official solution <a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-the-shortest-superstring/solution/">here</a>. Using the mask to remember the existing visited nodes is a little bit tricky. The 1 or 0 in each bit position of the mask represents that if the associated value is visited or not. The <code>mask ^ (1&lt;&lt;j)</code> represents that we set jth position as 1 and put it into the mask. (The <code>^</code> is the xor opertaion, if the original bit is 0 and current one <code>1&lt;&lt;j</code> is 1, the results here for specific bit is 1). Using <code>s &amp; (1 &lt;&lt; j)</code> operation can check if the specific bit is set. If it is set, the results is a non zero number, otherwise, the result is zero. We do not discuss the dp solution here. The dp solution can be written into the recursive way or not. The core ideas is that we keeping the intermidiate status during the search. How to memorise that information is key point to improve the speed.</p>
<p><strong>996. Number of Squareful Arrays</strong></p>
<p>This is a permutation operation pluse the constraint. The idea is a little bit similar with previous one. Same to the previous one, the naive searching method is still time consuming and the dp method can improve the code a lot, but it is not easy to figure out that dp solution. There are several small points, for example, 0 is also a square number. We can also sort the array and compute the prefix sum to see if the results is squere number. We can avoid the repeated solutions by this way.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; m_priorInfo;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">squareNum</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i*i&lt;=num;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*i==num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquarefulPerms</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> numSize = nums.<span class="built_in">size</span>();</span><br><span class="line">        m_priorInfo = vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; (numSize,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(numSize,<span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">//do the search</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">labels</span><span class="params">(numSize, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(ans,nums,labels,path);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span>&amp; ans, vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; labels, vector&lt;<span class="type">int</span>&gt;&amp; path)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check the results</span></span><br><span class="line">        <span class="comment">//if valid</span></span><br><span class="line">        <span class="comment">//how to remove the repeated one?</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//we need to start from the 0 since we need to go through </span></span><br><span class="line">        <span class="comment">//all permutations</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(labels[i]==<span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>] &amp;&amp; labels[i<span class="number">-1</span>]==<span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!path.<span class="built_in">empty</span>() &amp;&amp; !<span class="built_in">squareNum</span>(path.<span class="built_in">back</span>()+nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//all situation need to put the elements</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            labels[i]=<span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//dfs for children layers</span></span><br><span class="line">            <span class="built_in">dfs</span>(ans,nums,labels,path);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//back to current layer</span></span><br><span class="line">            labels[i]=<span class="literal">false</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This is the version to utilize the prior knoledge, maybe the good strategy is not to compute them all at once, we can cache them during the searching process.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">squareNum</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="built_in">sqrt</span>(num);</span><br><span class="line">    <span class="keyword">return</span> s * s == num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquarefulPerms</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> numSize = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">//do the search</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">labels</span><span class="params">(numSize, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(ans,nums,labels,path);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span>&amp; ans, vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; labels, vector&lt;<span class="type">int</span>&gt;&amp; path)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check the results</span></span><br><span class="line">        <span class="comment">//if valid</span></span><br><span class="line">        <span class="comment">//how to remove the repeated one?</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//we need to start from the 0 since we need to go through </span></span><br><span class="line">        <span class="comment">//all permutations</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(labels[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//be carefule here</span></span><br><span class="line">            <span class="comment">//if there are multiple same elements</span></span><br><span class="line">            <span class="comment">//only the first can be used in the same level, the third one is important</span></span><br><span class="line">            <span class="comment">//only when the labels for previous one is 0</span></span><br><span class="line">            <span class="comment">//we can make sure its dfs complete</span></span><br><span class="line">            <span class="comment">//otherwise, it might be the condition during the dfs process</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>] &amp;&amp; labels[i<span class="number">-1</span>]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!path.<span class="built_in">empty</span>() &amp;&amp; !<span class="built_in">squareNum</span>(path.<span class="built_in">back</span>()+nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//all situation need to put the elements</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            labels[i]=<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//dfs for children layers</span></span><br><span class="line">            <span class="built_in">dfs</span>(ans,nums,labels,path);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//back to current layer</span></span><br><span class="line">            labels[i]=<span class="number">0</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The efficient way is still to use the dp method, it is ensentially a hamitonion path in the graphy theory, refer to this explanation (<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=ISnktonx7rY">https://www.youtube.com/watch?v=ISnktonx7rY</a>). When there two numbers are prefect squre, there is a path between them.</p>
<h3 id="Naive-DFS-UpToBottom-Expression"><a href="#Naive-DFS-UpToBottom-Expression" class="headerlink" title="Naive DFS-UpToBottom-Expression"></a>Naive DFS-UpToBottom-Expression</h3><p>This type of question provide a expression, then maybe we need to compute some properties according to the expression. There usually exist the inserted structure which can be abstracted into a tree. The question in this type is a little bit like decoding the string into a tree structure with layered information, even if we do not use an actually tree structure, we still need to keep a layer variable to trace current part is at which layer. The 856 is a good example.</p>
<p><strong>856 Score of Parentheses</strong></p>
<p>the code looks super easy we do not even write it into a recursion way, but it is not straightforward to figure out why it works. The whole idea for solving this problem is to emulate a tree structure, different with the previous one, every node is a () pair.</p>
<p>For example, if the input is <code>(())</code>, the imaginary tree is as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">()</span><br><span class="line">|</span><br><span class="line">()</span><br></pre></td></tr></table></figure>
<p>If there is <code>(()())</code>, the imaginary tree (or the decision tree) is as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">()</span><br><span class="line">| \</span><br><span class="line">() ()</span><br></pre></td></tr></table></figure>
<p>The key is that we do not consider the implementaion, we consider the abstraction first. Then according to the rule of the score, for each leaf node, its score is 2^depth, then we accumulate all the scores of leaf node together. Although the description of the question is to compute the score from the bottom to top, it is much easier to compute scores from the top to the bottom.</p>
<p>Regarding to the implementation, when there is <code>(</code>, the depth increase, when there is <code>)</code> the depth decrease, and if the previous one is <code>(</code>, we assume that we met the leaf node. The whole sequence is just like the LRN traversal of the tree</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int scoreOfParentheses(string s) &#123;</span><br><span class="line">        int score =0;</span><br><span class="line">        int len = s.length();</span><br><span class="line">        int depth=0;</span><br><span class="line">        //range s</span><br><span class="line">        for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">            if(s[i] == &#x27;(&#x27;)&#123;</span><br><span class="line">                depth++;</span><br><span class="line">            &#125;else if(s[i] == &#x27;)&#x27;)&#123;</span><br><span class="line">                if(i&gt;0 &amp;&amp; s[i-1]==&#x27;(&#x27;)&#123;</span><br><span class="line">                    score+=pow(2,depth-1);</span><br><span class="line">                &#125;</span><br><span class="line">                depth--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Another way is to find the balanced outlayer strcutre, and then use the recursion to call the inner layer, which is like the tree taversal from the top to the bottom, in the string case, it can use the left and right index to label the each layer of the structure, when you find each layer, the tree depth increase one.</p>
<p>Enssentially, it like the process of decoding the string into the tree and then compute some properties of the tree. For the <code>394. Decode String</code>, this idea is more obvious, and we basically use the bottom to up strategy of the tree based approach and we decode each subtree recursively. For each level, we just need a function to let it return the reuslts of the subtree. For the tree structure in logically, the leaf node is the character and the parent node is the number. The issue is that in the string structure, we basically flatten everything and not knwo when it end. So that’s why we also return a right index. That right index labels when the current level moves to the end. And then we start from the next segment (which is the node at the same level with the current node)</p>
<p><strong>726. Number of Atoms</strong></p>
<p>This is the a hard one, the main reason is that the rules are a liitle bit complex. The idea is same with previous one, the different place is that we read the string from right side to the left side, it might be easier to consider things in this way. By this way, we check the number first (the non leaf node) then the atom (the leaf node). The code can be further optimized. Although current code can work, it is still a little bit unclear for when to put the information into the map.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map &lt;string, <span class="type">int</span>&gt; atomMap;</span><br><span class="line">    <span class="function">string <span class="title">countOfAtoms</span><span class="params">(string formula)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ordered map to store the atom and its number</span></span><br><span class="line">        string str;</span><br><span class="line">        <span class="type">int</span> len = formula.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> lindex=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">helper</span>(formula,lindex,len<span class="number">-1</span>,len,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//output the value from map into string</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : atomMap)&#123;</span><br><span class="line">            string key = it.first;</span><br><span class="line">            <span class="comment">//std::cout &lt;&lt; &quot;key&quot; &lt;&lt; key &lt;&lt;std::endl;</span></span><br><span class="line">            <span class="type">int</span> value = it.second;</span><br><span class="line">            str+=key;</span><br><span class="line">            <span class="keyword">if</span>(value!=<span class="number">1</span>)&#123;</span><br><span class="line">                str+=<span class="built_in">to_string</span>(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//paras: formular, start position, len of the formula</span></span><br><span class="line">    <span class="comment">//read it from right to left for simplicity</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(string&amp; f, <span class="type">int</span>&amp; lindex, <span class="type">int</span> rindex, <span class="type">int</span>&amp; len, <span class="type">int</span> multiplier)</span></span>&#123;</span><br><span class="line">        string atomName;</span><br><span class="line">        <span class="type">int</span> fNum=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i=rindex;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//std::cout &lt;&lt; &quot;i &quot; &lt;&lt; i &lt;&lt; std::endl;</span></span><br><span class="line">            <span class="comment">//number</span></span><br><span class="line">            <span class="keyword">if</span>(f[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; f[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// H2O case, it can be a new started atom</span></span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;len &amp;&amp; f[i+<span class="number">1</span>]&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; f[i+<span class="number">1</span>]&lt;=<span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">//this condition is prior than case where there is (</span></span><br><span class="line">                    <span class="comment">//when this executed, we do not check ( further</span></span><br><span class="line">                    <span class="comment">//this is a new atom</span></span><br><span class="line">                    <span class="comment">//std::cout&lt;&lt;&quot;anmed &quot;&lt;&lt;atomName &lt;&lt; &quot;fnum &quot; &lt;&lt; fNum &lt;&lt; &quot;multi &quot; &lt;&lt; multiplier&lt;&lt;std::endl;</span></span><br><span class="line">                    atomMap[atomName]+=fNum*multiplier;</span><br><span class="line">                    <span class="comment">//reset key variables</span></span><br><span class="line">                    atomName=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                    fNum=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//current number</span></span><br><span class="line">                <span class="type">int</span> tempNum = f[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="comment">//read from right to left</span></span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span> &lt; len &amp;&amp; f[i+<span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; f[i+<span class="number">1</span>]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                    fNum = tempNum*<span class="number">10</span>+fNum;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    fNum = tempNum;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//character(multiple)</span></span><br><span class="line">            <span class="keyword">if</span>((f[i]&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; f[i]&lt;=<span class="string">&#x27;Z&#x27;</span>) || (f[i]&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; f[i]&lt;=<span class="string">&#x27;z&#x27;</span>))&#123;</span><br><span class="line">                <span class="comment">//reset the fNum if there are two upper case</span></span><br><span class="line">                <span class="comment">//the 1 is omitted in expression</span></span><br><span class="line">                <span class="comment">//also update in this case</span></span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;len &amp;&amp; f[i+<span class="number">1</span>]&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; f[i+<span class="number">1</span>]&lt;=<span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">//this condition is prior than case where there is (</span></span><br><span class="line">                    <span class="comment">//when this executed, we do not check ( further</span></span><br><span class="line">                    <span class="comment">//this is a new atom</span></span><br><span class="line">                    <span class="comment">//std::cout&lt;&lt;&quot;anmec &quot;&lt;&lt;atomName&lt;&lt;std::endl;</span></span><br><span class="line">                    atomMap[atomName]+=fNum*multiplier;</span><br><span class="line">                    <span class="comment">//reset key variables</span></span><br><span class="line">                    atomName=f[i];</span><br><span class="line">                    fNum=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    atomName=f[i]+atomName;</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(f[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//recursion, process multiple elements inserted</span></span><br><span class="line">                <span class="comment">//in current section</span></span><br><span class="line">                <span class="comment">//update l index</span></span><br><span class="line">                <span class="built_in">helper</span>(f, lindex, i<span class="number">-1</span>, len, multiplier*fNum);</span><br><span class="line">                <span class="comment">//remember to set new fNum, from this point, it is a new segment</span></span><br><span class="line">                fNum=<span class="number">1</span>;</span><br><span class="line">                i=lindex<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// can start with chracter</span></span><br><span class="line">            <span class="comment">// when i==0 also insert</span></span><br><span class="line">            <span class="keyword">if</span>(f[i]==<span class="string">&#x27;(&#x27;</span> || i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//return point</span></span><br><span class="line">                <span class="comment">//put thing into map</span></span><br><span class="line">                <span class="comment">//std::cout&lt;&lt;&quot;anmeb &quot;&lt;&lt;atomName&lt;&lt;std::endl;</span></span><br><span class="line">                <span class="keyword">if</span>(atomName!=<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">                    atomMap[atomName]+=fNum*multiplier;</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">                <span class="comment">//reset key variables</span></span><br><span class="line">                atomName=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                fNum=<span class="number">1</span>;</span><br><span class="line">                lindex=i--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//process the first one</span></span><br><span class="line">        <span class="keyword">if</span>(atomName!=<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">//std::cout&lt;&lt;&quot;anmea &quot;&lt;&lt;atomName&lt;&lt; &quot; fNum &quot; &lt;&lt; fNum &lt;&lt; &quot; multi &quot; &lt;&lt; multiplier &lt;&lt; std::endl;</span></span><br><span class="line">            atomMap[atomName]+=fNum*multiplier;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Another example is 736, which is a little bit complex. (we will solve it in future)</p>
<p><strong>301. Remove Invalid Parentheses</strong></p>
<p>For this type of question, we need to generate new expression based on given expression. The naive way is to use the binaray tree, if the results increase the specific character or not. Without the trim, the complexity is 2^n, every time we map the status array into a new case.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    set&lt;string&gt; m_ans;</span><br><span class="line">    <span class="type">int</span> minUpdated = INT_MAX;</span><br><span class="line">    string inputStr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                depth++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                depth--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//do nothing for the letter</span></span><br><span class="line">            <span class="keyword">if</span>(depth&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//there are extra right parenthesis</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if the results is 0 all match</span></span><br><span class="line">        <span class="keyword">return</span> depth==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">removeInvalidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        inputStr = s;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">removedLabel</span><span class="params">(s.length(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,removedLabel);</span><br><span class="line">        vector&lt;string&gt; ansvec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v:m_ans)&#123;</span><br><span class="line">            ansvec.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ansvec.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            ansvec.<span class="built_in">push_back</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansvec;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">getNewStr</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; removedLabel)</span></span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inputStr.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//keep the string where there is false labels</span></span><br><span class="line">            <span class="keyword">if</span>(removedLabel[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                ans+=inputStr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> removedNum, <span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; removedLabel)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;inputStr.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">if</span>(removedNum&gt;minUpdated)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//maybe add a cache here</span></span><br><span class="line">        string currStr=<span class="built_in">getNewStr</span>(removedLabel);</span><br><span class="line">        <span class="comment">//printf(&quot;currStr %s label %d %d\n&quot;,currStr.c_str(),removedLabel[0],removedLabel[1]);</span></span><br><span class="line">        <span class="keyword">if</span>(removedNum==minUpdated)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">valid</span>(currStr))&#123;</span><br><span class="line">                m_ans.<span class="built_in">insert</span>(currStr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(removedNum&lt;minUpdated)&#123;</span><br><span class="line">            <span class="comment">//removedNum &lt; minUpdated</span></span><br><span class="line">            <span class="comment">//update resutls</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">valid</span>(currStr))&#123;</span><br><span class="line">                m_ans.<span class="built_in">clear</span>();</span><br><span class="line">                m_ans.<span class="built_in">insert</span>(currStr);  </span><br><span class="line">                minUpdated = removedNum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//todo reorganize the code, the s position mayber larger than</span></span><br><span class="line">        <span class="comment">//length in previous section</span></span><br><span class="line">        <span class="keyword">if</span>(s&gt;=inputStr.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//trim cases</span></span><br><span class="line">        <span class="comment">//if letters </span></span><br><span class="line">        <span class="keyword">if</span>(inputStr[s]!=<span class="string">&#x27;(&#x27;</span> &amp;&amp; inputStr[s]!=<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            removedLabel[s] = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(removedNum,s+<span class="number">1</span>,removedLabel);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;    </span><br><span class="line">            <span class="comment">//remove current or not</span></span><br><span class="line">            removedLabel[s]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//do the dfs, removed current</span></span><br><span class="line">            <span class="built_in">dfs</span>(removedNum+<span class="number">1</span>,s+<span class="number">1</span>,removedLabel);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//next is </span></span><br><span class="line">            removedLabel[s]=<span class="number">0</span>;</span><br><span class="line">            <span class="type">char</span> c = inputStr[s];</span><br><span class="line">            <span class="comment">//skip the repeated elements</span></span><br><span class="line">            <span class="keyword">while</span>(s&lt;inputStr.<span class="built_in">length</span>() &amp;&amp; inputStr[s]==c) s++; <span class="comment">//if not take then don&#x27;t take it until the same char</span></span><br><span class="line">            <span class="built_in">dfs</span>(removedNum,s,removedLabel);     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This is the version based on the bit mask and the cache, it does not improve the performance a lot, it however slows down the code, not sure the reason. (maybe the cache is not necessary)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    set&lt;string&gt; m_ans;</span><br><span class="line">    <span class="type">int</span> minUpdated = INT_MAX;</span><br><span class="line">    string inputStr;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; cache; <span class="comment">// map the mask into the string</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                depth++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                depth--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//do nothing for the letter</span></span><br><span class="line">            <span class="keyword">if</span>(depth&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//there are extra right parenthesis</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if the results is 0 all match</span></span><br><span class="line">        <span class="keyword">return</span> depth==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">removeInvalidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        inputStr = s;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">removedLabel</span><span class="params">(s.length(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> mask=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,mask);</span><br><span class="line">        vector&lt;string&gt; ansvec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v:m_ans)&#123;</span><br><span class="line">            ansvec.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ansvec.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            ansvec.<span class="built_in">push_back</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansvec;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//mask labels the removed part</span></span><br><span class="line">    <span class="function">string <span class="title">getNewStr</span><span class="params">(<span class="type">int</span> mask)</span></span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inputStr.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//keep the string where there is false labels</span></span><br><span class="line">            <span class="keyword">if</span>((mask &amp; (<span class="number">1</span>&lt;&lt;i))==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//if not labeled as removed</span></span><br><span class="line">                <span class="comment">//added into the ans</span></span><br><span class="line">                ans+=inputStr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//void dfs(int removedNum, int s, vector&lt;int&gt;&amp; removedLabel)&#123;</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> removedNum, <span class="type">int</span> s, <span class="type">int</span> mask)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;inputStr.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">if</span>(removedNum&gt;minUpdated)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//maybe add a cache here</span></span><br><span class="line">        string currStr;</span><br><span class="line">        <span class="keyword">if</span>(cache.<span class="built_in">count</span>(mask)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            currStr=cache[mask];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            currStr=<span class="built_in">getNewStr</span>(mask);</span><br><span class="line">            cache[mask]=currStr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//string currStr=getNewStr(removedLabel);</span></span><br><span class="line">        <span class="comment">//printf(&quot;currStr %s label %d %d\n&quot;,currStr.c_str(),removedLabel[0],removedLabel[1]);</span></span><br><span class="line">        <span class="keyword">if</span>(removedNum==minUpdated)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">valid</span>(currStr))&#123;</span><br><span class="line">                m_ans.<span class="built_in">insert</span>(currStr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(removedNum&lt;minUpdated)&#123;</span><br><span class="line">            <span class="comment">//removedNum &lt; minUpdated</span></span><br><span class="line">            <span class="comment">//update resutls</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">valid</span>(currStr))&#123;</span><br><span class="line">                m_ans.<span class="built_in">clear</span>();</span><br><span class="line">                m_ans.<span class="built_in">insert</span>(currStr);  </span><br><span class="line">                minUpdated = removedNum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//todo reorganize the code, the s position mayber larger than</span></span><br><span class="line">        <span class="comment">//length in previous section</span></span><br><span class="line">        <span class="keyword">if</span>(s&gt;=inputStr.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//trim cases</span></span><br><span class="line">        <span class="comment">//if letters </span></span><br><span class="line">        <span class="keyword">if</span>(inputStr[s]!=<span class="string">&#x27;(&#x27;</span> &amp;&amp; inputStr[s]!=<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//removedLabel[s] = false;</span></span><br><span class="line">            <span class="comment">//do not need to set, it is 0 initially</span></span><br><span class="line">            mask = (mask &amp; ~(<span class="number">1</span> &lt;&lt; s));</span><br><span class="line">            <span class="built_in">dfs</span>(removedNum,s+<span class="number">1</span>,mask);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;    </span><br><span class="line">            <span class="comment">//remove current or not</span></span><br><span class="line">            <span class="comment">//removedLabel[s]=1;</span></span><br><span class="line">            mask = (mask | (<span class="number">1</span>&lt;&lt;s));</span><br><span class="line">            <span class="comment">//do the dfs, removed current</span></span><br><span class="line">            <span class="built_in">dfs</span>(removedNum+<span class="number">1</span>,s+<span class="number">1</span>,mask);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//next is </span></span><br><span class="line">            <span class="comment">//removedLabel[s]=0;</span></span><br><span class="line">            mask = (mask &amp; ~(<span class="number">1</span>&lt;&lt;s));</span><br><span class="line">            <span class="type">char</span> c = inputStr[s];</span><br><span class="line">            <span class="comment">//skip the repeated elements</span></span><br><span class="line">            <span class="keyword">while</span>(s&lt;inputStr.<span class="built_in">length</span>() &amp;&amp; inputStr[s]==c) s++; <span class="comment">//if not take then don&#x27;t take it until the same char</span></span><br><span class="line">            <span class="built_in">dfs</span>(removedNum,s,mask);     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>394. Decode String</strong></p>
<p>We write this code into a recursion way, once we got the bracket, we do a recursion call. It actually use the bottom to up way to do the dfs</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">        string str = <span class="built_in">getSubstr</span>(s, <span class="number">0</span>, len, len);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">getSubstr</span><span class="params">(string&amp; s, <span class="type">int</span> l, <span class="type">int</span> len, <span class="type">int</span>&amp; rindex)</span></span>&#123;</span><br><span class="line">        string fullstr;</span><br><span class="line">        <span class="type">int</span> depth=<span class="number">0</span>;        </span><br><span class="line">        <span class="type">int</span> i=l;</span><br><span class="line">        <span class="type">int</span> repeat=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">            <span class="keyword">if</span>( s[i]==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                rindex=i;</span><br><span class="line">                repeat=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> fullstr;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i]&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">                fullstr+=s[i];</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> tempRepeat = (s[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; s[i<span class="number">-1</span>]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i<span class="number">-1</span>]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">//consider previous one only when</span></span><br><span class="line">                    <span class="comment">//there are adjacent digits</span></span><br><span class="line">                    repeat = repeat*<span class="number">10</span>+tempRepeat;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    repeat = tempRepeat;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            string tempstr;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                tempstr = <span class="built_in">getSubstr</span>(s,i+<span class="number">1</span>,len,rindex);</span><br><span class="line">                i=rindex+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;repeat;j++)&#123;</span><br><span class="line">                fullstr+=tempstr;</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fullstr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>79. Word Search</strong></p>
<p>The naive idea is to go through every cell and use each cell as the start position and then call the dfs, if find a specific path during the call, return the true and do not further do the dfs call. The operation to start the search one by one is a imporatant thinking perspective. We need to confirm the start position anyway.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; m_board;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; m_boardFlag;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m_rowNum;</span><br><span class="line">    <span class="type">int</span> m_colmNum;</span><br><span class="line">    string m_word;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        m_board = board;</span><br><span class="line">        m_word = word;</span><br><span class="line">        m_rowNum = board.<span class="built_in">size</span>();</span><br><span class="line">        m_colmNum = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        m_boardFlag = <span class="built_in">vector</span>(m_rowNum, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m_colmNum,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_rowNum;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m_colmNum;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==word[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="comment">//reset the flag</span></span><br><span class="line">                    m_boardFlag = <span class="built_in">vector</span>(m_rowNum, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m_colmNum,<span class="literal">false</span>));</span><br><span class="line">                    <span class="type">bool</span> find = <span class="built_in">dfs</span>(i,j,<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(find) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//start from r c find adjacent sequence match with word</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> windex)</span></span>&#123;</span><br><span class="line">        <span class="comment">//find the word</span></span><br><span class="line">        <span class="comment">//return</span></span><br><span class="line">        <span class="keyword">if</span>(windex==m_word.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//get out of the bound, return not found</span></span><br><span class="line">        <span class="keyword">if</span>(r&gt;=m_rowNum || r&lt;<span class="number">0</span> || c&gt;=m_colmNum || c&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//this cell is visited</span></span><br><span class="line">        <span class="keyword">if</span>(m_boardFlag[r][c]==<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//we may start to search word from the scratch for this</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment">//check current</span></span><br><span class="line">        <span class="comment">//windex ++ if current is equal</span></span><br><span class="line">        <span class="keyword">if</span>(m_board[r][c]==m_word[windex])&#123;</span><br><span class="line">            <span class="comment">//current one equal word index position</span></span><br><span class="line">            <span class="comment">//check the next</span></span><br><span class="line">            windex++;</span><br><span class="line">            m_boardFlag[r][c] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//right</span></span><br><span class="line">            <span class="type">bool</span> find = <span class="built_in">dfs</span>(r,c+<span class="number">1</span>,windex);</span><br><span class="line">            <span class="keyword">if</span>(find) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//left</span></span><br><span class="line">            find = <span class="built_in">dfs</span>(r,c<span class="number">-1</span>,windex);</span><br><span class="line">            <span class="keyword">if</span>(find) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//up</span></span><br><span class="line">            find = <span class="built_in">dfs</span>(r<span class="number">-1</span>,c,windex);</span><br><span class="line">            <span class="keyword">if</span>(find) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//down</span></span><br><span class="line">            find = <span class="built_in">dfs</span>(r+<span class="number">1</span>,c,windex);</span><br><span class="line">            <span class="keyword">if</span>(find) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//set current back, the current position is not ok</span></span><br><span class="line">            m_boardFlag[r][c] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//if all direaction fail false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                 </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>It is interesting to ask, if it is ok to use the bfs as a kernel to do the path finding. We can not use the bfs for this question, look at this exmaple:<code>[[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;E&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]] &quot;ABCESEEEFS&quot;</code> Since we need to set the label position of the cell to 1 if we put it into the queue, however, in this case, for the correct path, it need to go back to find the node in the higher layer that have been visited. However, these nodes have been visited. So we could not get correct answer anyway. Be careful about using the bfs, it is suitable for the case that there is the abstraction about the shortest path or the distance to the root node. And the node that is visited can not be visited anymore during the path search. If there is a cycle in the graph, it is not suitable to use the bfs.</p>
<p><strong>212. Word Search II</strong></p>
<p>There is time limit excedded issue if we just use the similar ideas compared with previous one, namely reuse the previous code and then add another for loop outside of it, since the list of the words can be really large (3*10^4).</p>
<p>The idea is to use a tire tree to extract the common part of the input list. The direactly using of the tire tree is similar to the auto typing when we search things. The keep point is that we use each edge to represent one of the 26 characters and also label the origianl word (if it exist) at the end of the searching path.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// using the Tire tree</span></span><br><span class="line"><span class="comment">// refer to huahua&#x27;s code for the tire tree</span></span><br><span class="line"><span class="comment">// this data structure saves the actual value</span></span><br><span class="line"><span class="comment">// and use the path to represents the which character it is</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TrieNode*&gt; nodes; <span class="comment">// children for this nodes</span></span><br><span class="line">    string rawWord; <span class="comment">// point to the original word</span></span><br><span class="line">    <span class="built_in">TrieNode</span>():<span class="built_in">nodes</span>(<span class="number">26</span>), <span class="built_in">rawWord</span>(<span class="string">&quot;&quot;</span>) &#123;&#125;; <span class="comment">//the edge represents the letter</span></span><br><span class="line">    ~<span class="built_in">TrieNode</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> node:nodes) <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; m_board;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; m_boardFlag;</span><br><span class="line">    set&lt;string&gt; m_ans;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m_rowNum;</span><br><span class="line">    <span class="type">int</span> m_colNum;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//make sure to fully use the trie tree</span></span><br><span class="line">        <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        TrieNode root;        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//put words into the tree</span></span><br><span class="line">        <span class="comment">//construct the tree</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word:words)&#123;</span><br><span class="line">            <span class="comment">//check each word</span></span><br><span class="line">            <span class="comment">//the root should always be the top level, all words should in same level</span></span><br><span class="line">            TrieNode* cur = &amp;root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c:word)&#123;</span><br><span class="line">                <span class="comment">//printf(&quot;c %c\n&quot;,c);</span></span><br><span class="line">                <span class="comment">//attebtion to this one make sure it is r reference</span></span><br><span class="line">                TrieNode*&amp; next = cur-&gt;nodes[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="comment">//if next is empty, there might be repeated letter in word</span></span><br><span class="line">                <span class="keyword">if</span>(next==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="comment">//printf(&quot;new node %c\n&quot;,c);</span></span><br><span class="line">                    next=<span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//if the cur is at the end of tree</span></span><br><span class="line">            cur -&gt; rawWord = word;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        m_board = board;</span><br><span class="line">        m_rowNum = board.<span class="built_in">size</span>();</span><br><span class="line">        m_colNum = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        m_boardFlag = <span class="built_in">vector</span>(m_rowNum, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m_colNum,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//call the dfs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_rowNum;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m_colNum;j++)&#123;</span><br><span class="line">                <span class="comment">//reset the flag, this is not necessary</span></span><br><span class="line">                <span class="comment">//m_boardFlag = vector(m_rowNum, vector&lt;bool&gt;(m_colNum,false));</span></span><br><span class="line">                <span class="built_in">dfs</span>(i,j,&amp;root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:m_ans)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, TrieNode* root)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check the boundry</span></span><br><span class="line">        <span class="keyword">if</span>(r&gt;=m_rowNum || r&lt;<span class="number">0</span> || c&gt;=m_colNum || c&lt;<span class="number">0</span> || m_boardFlag[r][c]==<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check current node</span></span><br><span class="line">        <span class="type">char</span> curr = m_board[r][c];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//choose specific path to get next node</span></span><br><span class="line">        TrieNode* next = root-&gt;nodes[curr-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if the next is nullptr, the trie root does not </span></span><br><span class="line">        <span class="comment">//contains this character, move to the next</span></span><br><span class="line">        <span class="comment">//current value not exist in the trie tree, there is not match</span></span><br><span class="line">        <span class="keyword">if</span>(next == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//for the subsequent part, current char</span></span><br><span class="line">        <span class="comment">//exist in the trie tree</span></span><br><span class="line">        <span class="comment">//check the current nodes</span></span><br><span class="line">        <span class="comment">//if at the ends of the words</span></span><br><span class="line">        <span class="comment">//printf(&quot;check word %s\n&quot;,next-&gt;rawWord.c_str());</span></span><br><span class="line">        <span class="keyword">if</span>(next-&gt;rawWord!=<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">            <span class="comment">//there is raw word till this stage</span></span><br><span class="line">            m_ans.<span class="built_in">insert</span>(next-&gt;rawWord);   </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//if there is actual word </span></span><br><span class="line">        <span class="comment">//check the whole trie tree</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//process the current node</span></span><br><span class="line">        m_boardFlag[r][c]=<span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//right</span></span><br><span class="line">        <span class="built_in">dfs</span>(r,c+<span class="number">1</span>,next);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//left</span></span><br><span class="line">        <span class="built_in">dfs</span>(r,c<span class="number">-1</span>,next);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//up</span></span><br><span class="line">        <span class="built_in">dfs</span>(r<span class="number">-1</span>,c,next);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//down</span></span><br><span class="line">        <span class="built_in">dfs</span>(r+<span class="number">1</span>,c,next);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//set the flag back</span></span><br><span class="line">        m_boardFlag[r][c]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>In the previous code, there is always repeated answer, so we use a set to store the results, the key issue is here <code>next-&gt;rawWord=&quot;&quot;;</code> If we set the rawWord to empty after visiting it each time, we can save lots of time, this is code that is less than 1000ms</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// using the Tire tree</span></span><br><span class="line"><span class="comment">// refer to huahua&#x27;s code for the tire tree</span></span><br><span class="line"><span class="comment">// this data structure saves the actual value</span></span><br><span class="line"><span class="comment">// and use the path to represents the which character it is</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TrieNode*&gt; nodes; <span class="comment">// children for this nodes</span></span><br><span class="line">    string rawWord; <span class="comment">// point to the original word</span></span><br><span class="line">    <span class="built_in">TrieNode</span>():<span class="built_in">nodes</span>(<span class="number">26</span>), <span class="built_in">rawWord</span>(<span class="string">&quot;&quot;</span>) &#123;&#125;; <span class="comment">//the edge represents the letter</span></span><br><span class="line">    ~<span class="built_in">TrieNode</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> node:nodes) <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; m_board;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; m_boardFlag;</span><br><span class="line">    vector&lt;string&gt; m_ans;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m_rowNum;</span><br><span class="line">    <span class="type">int</span> m_colNum;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//make sure to fully use the trie tree</span></span><br><span class="line">        <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        TrieNode root;        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//put words into the tree</span></span><br><span class="line">        <span class="comment">//construct the tree</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word:words)&#123;</span><br><span class="line">            <span class="comment">//check each word</span></span><br><span class="line">            <span class="comment">//the root should always be the top level, all words should in same level</span></span><br><span class="line">            TrieNode* cur = &amp;root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c:word)&#123;</span><br><span class="line">                <span class="comment">//printf(&quot;c %c\n&quot;,c);</span></span><br><span class="line">                <span class="comment">//attebtion to this one make sure it is r reference</span></span><br><span class="line">                TrieNode*&amp; next = cur-&gt;nodes[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="comment">//if next is empty, there might be repeated letter in word</span></span><br><span class="line">                <span class="keyword">if</span>(next==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="comment">//printf(&quot;new node %c\n&quot;,c);</span></span><br><span class="line">                    next=<span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//if the cur is at the end of tree</span></span><br><span class="line">            cur -&gt; rawWord = word;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        m_board = board;</span><br><span class="line">        m_rowNum = board.<span class="built_in">size</span>();</span><br><span class="line">        m_colNum = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        m_boardFlag = <span class="built_in">vector</span>(m_rowNum, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m_colNum,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//call the dfs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_rowNum;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m_colNum;j++)&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i,j,&amp;root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> m_ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, TrieNode* root)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check the boundry</span></span><br><span class="line">        <span class="keyword">if</span>(r&gt;=m_rowNum || r&lt;<span class="number">0</span> || c&gt;=m_colNum || c&lt;<span class="number">0</span> || m_boardFlag[r][c]==<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check current node</span></span><br><span class="line">        <span class="type">char</span> curr = m_board[r][c];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//choose specific path to get next node</span></span><br><span class="line">        TrieNode* next = root-&gt;nodes[curr-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if the next is nullptr, the trie root does not </span></span><br><span class="line">        <span class="comment">//contains this character, move to the next</span></span><br><span class="line">        <span class="comment">//current value not exist in the trie tree, there is not match</span></span><br><span class="line">        <span class="keyword">if</span>(next == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//for the subsequent part, current char</span></span><br><span class="line">        <span class="comment">//exist in the trie tree</span></span><br><span class="line">        <span class="comment">//check the current nodes</span></span><br><span class="line">        <span class="comment">//if at the ends of the words</span></span><br><span class="line">        <span class="comment">//printf(&quot;check word %s\n&quot;,next-&gt;rawWord.c_str());</span></span><br><span class="line">        <span class="keyword">if</span>(next-&gt;rawWord!=<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">            <span class="comment">//there is raw word till this stage</span></span><br><span class="line">            m_ans.<span class="built_in">push_back</span>(next-&gt;rawWord);</span><br><span class="line">            next-&gt;rawWord=<span class="string">&quot;&quot;</span>;         &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//if there is actual word </span></span><br><span class="line">        <span class="comment">//check the whole trie tree</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//process the current node</span></span><br><span class="line">        m_boardFlag[r][c]=<span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//right</span></span><br><span class="line">        <span class="built_in">dfs</span>(r,c+<span class="number">1</span>,next);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//left</span></span><br><span class="line">        <span class="built_in">dfs</span>(r,c<span class="number">-1</span>,next);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//up</span></span><br><span class="line">        <span class="built_in">dfs</span>(r<span class="number">-1</span>,c,next);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//down</span></span><br><span class="line">        <span class="built_in">dfs</span>(r+<span class="number">1</span>,c,next);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//set the flag back</span></span><br><span class="line">        m_boardFlag[r][c]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="DFS-Partition"><a href="#DFS-Partition" class="headerlink" title="DFS Partition"></a>DFS Partition</h3><p>Partition can be viewd as a extend type of combination, for example, the question 77 can be the foundation to solve the 698. There are two ways to construct tree for this type, assuming there is 3 numbers, a1 a2 a3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root</span><br><span class="line">|   \</span><br><span class="line">a1    null</span><br><span class="line">|   \    |  \</span><br><span class="line">a1a2 a1  a2  null</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>For each layer, we only consider weather ai is operated with previous layer, there are 8 tree nodes, and these 8 tree nodes are all cases.</p>
<p>Another way is to use for loop to construct next layer of the tree, this way is based on question 77, and can save some iterations, which has better speed up than previous one. Assuming the node value is 1 to 4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root</span><br><span class="line">|   \    \   \</span><br><span class="line">1     2   3   4</span><br><span class="line">| | \  \\   \     \ </span><br><span class="line">2 3  4  34  4    null</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>For each time of dividing the subtree, the principle is the start position, for example, at level 0, the start position can be 1 to 4, then at the second level, of 1, the start position is 2 to 4, each path is the potential combination. And we can record the path during the recursion.</p>
<p>By this way, only node start with a1 comes to the deepest layer. The coding in this style is faster than previous one for question 698. </p>
<p><strong>698 Partition to K Equal Sum Subsets</strong></p>
<p>An version with error in it. We assume there are k possible set, and iterate dfs with k iterations. But this is not a complete case, we miss some combinations.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int m_gNum=0;</span><br><span class="line">    int m_gSum=0;</span><br><span class="line">public:</span><br><span class="line">    bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        //nums sum</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //edge cases, not the multipler of k</span><br><span class="line">        if(sum&lt;k || sum % k!=0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        //int slot sum</span><br><span class="line">        m_gSum = sum/k;</span><br><span class="line">        m_gNum = k;</span><br><span class="line">        </span><br><span class="line">        //visited flag</span><br><span class="line">        sort(nums.rbegin(),nums.rend());</span><br><span class="line">        vector&lt;int&gt; visited(nums.size(), 0);</span><br><span class="line">        vector&lt;int&gt; ansIndex; </span><br><span class="line">        for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">            //for each group</span><br><span class="line">            //dfs</span><br><span class="line">            ansIndex.clear();</span><br><span class="line">            //input visited</span><br><span class="line">            for(int j=0;j&lt;visited.size();j++)&#123;</span><br><span class="line">                std::cout &lt;&lt; &quot;visited j &quot; &lt;&lt; visited[j] &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bool iffind = dfs2(nums,visited,0,k,0, ansIndex);</span><br><span class="line">            //label visited elements</span><br><span class="line">            if (iffind==false)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            //go through ans index, set visited as 1</span><br><span class="line">            for (int h=0;h&lt;ansIndex.size();h++)&#123;</span><br><span class="line">                visited[ansIndex[h]]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool dfs2(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; visited, int currSum, int k, int nextIndex, vector&lt;int&gt;&amp;ansIndex)&#123;</span><br><span class="line">        if(currSum==k)&#123;</span><br><span class="line">            //find out one combination</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(nextIndex&gt;=nums.size())&#123;</span><br><span class="line">            //gose to the last element</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(visited[nextIndex]==1)&#123;</span><br><span class="line">            //visited, not add, go to check next one</span><br><span class="line">            return dfs2(nums,visited,currSum,k,nextIndex+1, ansIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int nextVal = nums[nextIndex];</span><br><span class="line"></span><br><span class="line">        //two decisions, add this one</span><br><span class="line">        //push current</span><br><span class="line">        ansIndex.push_back(nextIndex);</span><br><span class="line">        bool leftok = dfs2(nums,visited,currSum+nextVal,k,nextIndex+1,ansIndex);</span><br><span class="line">        //we return either left or right is true</span><br><span class="line">        if(leftok)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ansIndex.pop_back();</span><br><span class="line">            //not add current one, not push </span><br><span class="line">            bool rightok = dfs2(nums,visited,currSum,k,nextIndex+1,ansIndex);</span><br><span class="line">            if (rightok)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //both left and right are false</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>An TLE version, for each layer, we need to check all possibilities.In this version, at each iteration, we go through all possible cases. So the next layer contains all elements. (Be careful about this)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int m_gNum=0;</span><br><span class="line">    int m_gSum=0;</span><br><span class="line">public:</span><br><span class="line">    bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        //nums sum</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //edge cases, not the multipler of k</span><br><span class="line">        if(sum&lt;k || sum % k!=0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        //int slot sum</span><br><span class="line">        m_gSum = sum/k;</span><br><span class="line">        m_gNum = k;</span><br><span class="line">                </span><br><span class="line">        vector&lt;int&gt;visited(nums.size(),0);</span><br><span class="line">        //visited flag</span><br><span class="line">        sort(begin(nums),end(nums),greater&lt;int&gt;());// For avoid extra calculation</span><br><span class="line"></span><br><span class="line">        return dfs3(nums, visited,0,m_gSum,0,m_gNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool dfs3(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; visited, int currSum, int target, int nextIndex, int remainGroup)&#123;</span><br><span class="line">        if(remainGroup==0)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(currSum==target)&#123;</span><br><span class="line">            return dfs3(nums, visited, 0, target, 0, remainGroup-1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(nextIndex&gt;=nums.size()) return false;</span><br><span class="line">        //for all possible values</span><br><span class="line">        for(int i=nextIndex;i&lt;nums.size(); i++)&#123;</span><br><span class="line">            if (visited[i] || currSum + nums[i] &gt; target) continue;</span><br><span class="line">            visited[i]=true;</span><br><span class="line">            bool oktoadd = dfs3(nums,visited,currSum + nums[i],target,i+1,remainGroup);</span><br><span class="line">            if(oktoadd) return true;</span><br><span class="line">            //not ok, do not add current one, try next</span><br><span class="line">            visited[i]=false;</span><br><span class="line">        &#125;</span><br><span class="line">        //not find</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This is based on the original TLE version using dp approach<br>An DFS version with <strong>memorization search</strong> based on map and <strong>bitmask</strong>. The visited array can be the bitmask, which is an integer<br>check this solution.</p>
<p><a target="_blank" rel="noopener" href="https://wangzhezhe.github.io/2023/02/19/algorithm-bit-index/">This blog</a> list associated bitmask operations, using bitmaks is the foundation for memorization since the key in that map is the bitmask of visited flag. The searching time decreases from 2000ms to around 138 after using memorization.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_gNum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m_gSum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//edge cases, not the multipler of k</span></span><br><span class="line">        <span class="keyword">if</span>(sum&lt;k || sum % k!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//sort can improve the speed</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//int slot sum</span></span><br><span class="line">        m_gSum = sum/k;</span><br><span class="line">        m_gNum = k;</span><br><span class="line">                </span><br><span class="line">        <span class="comment">//visited flag</span></span><br><span class="line">        <span class="comment">//vector&lt;int&gt; visited(nums.size(), 0);</span></span><br><span class="line">        <span class="type">int</span> visited=<span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mem;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">rbegin</span>(),nums.<span class="built_in">rend</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums,visited,<span class="number">0</span>,k,<span class="number">0</span>, mem);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span>&amp; visited, <span class="type">int</span> index, <span class="type">int</span> remain, <span class="type">int</span> currSum, unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; mem)</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span>(remain==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(mem.<span class="built_in">count</span>(visited)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> mem[visited];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//the sequence here is important for recursion things, especially for the last rount iteration</span></span><br><span class="line">        <span class="keyword">if</span>(currSum==m_gSum)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(nums,visited,<span class="number">0</span>,remain<span class="number">-1</span>,<span class="number">0</span>, mem);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(index&gt;=nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//if(visited[index]==1)&#123;</span></span><br><span class="line">        <span class="keyword">if</span>(visited&amp;(<span class="number">1</span>&lt;&lt;index))&#123;</span><br><span class="line">            <span class="comment">//there is issue, if it is visited, maybe it we should continue, just jump this one</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(nums, visited, index+<span class="number">1</span>, remain, currSum, mem);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> found = <span class="built_in">dfs</span>(nums, visited, index+<span class="number">1</span>, remain, currSum, mem);</span><br><span class="line">        <span class="keyword">if</span>(found)&#123;</span><br><span class="line">            mem[visited]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;             </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//choose current one       </span></span><br><span class="line">        <span class="type">int</span> tempSum = currSum+nums[index];</span><br><span class="line">        <span class="keyword">if</span>(tempSum&gt;m_gSum)&#123;</span><br><span class="line">            <span class="comment">//not possible to have targeted one</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//visited[index]=1;</span></span><br><span class="line">        visited |= (<span class="number">1</span>&lt;&lt;index);</span><br><span class="line">        found = <span class="built_in">dfs</span>(nums, visited, index+<span class="number">1</span>, remain, tempSum, mem);</span><br><span class="line">        <span class="keyword">if</span>(found) &#123;</span><br><span class="line">            mem[visited]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//visited[index]=0;</span></span><br><span class="line">        visited = visited &amp; ~(<span class="number">1</span> &lt;&lt; index);</span><br><span class="line">        mem[visited]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This is another version which has fewer iterations then previous one (a little bit faster than previous one), for each node, we check the dfs for its subsequent operations </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_gNum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m_gSum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//nums sum</span></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//edge cases, not the multipler of k</span></span><br><span class="line">        <span class="keyword">if</span>(sum&lt;k || sum % k!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="comment">//int slot sum</span></span><br><span class="line">        m_gSum = sum/k;</span><br><span class="line">        m_gNum = k;</span><br><span class="line">                </span><br><span class="line">        <span class="comment">//vector&lt;int&gt;visited(nums.size(),0);</span></span><br><span class="line">        <span class="comment">//visited flag</span></span><br><span class="line">        <span class="type">int</span> visited=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">begin</span>(nums),<span class="built_in">end</span>(nums),<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());<span class="comment">// For avoid extra calculation</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mem;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs3</span>(nums, visited,<span class="number">0</span>,m_gSum,<span class="number">0</span>,m_gNum,mem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs3</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span>&amp; visited, <span class="type">int</span> currSum, <span class="type">int</span> target, <span class="type">int</span> nextIndex, <span class="type">int</span> remainGroup,unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; mem)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remainGroup==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mem.<span class="built_in">count</span>(visited)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> mem[visited];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(currSum==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs3</span>(nums, visited, <span class="number">0</span>, target, <span class="number">0</span>, remainGroup<span class="number">-1</span>,mem);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nextIndex&gt;=nums.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//for all possible values</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=nextIndex;i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((visited&amp;(<span class="number">1</span>&lt;&lt;i)) || currSum + nums[i] &gt; target) <span class="keyword">continue</span>;</span><br><span class="line">            visited |= (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            <span class="type">bool</span> oktoadd = <span class="built_in">dfs3</span>(nums,visited,currSum + nums[i],target,i+<span class="number">1</span>,remainGroup,mem);</span><br><span class="line">            <span class="keyword">if</span>(oktoadd) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                mem[visited]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//not ok, do not add current one, try next</span></span><br><span class="line">            visited = visited &amp; ~(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//not find</span></span><br><span class="line">        mem[visited]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Analysing the time complexity for this question is a little bit tricky. This <a target="_blank" rel="noopener" href="https://leetcode.com/problems/partition-to-k-equal-sum-subsets/solutions/1705743/698-partition-to-k-equal-sum-subsets-via-backtracking/">article</a> is a good analysis.</p>
<p>The template question, print all possible combinations of r elements in a given array of size n: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/combinations/">https://leetcode.com/problems/combinations/</a></p>
<p>The time complexity is <code>O(k*2^n)</code> for each element, we need to consider wheather it is included into the tree. However, there are two ways to construct tree, using the for loop in each layer is more efficient.</p>
<p><strong>93 Restore IP Addresses</strong></p>
<p>This is also a partition type, compared with previous one, this one is hard to use the memorization since it requires to store actual results instead of the true of false. The pattern to select next node is tricky, it use the start position and the length of the substr to do it. This should be a typical pattern for the substr related question.</p>
<p>For each substr, since the maximal length is 3, we can have three slots to put the dots. The maximum dot we can insert is four. Be careful about these details to decide the dfs configurations.</p>
<p>The subroutine to validate the substr is also error prone, there are a lot of details need to take care of.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//edge cases</span></span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//start dfs</span></span><br><span class="line">        vector&lt;string&gt; validSubStrs;</span><br><span class="line">        <span class="comment">//init position, the length of current substr, remain substr</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=<span class="number">3</span>;l++)&#123;</span><br><span class="line">            validSubStrs.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="built_in">dfs</span>(<span class="number">0</span>, l, <span class="number">4</span>, s, validSubStrs, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for a specific substr between two dots</span></span><br><span class="line">    <span class="comment">//if it is a valid integer</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(string substr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//length 0 to 3</span></span><br><span class="line">        <span class="type">int</span> len = substr.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(len&gt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//second position is not 0</span></span><br><span class="line">        <span class="keyword">if</span>(len&gt;=<span class="number">2</span> &amp;&amp; substr[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//does not contain special character</span></span><br><span class="line">        <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(substr[i]&lt;<span class="string">&#x27;0&#x27;</span> || substr[i]&gt;<span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            v=v*<span class="number">10</span>+(substr[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//from 0 to 255</span></span><br><span class="line">        <span class="keyword">if</span>(v&gt;<span class="number">255</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//each node is a integer for specific segment</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> spos, <span class="type">int</span> subslen, <span class="type">int</span> remain, string&amp; s, vector&lt;string&gt;&amp;validSubStrs, vector&lt;string&gt;&amp;ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((spos+subslen) &gt; s.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="comment">//exceeds the limitation</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if valid and the remain is 0 </span></span><br><span class="line">        <span class="comment">//put it into the ans</span></span><br><span class="line">        string substr = s.<span class="built_in">substr</span>(spos,subslen);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">valid</span>(substr)==<span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//current substr is valid</span></span><br><span class="line">        <span class="comment">//remain value decreases one</span></span><br><span class="line">        validSubStrs.<span class="built_in">push_back</span>(substr);</span><br><span class="line">        remain--;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//if already been zero, do not go to next layer further</span></span><br><span class="line">        <span class="keyword">if</span>(remain==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((spos+subslen) &lt; s.<span class="built_in">length</span>())&#123;</span><br><span class="line">                <span class="comment">//not get to the last position even when remain is 0</span></span><br><span class="line">                validSubStrs.<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//organize validSubStrs into a complete string</span></span><br><span class="line">            string ip;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;validSubStrs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    ip=ip+validSubStrs[i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ip=ip+<span class="string">&quot;.&quot;</span>+validSubStrs[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ans.<span class="built_in">push_back</span>(ip);</span><br><span class="line">            <span class="comment">//set status back</span></span><br><span class="line">            validSubStrs.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//if remain is not zero, and current is valid</span></span><br><span class="line">        <span class="comment">//call the dfs for several possible cases at the next layer</span></span><br><span class="line">        <span class="comment">//use len to represent length of next position</span></span><br><span class="line">        <span class="comment">//for next layer, the maximal is three spots for each substr</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=<span class="number">3</span>;l++)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(spos+subslen,l,remain,s,validSubStrs,ans);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//subsequent cases based on current one is completed</span></span><br><span class="line">        validSubStrs.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>131. Palindrome Partitioning</strong></p>
<p>When moving from current root to children, the rule here is the length of the substr, the len of substr can start from 1 to len-start position of substr. The start position of substr is the 0+len of substr. The approach to construct substr is similar to the prevous IP question. We need a subroutine to decide if a specific substr satisfies a specific condition.</p>
<p>For each layer of the tree, each layer represents one possible solution of the substr. For example, if the input string is aabcb, then the first layer is ‘a’,’aa’,’aab’,’aabc’,’aabcb’. (the start position is 0 and the length of substr is 1 to n) Then we will check subsequent partitions. For example, the ‘aab’ is not a valid solution, so we do not move to the next layer for this tree.</p>
<p>For the option ‘a’, it is a valid one, so we can move to the next layer for this tree. which contains ‘a’,’ab’,’abc’,’abcb’, then we will do similar operations and checkings. The maximal depth of the tree in this pattern is the maximal possibilities to do the partition, which is the length of the string for this question.</p>
<p>Be careful about approach to transfer the substring, we use the whole string, start position, length of the substr to do that. That is conveneint to do since the parameter used by <code>substr</code> API of <code>std::string</code> is start position and str length.</p>
<p>This is assocaited code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="comment">//init records</span></span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; solutions;</span><br><span class="line">        vector&lt;string&gt;curr;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,curr,solutions,s);</span><br><span class="line">        <span class="keyword">return</span> solutions;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start, vector&lt;string&gt;&amp;curr, vector&lt;vector&lt;string&gt;&gt;&amp; solutions, string&amp; s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> size = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(start == size)&#123;</span><br><span class="line">            <span class="comment">//there is only one element</span></span><br><span class="line">            solutions.<span class="built_in">push_back</span>(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=s.<span class="built_in">length</span>()-start;len++)&#123;</span><br><span class="line">            <span class="comment">//check current </span></span><br><span class="line">            string substr = s.<span class="built_in">substr</span>(start,len);</span><br><span class="line">            <span class="comment">//trim the branch, this partition not work</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isPlin</span>(substr)==<span class="literal">false</span>) <span class="keyword">continue</span>; </span><br><span class="line">            curr.<span class="built_in">push_back</span>(substr);</span><br><span class="line">            <span class="comment">//continue to construct the curr solution</span></span><br><span class="line">            <span class="built_in">dfs</span>(start+len,curr,solutions,s);</span><br><span class="line">            <span class="comment">//set back status after each iteration</span></span><br><span class="line">            curr.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPlin</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> size = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> j = size<span class="number">-1</span>-i;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=s[j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>241 Different Ways to Add Parentheses</strong></p>
<p>The first thing is to understand question clearly, the output is a list that contains all possible results of equations.</p>
<p>The tree structure is a little bit different for this one. Each node is supposed to be a expression, but the expression can be divided into three types, the expression such as <code>2-1-1</code> the operator such as <code>-</code> or <code>+</code> the node with number, which is the leaf node and can be retured to the root node.</p>
<p>So when we start from root to bottom, assuming the root expression is <code>2-1-1</code>, then then second layer is <code>-</code> and <code>-</code> which are two operators. For the first node <code>-</code> its two subnodes are <code>2</code> and <code>1-1</code>, then we can call same subroutine one these nodes.</p>
<p>Be careful that the return value is not one sigle vale, it is multiple values, which is a vector, for each time we merge results returned from two subtrees, it is a set operation or cartisian products operation for two reuslts.</p>
<p>The conveneint point for this one is that the node is just an expression, which is ensentially a string, which is easy to be set as a key of the map, so this make the memorization search possible for this question.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(string expression)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="comment">//edge cases</span></span><br><span class="line">        <span class="keyword">if</span>(expression.<span class="built_in">length</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//memorization search</span></span><br><span class="line">        unordered_map&lt;string, vector&lt;<span class="type">int</span>&gt;&gt; cache; </span><br><span class="line">        ans = <span class="built_in">dfs</span>(expression,cache);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compute</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">char</span> op)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> a+b;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> a-b;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> a*b;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;false op %c\n&quot;</span>,op);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cartision operation to compute the reuslts of two sets with op</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">setCompute</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; lset, vector&lt;<span class="type">int</span>&gt;&amp; rset, <span class="type">char</span> op)</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> l:lset)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> r:rset)&#123;</span><br><span class="line">                <span class="type">int</span> v = <span class="built_in">compute</span>(l,r,op);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ifleaf</span><span class="params">(string&amp; exp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//the value is from 0 to 99</span></span><br><span class="line">        <span class="keyword">if</span>(exp.<span class="built_in">length</span>()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//from the back to front</span></span><br><span class="line">        <span class="comment">//if there is op return false</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=(exp.<span class="built_in">length</span>()<span class="number">-1</span>);i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(exp[i]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; exp[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dfs</span><span class="params">(string exp, unordered_map&lt;string, vector&lt;<span class="type">int</span>&gt;&gt;&amp;cache)</span></span>&#123;</span><br><span class="line">        <span class="comment">//hit cache return</span></span><br><span class="line">        <span class="keyword">if</span>(cache.<span class="built_in">count</span>(exp)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> cache[exp];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//get to the leaf node, when it contains one number</span></span><br><span class="line">        <span class="comment">//there is only one possible value, return vector with one elemenet</span></span><br><span class="line">        <span class="comment">//insert results into cache</span></span><br><span class="line">        <span class="keyword">if</span>(ifleaf(exp))&#123;</span><br><span class="line">            <span class="type">int</span> v = <span class="built_in">stoi</span>(exp);</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; currset = &#123;v&#125;;</span><br><span class="line">            cache[exp]=currset;</span><br><span class="line">            <span class="keyword">return</span> currset;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//processing expression and divide it into branches</span></span><br><span class="line">        <span class="comment">//check all possible op</span></span><br><span class="line">        <span class="comment">//break down into subtrees</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; currset;</span><br><span class="line">        <span class="comment">//the last digit is the number definately</span></span><br><span class="line">        <span class="comment">//find out the char which is operator, which can be the</span></span><br><span class="line">        <span class="comment">//point to break the string</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(exp.<span class="built_in">length</span>()<span class="number">-1</span>);i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(exp[i]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; exp[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//for the op character</span></span><br><span class="line">            <span class="comment">//get the left exp and right exp</span></span><br><span class="line">            <span class="type">char</span> op = exp[i];            </span><br><span class="line">            <span class="comment">//start to current</span></span><br><span class="line">            string lexp = exp.<span class="built_in">substr</span>(<span class="number">0</span>,i);</span><br><span class="line">            <span class="comment">//next to end</span></span><br><span class="line">            string rexp = exp.<span class="built_in">substr</span>(i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//get left set and right set</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; lset = <span class="built_in">dfs</span>(lexp,cache);</span><br><span class="line">            <span class="comment">//op the left and right</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; rset = <span class="built_in">dfs</span>(rexp,cache);</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tempset =  <span class="built_in">setCompute</span>(lset,rset,op);</span><br><span class="line">            <span class="comment">//merge tempset into currset</span></span><br><span class="line">            currset.<span class="built_in">insert</span>(currset.<span class="built_in">end</span>(), tempset.<span class="built_in">begin</span>(),tempset.<span class="built_in">end</span>());   </span><br><span class="line">            <span class="comment">//do not need to set back status</span></span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="comment">//cache the current ans</span></span><br><span class="line">        cache[exp]=currset;</span><br><span class="line">        <span class="keyword">return</span> currset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>282 Expression Add Operators</strong></p>
<p>This question is a hard one, which is a little bit ticky to solve, but when we consider it by dividing is into several samller questions, it start to getting eaiser. This question is a hard one and it is also an inspiring one, the solution to solve it step by step is a good exercise for solving the hard question. This is a both partition and the combination question.</p>
<p>Compared with the 241, we need to compute the results of this question on the fly since we can not use the divide and conqure approach to solve this question, which has the depedency when there is times operation.</p>
<p>1 output all combinations of potential operatands in string</p>
<p>we just need to use the common type of recursion based on for loop, here, we use comma to express an operator, each time, the length of operator can from the current position to the end of the string, the start position of the previous is the next element of the previous operand. At each level of the recursion tree, we fix one operand, and then we store the path of the tree in the fly into an string.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string InputStr;</span><br><span class="line">    <span class="type">int</span> Target;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">addOperators</span><span class="params">(string num, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        InputStr=num;</span><br><span class="line">        Target=target;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;&quot;</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//index represent the position to extract from inputstr</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> prevOperand, <span class="type">int</span> currValue, string exp, vector&lt;string&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">        <span class="comment">//decide if hit the leaf node and need to return</span></span><br><span class="line">        <span class="keyword">if</span>(index==InputStr.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//get operand and process current</span></span><br><span class="line">        <span class="type">int</span> currOperand=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> oprLen=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;index+oprLen<span class="number">-1</span>&lt;InputStr.<span class="built_in">size</span>();oprLen++)&#123;</span><br><span class="line">            currOperand=currOperand*<span class="number">10</span>+(InputStr[index+oprLen<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="comment">//for each possible operand</span></span><br><span class="line">            std::string expNew = exp;</span><br><span class="line">            <span class="keyword">if</span> (index==<span class="number">0</span>)&#123;</span><br><span class="line">                expNew = expNew+<span class="built_in">to_string</span>(currOperand);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                expNew = expNew+<span class="string">&quot;,&quot;</span>+<span class="built_in">to_string</span>(currOperand);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//go to next layer</span></span><br><span class="line">            <span class="built_in">dfs</span>(index+oprLen,prevOperand,currValue,expNew,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2 compute results of all potential operands output in 1 only using + and -<br>3 only filter out the results that satisfies specific conditions of 2</p>
<p>This is comparatively easy to do based on previous one. Since the + and - is easy to compute on the fly, we do not need to change the value of the previous expression. At the start position of the function, we just return the result when the value equals to specific target. We combine sub-problem 2 and 3 together.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string InputStr;</span><br><span class="line">    <span class="type">int</span> Target;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">addOperators</span><span class="params">(string num, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        InputStr=num;</span><br><span class="line">        Target=target;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;&quot;</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//index represent the position to extract from inputstr</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> prevOperand, <span class="type">int</span> currValue, string exp, vector&lt;string&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">        <span class="comment">//decide if hit the leaf node and need to return</span></span><br><span class="line">        <span class="keyword">if</span>(index==InputStr.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">//moves to invalid position</span></span><br><span class="line">            <span class="keyword">if</span>(currValue==Target)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(exp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//get operand and process current</span></span><br><span class="line">        <span class="type">int</span> currOperand=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> oprLen=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;index+oprLen<span class="number">-1</span>&lt;InputStr.<span class="built_in">size</span>();oprLen++)&#123;</span><br><span class="line">            currOperand=currOperand*<span class="number">10</span>+(InputStr[index+oprLen<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="comment">//std::cout &lt;&lt; currOperand &lt;&lt; std::endl;</span></span><br><span class="line">            <span class="comment">//for each possible operand</span></span><br><span class="line">            std::string expNew;</span><br><span class="line">            <span class="keyword">if</span> (index==<span class="number">0</span>)&#123;</span><br><span class="line">                expNew = exp+<span class="built_in">to_string</span>(currOperand);</span><br><span class="line">                <span class="comment">//go to next layer</span></span><br><span class="line">                <span class="built_in">dfs</span>(index+oprLen,prevOperand,currValue+currOperand,expNew,ans);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//+</span></span><br><span class="line">                expNew = exp+<span class="string">&quot;+&quot;</span>+<span class="built_in">to_string</span>(currOperand);</span><br><span class="line">                <span class="built_in">dfs</span>(index+oprLen,prevOperand,currValue+currOperand,expNew,ans);</span><br><span class="line">                <span class="comment">//-</span></span><br><span class="line">                expNew = exp+<span class="string">&quot;-&quot;</span>+<span class="built_in">to_string</span>(currOperand);</span><br><span class="line">                <span class="built_in">dfs</span>(index+oprLen,prevOperand,currValue-currOperand,expNew,ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>4 expand the type of operators and also consider the operator <code>*</code> based on 3. This one is a little bit tricky, since we need to keep the previous operand when we consider the times operand. For example, if current expression is 1+2, then we get next one <code>*3</code>, we need to update the new value by <code>3-2+2*3</code>, which means using the current value minus the previous operand and then add the operand times the current operand. So it is important to keep track of the previous operand. For the + and -, the previous operand is just the current one. For the <code>*</code> operation, the new previous operand is <code>operand*currValue</code>, we need to view them as a whole portion.</p>
<p>Also be carefule about zero, for the operator start with 0 but there are more than 2 digits, we need to skip it since it is not a valid operator such as <code>05</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string InputStr;</span><br><span class="line">    <span class="type">int</span> Target;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">addOperators</span><span class="params">(string num, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        InputStr=num;</span><br><span class="line">        Target=target;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;&quot;</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//index represent the position to extract from inputstr</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> index, <span class="type">long</span> <span class="type">int</span> prevOperand, <span class="type">long</span> <span class="type">int</span> currValue, string exp, vector&lt;string&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">        <span class="comment">//decide if hit the leaf node and need to return</span></span><br><span class="line">        <span class="keyword">if</span>(index==InputStr.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">//moves to invalid position</span></span><br><span class="line">            <span class="keyword">if</span>(currValue==Target)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(exp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//get operand and process current</span></span><br><span class="line">        <span class="type">long</span> <span class="type">int</span> currOperand=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> oprLen=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;index+oprLen<span class="number">-1</span>&lt;InputStr.<span class="built_in">size</span>();oprLen++)&#123;</span><br><span class="line">            <span class="comment">//if start with 0 and have two digits, not a valid operand, </span></span><br><span class="line">            <span class="comment">//such as case 105</span></span><br><span class="line">            <span class="keyword">if</span>(InputStr[index]==<span class="string">&#x27;0&#x27;</span> &amp;&amp; oprLen&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currOperand=currOperand*<span class="number">10</span>+(InputStr[index+oprLen<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="comment">//std::cout &lt;&lt; currOperand &lt;&lt; std::endl;</span></span><br><span class="line">            <span class="comment">//for each possible operand</span></span><br><span class="line">            std::string expNew;</span><br><span class="line">            <span class="keyword">if</span> (index==<span class="number">0</span>)&#123;</span><br><span class="line">                expNew = exp+<span class="built_in">to_string</span>(currOperand);</span><br><span class="line">                <span class="comment">//go to next layer</span></span><br><span class="line">                <span class="built_in">dfs</span>(index+oprLen,currOperand,currValue+currOperand,expNew,ans);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//+</span></span><br><span class="line">                expNew = exp+<span class="string">&quot;+&quot;</span>+<span class="built_in">to_string</span>(currOperand);</span><br><span class="line">                <span class="built_in">dfs</span>(index+oprLen,currOperand,currValue+currOperand,expNew,ans);</span><br><span class="line">                <span class="comment">//-</span></span><br><span class="line">                expNew = exp+<span class="string">&quot;-&quot;</span>+<span class="built_in">to_string</span>(currOperand);</span><br><span class="line">                <span class="built_in">dfs</span>(index+oprLen,-currOperand,currValue-currOperand,expNew,ans);</span><br><span class="line">                <span class="comment">//*</span></span><br><span class="line">                expNew = exp+<span class="string">&quot;*&quot;</span>+<span class="built_in">to_string</span>(currOperand);</span><br><span class="line">                <span class="type">long</span> <span class="type">int</span> newCurrValue = currValue-prevOperand+prevOperand*currOperand;</span><br><span class="line">                <span class="built_in">dfs</span>(index+oprLen,prevOperand*currOperand,newCurrValue,expNew,ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>5 More optimization. The previous one can make most of results right, but there are some TLE case, the typical memorization is not suitable for this question since we compute the current value on the fly. After checking assocaited <a target="_blank" rel="noopener" href="https://leetcode.com/problems/expression-add-operators/solutions/572099/c-java-python-backtracking-evaluate-on-the-fly-clean-concise/">answer</a>, I founud that the issue is caused by exra string copy, so I save the extra string and make the code more clean, this is the final version:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">addOperators</span><span class="params">(string num, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;&quot;</span>,num,target,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//index represent the position to extract from inputstr</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> index, <span class="type">long</span> <span class="type">int</span> prevOperand, <span class="type">long</span> <span class="type">int</span> currValue, string exp, string&amp; num, <span class="type">int</span>&amp;target, vector&lt;string&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">        <span class="comment">//decide if hit the leaf node and need to return</span></span><br><span class="line">        <span class="keyword">if</span>(index==num.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(currValue==target)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(exp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//get operand and process current</span></span><br><span class="line">        <span class="type">long</span> <span class="type">int</span> currOperand=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> oprLen=<span class="number">1</span>;</span><br><span class="line">        string operandStr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;index+oprLen<span class="number">-1</span>&lt;num.<span class="built_in">size</span>();oprLen++)&#123;</span><br><span class="line">            <span class="comment">//if start with 0 and have two digits, not a valid operand, </span></span><br><span class="line">            <span class="comment">//such as case 105</span></span><br><span class="line">            <span class="keyword">if</span>(num[index]==<span class="string">&#x27;0&#x27;</span> &amp;&amp; oprLen&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currOperand=currOperand*<span class="number">10</span>+(num[index+oprLen<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            operandStr+=num[index+oprLen<span class="number">-1</span>];</span><br><span class="line">            <span class="comment">//for each possible operand</span></span><br><span class="line">            <span class="keyword">if</span> (index==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//go to next layer</span></span><br><span class="line">                <span class="built_in">dfs</span>(index+oprLen,currOperand,currValue+currOperand,exp+operandStr,num,target,ans);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//+</span></span><br><span class="line">                <span class="built_in">dfs</span>(index+oprLen,currOperand,currValue+currOperand,exp+<span class="string">&quot;+&quot;</span>+operandStr,num,target,ans);</span><br><span class="line">                <span class="comment">//-</span></span><br><span class="line">                <span class="built_in">dfs</span>(index+oprLen,-currOperand,currValue-currOperand,exp+<span class="string">&quot;-&quot;</span>+operandStr,num,target,ans);</span><br><span class="line">                <span class="comment">//*</span></span><br><span class="line">                <span class="built_in">dfs</span>(index+oprLen,prevOperand*currOperand,currValue-prevOperand+prevOperand*currOperand,exp+<span class="string">&quot;*&quot;</span>+operandStr,num,target,ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>842. Split Array into Fibonacci Sequence</strong></p>
<p>This solution use the similar pattern of dfs based on partition. For each time of processing the current node, start from the index, and the length of the substr satisfy some constraints.</p>
<p>Be careful about the edge cases for this question such as the upper bound of the number. And the special case to check if the operator is a valid one (the one start with 0 and have more than two digits are invalid, such as 02, 03 are invalid values.)</p>
<p>This one is easy to solve if we can understand the previous one (282)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">splitIntoFibonacci</span><span class="params">(string num)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="comment">//edge case</span></span><br><span class="line">        <span class="keyword">if</span>(num.<span class="built_in">length</span>()&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> path;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,num,path);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">continueRec</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="comment">//less than three number, continue recursion</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;path.<span class="built_in">size</span>()<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//not valid, do not further recursion</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">long</span>(path[i])+<span class="built_in">long</span>(path[i+<span class="number">1</span>])&gt;INT_MAX)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">long</span>(path[i])+<span class="built_in">long</span>(path[i+<span class="number">1</span>])!=<span class="built_in">long</span>(path[i+<span class="number">2</span>]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//index=0, the split position is after 0</span></span><br><span class="line">    <span class="comment">//return value represents find or not</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> index, string&amp; num, vector&lt;<span class="type">int</span>&gt;&amp; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">continueRec</span>(path)==<span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="comment">//this path not valid, do not go further</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if goes to the leaf</span></span><br><span class="line">        <span class="comment">//the path is also valid</span></span><br><span class="line">        <span class="keyword">if</span>(index&gt;=(num.<span class="built_in">length</span>()) &amp;&amp; path.<span class="built_in">size</span>()&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//split current string</span></span><br><span class="line">        <span class="comment">//index to index+len is first, remaining part is second number</span></span><br><span class="line">        <span class="comment">//return any one is ok </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;index+len&lt;=num.<span class="built_in">length</span>();len++)&#123;</span><br><span class="line">            <span class="comment">//process the case that start with zero</span></span><br><span class="line">            <span class="comment">//the output of 01 is 1</span></span><br><span class="line">            <span class="keyword">if</span>(num[index]==<span class="string">&#x27;0&#x27;</span> &amp;&amp; len &gt;<span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">//invalid number </span></span><br><span class="line">            <span class="type">long</span> <span class="type">int</span> currnum = <span class="built_in">stol</span>(num.<span class="built_in">substr</span>(index,len));</span><br><span class="line">            <span class="keyword">if</span>(currnum &gt;= INT_MAX) <span class="keyword">break</span>; <span class="comment">//out of the upper bounud</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(<span class="built_in">int</span>(currnum));</span><br><span class="line"></span><br><span class="line">            <span class="type">bool</span> find=<span class="built_in">dfs</span>(index+len,num,path);</span><br><span class="line">            <span class="keyword">if</span>(find==<span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="comment">//pop back and continue search</span></span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//find one, exit, remember to set return label here</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="BFS-with-level-size-and-visited-flag"><a href="#BFS-with-level-size-and-visited-flag" class="headerlink" title="BFS with level size and visited flag"></a>BFS with level size and visited flag</h3><p>The naive BFS is the basic skills, we put node into the queue, and then pop it gradually, at each time we get a new node from the queue, we then process its children. There are two basic tricks based on it. </p>
<p>One is to get the level size, in this case, before pop out the node, we firstly get the size of the queue, this means the number of node in the current layer, then we use another loop with condition <code>levelSize&gt;0</code>, when nodes in one layer are processed completely, we than do some operation such as dist+1. If we do not use this techniques, we need to store the level value into the node, and each time we get a node from the queue, we access that dist or level value.</p>
<p>Another trick is to set the visited flags, for the question to compute the shortest distance, if we do not add the visited flag, it is possibile to get into the infinity loop. </p>
<p>The question 1091 can be viewed as a template question, it uses several practical skills which are commonly in BFS questions, such as move array, levelsize, and visited flag. These subroutine might be used in more complicated questions such as 675.</p>
<p><strong>1091. Shortest Path in Binary Matrix(A template question)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int r = grid.size();</span><br><span class="line">        int c = grid[0].size();</span><br><span class="line">        //edge cases</span><br><span class="line">        if(grid[0][0]==1 || grid[r-1][c-1]==1) return -1;</span><br><span class="line">        if(r==1 &amp;&amp; c==1 &amp;&amp; grid[0][0]==0) return 1;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; visited(r,vector&lt;int&gt;(c,0));</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; move =&#123;&#123;-1,0&#125;,&#123;-1,-1&#125;,&#123;0,-1&#125;,&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;,&#123;0,1&#125;,&#123;-1,1&#125;&#125;;</span><br><span class="line">        queue&lt;pair&lt;int, int&gt;&gt; q;</span><br><span class="line">        q.push(&#123;0,0&#125;);</span><br><span class="line">        visited[0][0]=1;</span><br><span class="line">        int dist=1;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            //current level size</span><br><span class="line">            int levelSize = q.size();</span><br><span class="line">            while(levelSize&gt;0)&#123;</span><br><span class="line">                //get node</span><br><span class="line">                auto node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                //check children</span><br><span class="line">                for(int i=0;i&lt;8;i++)&#123;</span><br><span class="line">                    int nr = node.first+move[i][0];</span><br><span class="line">                    int nc = node.second+move[i][1];</span><br><span class="line">                    //out of bounuds</span><br><span class="line">                    if(nr&lt;0 || nr &gt;=r || nc &lt;0 || nc &gt;=c )&#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //visited</span><br><span class="line">                    if(visited[nr][nc]==1)&#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //no road</span><br><span class="line">                    if(grid[nr][nc]==1)&#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //go to the dest</span><br><span class="line">                    if(nr==r-1 &amp;&amp; nc==c-1)&#123;</span><br><span class="line">                        return dist+1;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        q.push(&#123;nr,nc&#125;);</span><br><span class="line">                        //visited</span><br><span class="line">                        visited[nr][nc]=1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                levelSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            //ok for one layer</span><br><span class="line">            dist++;</span><br><span class="line">        &#125;</span><br><span class="line">        //no road</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>788 The Maze II(Lintcode)</strong></p>
<p>This is basically the same question with the previous one, the only difference is that the src and dest are also the input parameters.</p>
<p><strong>17 Output all possible combinations.</strong></p>
<p>We basically need to output all the paths, each number represents a new level for each all possible nodes. Essentailly, there is a tree structure and it is good to use the bfs method to search all the tree and only put the results in vector at the last layer. We do not need to put the value in ans at the first several layers and we just need to put the value into the ans at the final layer. The code structure is same with the tree based version, the difference is that the node is not the actual tree node, it is just the imaginary tree node.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;    </span><br><span class="line">        <span class="type">int</span> len = digits.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//init dial table</span></span><br><span class="line">        map&lt;<span class="type">int</span>,vector&lt;string&gt;&gt; dialMap;</span><br><span class="line">        dialMap[<span class="number">2</span>]=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">        dialMap[<span class="number">3</span>]=&#123;<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;f&quot;</span>&#125;;</span><br><span class="line">        dialMap[<span class="number">4</span>]=&#123;<span class="string">&quot;g&quot;</span>,<span class="string">&quot;h&quot;</span>,<span class="string">&quot;i&quot;</span>&#125;;</span><br><span class="line">        dialMap[<span class="number">5</span>]=&#123;<span class="string">&quot;j&quot;</span>,<span class="string">&quot;k&quot;</span>,<span class="string">&quot;l&quot;</span>&#125;;</span><br><span class="line">        dialMap[<span class="number">6</span>]=&#123;<span class="string">&quot;m&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;o&quot;</span>&#125;;</span><br><span class="line">        dialMap[<span class="number">7</span>]=&#123;<span class="string">&quot;p&quot;</span>,<span class="string">&quot;q&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="string">&quot;s&quot;</span>&#125;;</span><br><span class="line">        dialMap[<span class="number">8</span>]=&#123;<span class="string">&quot;t&quot;</span>,<span class="string">&quot;u&quot;</span>,<span class="string">&quot;v&quot;</span>&#125;;</span><br><span class="line">        dialMap[<span class="number">9</span>]=&#123;<span class="string">&quot;w&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;y&quot;</span>,<span class="string">&quot;z&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//init the q</span></span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        <span class="type">int</span> initkey = digits[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:dialMap[initkey])&#123;</span><br><span class="line">            <span class="keyword">if</span>(len&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="comment">//construct all possible results at current layer</span></span><br><span class="line">            <span class="type">int</span> key = digits[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">//fetch the value at i-1 layer</span></span><br><span class="line">            <span class="type">int</span> qsize = q.<span class="built_in">size</span>(); </span><br><span class="line">            <span class="keyword">while</span>(qsize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                string preStr=q.<span class="built_in">front</span>();</span><br><span class="line">                <span class="comment">//put new nodes into the queue</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> v:dialMap[key])&#123;                </span><br><span class="line">                    string currStr = preStr+v;</span><br><span class="line">                    <span class="comment">//put value into the q if i&lt;len-1</span></span><br><span class="line">                    <span class="comment">//put the q value into the ans i ==len-1</span></span><br><span class="line">                    <span class="keyword">if</span>(i&lt;len<span class="number">-1</span>)&#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(currStr);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==(len<span class="number">-1</span>))&#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(currStr);</span><br><span class="line">                    &#125;                  </span><br><span class="line">                &#125;             </span><br><span class="line">                <span class="comment">//pop out old nodes</span></span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                qsize--;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>784. Letter Case Permutation</strong></p>
<p>This is the sample code, the framework is still same with previous one (dfs split the current string into the current part and the remaning part). We just classifiy the type of each elements can consider each operations gradually. the idea is still the recursion based on dfs manner.</p>
<p>The goal of algorithm is to find all the combinations, for each character which is a letter, it can be either a small case or large case, so there are two options for current layer</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCasePermutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        string curr;</span><br><span class="line">        <span class="built_in">dfs</span>(ans, s, curr, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;string&gt;&amp; ans, string&amp;sample, string curr, <span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==sample.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="comment">//all elements are pushed into the curr</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//if not letter, move to next</span></span><br><span class="line">        <span class="type">char</span> temp = sample[index];     </span><br><span class="line">        <span class="keyword">if</span>(temp&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; temp&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//if letter</span></span><br><span class="line">            <span class="comment">//dfs results with the change</span></span><br><span class="line">            <span class="type">char</span> letterNew = temp-<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            string currLower=curr+temp;</span><br><span class="line">            string currUpper=curr+letterNew;</span><br><span class="line">            <span class="built_in">dfs</span>(ans, sample, currLower, index+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(ans, sample, currUpper, index+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; temp&lt;=<span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">char</span> letterNew = temp-<span class="string">&#x27;A&#x27;</span> + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            string currUpper=curr+temp;</span><br><span class="line">            string currLower=curr+letterNew;</span><br><span class="line">            <span class="built_in">dfs</span>(ans, sample, currLower, index+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(ans, sample, currUpper, index+<span class="number">1</span>);            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//not letter</span></span><br><span class="line">            curr=curr+temp;</span><br><span class="line">            <span class="built_in">dfs</span>(ans, sample, curr, index+<span class="number">1</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>126</strong></p>
<p>One key issue here is the defination of the visited flag, how to define it. There are two definations. The first one is that, once the node is checked, we assume it is visited. Another case is that, once the adjacent nodes around current nodes have been checked, we think it is visited. </p>
<p>The 126 is the case that visited nodes is checked out not</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c </span><br><span class="line">  \</span><br><span class="line">a - b</span><br></pre></td></tr></table></figure>

<p>For this case, if a and c are in the queue during the bst search, we then check the b and label b as visited. Then when we pop out the c from the queue, we do not further put the b into the queue, since it has been labeled as visited. In this case, the edge <code>c-&gt;b</code> is not checked. The 127 is a simple case for it. </p>
<p>Another case is check the node after the adjacent nodes is checked. In this case, the operation of setting the flag as true after checking all adjacent nodes. We also list the assocaited code in 127. For the 126 question, this is more suitable solution, since for the one critical nodes, it can be the adjacent node of multiple nodes, so we need to make sure every edge is visited. </p>
<p>In summary, if we need only search the shortest path, we can use the first defination, otherwise, if we need to record all possible path, we need to use the second defination about the visit flags.</p>
<p><strong>127. Word Ladder</strong></p>
<p>The <code>shortest</code> is a kind of key word to remind people to use the BFS. Although we can use dfs (maybe easy for programming), but it is easy to extends the time limit in general cases. If we look at the size of the input list, it is really large, so the dfs is easy to create a really deep recurtion tree.</p>
<p>This is the dfs version, for each time, we go through the list and find one wich is one different with the current one (this is time consuming)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;string&gt; m_wordList;</span><br><span class="line">    string m_beginWord;</span><br><span class="line">    string m_endWord;</span><br><span class="line">    <span class="type">int</span> m_bestPath = INT_MAX; <span class="comment">// do not account the start and the end</span></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; m_flag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">inlist</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> w:m_wordList)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w==m_endWord)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        m_wordList = wordList;</span><br><span class="line">        m_beginWord=beginWord;</span><br><span class="line">        m_endWord=endWord;</span><br><span class="line">        m_flag = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m_wordList.<span class="built_in">size</span>(),<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//make sure the end word is in list</span></span><br><span class="line">        <span class="type">bool</span> ifinlist = <span class="built_in">inlist</span>();</span><br><span class="line">        <span class="keyword">if</span>(ifinlist==<span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(beginWord,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(m_bestPath&gt;<span class="number">0</span> &amp;&amp; m_bestPath!=INT_MAX)&#123;</span><br><span class="line">            <span class="keyword">return</span> m_bestPath+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//function compare 1 letter diff</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">oneDiff</span><span class="params">(<span class="type">const</span> string&amp; str1, <span class="type">const</span> string&amp; str2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//can the str1 and str2 in different length</span></span><br><span class="line">        <span class="type">int</span> len1 = str1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> len2 = str2.<span class="built_in">length</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> lenDiff = <span class="built_in">abs</span>(len1-len2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(lenDiff&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> diff=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">min</span>(len1,len2);i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[i]!=str2[i])&#123;</span><br><span class="line">                diff++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(diff&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((diff+lenDiff)==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string curr, <span class="type">int</span> currPath)</span></span>&#123;</span><br><span class="line">        <span class="comment">//if wordsNum&gt;1</span></span><br><span class="line">        <span class="comment">//current word is one letter diff with endWord</span></span><br><span class="line">        <span class="comment">//return true</span></span><br><span class="line">        <span class="keyword">if</span>(currPath&gt;=<span class="number">1</span> &amp;&amp; curr == m_endWord)&#123;</span><br><span class="line">            m_bestPath = <span class="built_in">min</span>(m_bestPath,currPath);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check all avaliable words</span></span><br><span class="line">        <span class="comment">//this can be very large and up to 3000</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_wordList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m_flag[i])&#123;</span><br><span class="line">                <span class="comment">//this word have been used</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//word is not used</span></span><br><span class="line">            <span class="comment">//check if it is one letter diff with current</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">oneDiff</span>(curr,m_wordList[i]))&#123;</span><br><span class="line">                <span class="comment">//this one is a potential one</span></span><br><span class="line">                m_flag[i]=<span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(m_wordList[i],currPath+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//set flag back after dfs search</span></span><br><span class="line">                m_flag[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The reason that we need to use the visited flag is because there is a graph in the given data structure, we try to use the visited flag to avoid the repeated visit. This visit flag checking is usually happens at the step when we decide if we put the new nodes into the queue.</p>
<p>There are several small places we need to take care of. The idea of the pattern map, which represents the how we move to the next layer. (This idea comes from this <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=h9iTnkgv05E">video</a>). We enssentially use this data structure to construct a graph based on the input data. Understanding this idea is very important, we need to have a logical graph firstly (not the tree in this question) and then use bfs to search the distance.</p>
<ul>
<li><p>When processing status, one case is that when pushing the element into the queue, we label it as visited, another case is that when extract it from the queue, we label it as visited. If we label it as visited when we put things into the queue, otherwise, there is repeated path, we may take actual jumps between the brother nodes in one layer.</p>
</li>
<li><p>The ++ operation should be put at the position when one layer is finished processing instead of when there is new elements is extracted from the pattern.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check if the endword is in the list</span></span><br><span class="line">    <span class="type">bool</span> endExist = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : wordList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (v == endWord) &#123;</span><br><span class="line">        endExist = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (endExist == <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// end not exist</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build the dic (grpah) with the pattern</span></span><br><span class="line">    <span class="comment">// key is pattern, value is assocaited string</span></span><br><span class="line">    <span class="comment">// We can use this info to check the adjacent nodes in the graph each time</span></span><br><span class="line">    unordered_map&lt;string, set&lt;string&gt;&gt; patternMap;</span><br><span class="line">    string pattern;</span><br><span class="line">    wordList.<span class="built_in">push_back</span>(beginWord);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> word : wordList) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        pattern = word;</span><br><span class="line">        pattern[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        patternMap[pattern].<span class="built_in">insert</span>(word);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set&lt;string&gt; visited;</span><br><span class="line">    visited.<span class="built_in">insert</span>(beginWord);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bfs</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    queue&lt;string&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(beginWord);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">empty</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// visit current layer</span></span><br><span class="line">      <span class="comment">// for the new layer</span></span><br><span class="line">      <span class="type">int</span> qsize = q.<span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">while</span> (qsize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// get current</span></span><br><span class="line">        string currw = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        qsize--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check all patterns</span></span><br><span class="line">        <span class="comment">// get to the end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// check words in pattern map</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; currw.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">          pattern = currw;</span><br><span class="line">          pattern[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">auto</span> pattenw : patternMap[pattern]) &#123;</span><br><span class="line">            <span class="comment">//find the adjactent nodes based on the pattern we extracted</span></span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">find</span>(pattenw) == visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">              <span class="comment">// not exist</span></span><br><span class="line">              <span class="comment">// set flag when put things into the queue</span></span><br><span class="line">              <span class="comment">// if the word haved been used, we do not iterate it further</span></span><br><span class="line">              visited.<span class="built_in">insert</span>(pattenw);</span><br><span class="line">              q.<span class="built_in">push</span>(pattenw);</span><br><span class="line">              <span class="keyword">if</span> (pattenw == endWord) &#123;</span><br><span class="line">                <span class="comment">// the first finded one is the shortest one</span></span><br><span class="line">                <span class="comment">// we do not need to iterate all possibilities</span></span><br><span class="line">                <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// finsh processing one layer</span></span><br><span class="line">      res++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// did not get to the res</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This is the version of the code we set the flag after checking all adjacent nodes. There are some major differences compared with previous version</p>
<p>(1) We do not need to set the root node into the queue before bfs</p>
<p>(2) We check the visited status before the bfs checking</p>
<p>(3) We set the flag after checking the all status of the current nodes, the previous one is to check the flag in the for loop when check each status. we also check the flag here, we insert it only if it is not visited.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check if the endword is in the list</span></span><br><span class="line">    <span class="type">bool</span> endExist = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : wordList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (v == endWord) &#123;</span><br><span class="line">        endExist = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (endExist == <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// end not exist</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build the dic with the pattern</span></span><br><span class="line">    unordered_map&lt;string, set&lt;string&gt;&gt; patternMap;</span><br><span class="line">    string pattern;</span><br><span class="line">    wordList.<span class="built_in">push_back</span>(beginWord);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> word : wordList) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        pattern = word;</span><br><span class="line">        pattern[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        patternMap[pattern].<span class="built_in">insert</span>(word);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//only when the nodes are put into the queue, then labeled it as visited</span></span><br><span class="line">    set&lt;string&gt; visited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bfs</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    queue&lt;string&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(beginWord);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">empty</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// visit current layer</span></span><br><span class="line">      <span class="comment">// for the new layer</span></span><br><span class="line">      <span class="type">int</span> qsize = q.<span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">while</span> (qsize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// get current</span></span><br><span class="line">        string currw = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        qsize--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jump the first case</span></span><br><span class="line">        <span class="keyword">if</span>(visited.<span class="built_in">find</span>(currw) != visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">//this one is visited</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;            </span><br><span class="line"></span><br><span class="line">        <span class="comment">// check words in pattern map</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; currw.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">          pattern = currw;</span><br><span class="line">          pattern[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">auto</span> pattenw : patternMap[pattern]) &#123;</span><br><span class="line">              <span class="comment">// not exist</span></span><br><span class="line">              <span class="comment">// set flag when put things into the queue</span></span><br><span class="line">              <span class="comment">// if the word haved been used, we do not iterate it further</span></span><br><span class="line">              <span class="keyword">if</span>(pattenw==currw) <span class="keyword">continue</span>;</span><br><span class="line">              q.<span class="built_in">push</span>(pattenw);</span><br><span class="line">              <span class="keyword">if</span> (pattenw == endWord) &#123;</span><br><span class="line">                <span class="comment">// the first finded one is the shortest one</span></span><br><span class="line">                <span class="comment">// we do not need to iterate all possibilities</span></span><br><span class="line">                <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        visited.<span class="built_in">insert</span>(currw);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// finsh processing one layer</span></span><br><span class="line">      res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// did not get to the res</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>752. Open the Lock</strong></p>
<p>This is the typical bfs + flag question, this will be a typical one and can be solved with the common framework. We use the getAdjacent to get the possible adjacent nodes (<code>2*4</code> possibilities) at each step. All poissible nodes for next layer are stored in an array.</p>
<p>If the new one is the deadends(constrains giving by the question) or the node that have been visited previously. We do not visit them again. </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">getAdjacent</span><span class="params">(string curr, set&lt;string&gt;&amp; visited, set&lt;string&gt;&amp; deadSets)</span></span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            string strnew = curr;</span><br><span class="line">            <span class="comment">//back </span></span><br><span class="line">            <span class="type">char</span> back = curr[i]<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(curr[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                back = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            strnew[i] = back;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//check the deadends</span></span><br><span class="line">            <span class="keyword">if</span>(deadSets.<span class="built_in">find</span>(strnew) == deadSets.<span class="built_in">end</span>() &amp;&amp; visited.<span class="built_in">find</span>(strnew) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="comment">//not exist in dead end</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(strnew);</span><br><span class="line">            &#125;     </span><br><span class="line">                  </span><br><span class="line">            <span class="comment">//forward</span></span><br><span class="line">            <span class="type">char</span> next = curr[i]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(curr[i]==<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                next = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            strnew[i] = next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//check visited, if visited, do not push into the q</span></span><br><span class="line">            <span class="keyword">if</span>(deadSets.<span class="built_in">find</span>(strnew) == deadSets.<span class="built_in">end</span>() &amp;&amp; visited.<span class="built_in">find</span>(strnew) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="comment">//not visited</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(strnew);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">openLock</span><span class="params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//set to store the dead ends</span></span><br><span class="line">        <span class="function">set&lt;string&gt; <span class="title">deadSets</span><span class="params">(deadends.begin(),deadends.end())</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//a flag to label the visited nodes</span></span><br><span class="line">        <span class="comment">//visit flag only represents if the node is visited or not</span></span><br><span class="line">        set&lt;string&gt; visited;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//edge cases</span></span><br><span class="line">        <span class="keyword">if</span>(deadSets.<span class="built_in">find</span>(target)!=deadSets.<span class="built_in">end</span>() || deadSets.<span class="built_in">find</span>(<span class="string">&quot;0000&quot;</span>)!=deadSets.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">//if the target or start is in deadSets</span></span><br><span class="line">            <span class="comment">//could not find anyway</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(target==<span class="string">&quot;0000&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//bfs</span></span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        visited.<span class="built_in">insert</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//for current nodes</span></span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">empty</span>()==<span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="type">int</span> qsize = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(qsize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//get the front one</span></span><br><span class="line">                string curr = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                qsize--;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//compute the all possible adjacent nodes</span></span><br><span class="line">                <span class="comment">//merge the process of getAdjacent and deadSets/visited check </span></span><br><span class="line">                <span class="comment">//can improve the speed</span></span><br><span class="line">                vector&lt;string&gt; adjStrs = <span class="built_in">getAdjacent</span>(curr, deadSets, visited);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> v:adjStrs)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(v==target)&#123;</span><br><span class="line">                        <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//not exist in deadends and not visited</span></span><br><span class="line">                    visited.<span class="built_in">insert</span>(v);</span><br><span class="line">                    <span class="comment">//not the target, push into the queue</span></span><br><span class="line">                    <span class="comment">//printf(&quot;push %s\n&quot;,v.c_str());</span></span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    <span class="comment">//parent[v]=curr;</span></span><br><span class="line">                &#125;<span class="comment">//for all adjacents</span></span><br><span class="line">            &#125;<span class="comment">//while q size</span></span><br><span class="line">            <span class="comment">//update ans for each layer</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;<span class="comment">//while q empty</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//did not find target</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>818. Race Car</strong></p>
<p>The bfs part is similar with previous framework, there are two options for each step. The tricky part is the trimming operation. The nodes number is <code>2^k</code> if we do not do the trimming operation, which make the bfs operation become redoundant quickly. This question also shows another way to use the flag array. We basically code it based on customized way such as <code>pos_speed</code> in this question and put the coded str into the set. </p>
<p>Another strategy for this kind of problem is to use the dp programming. We do not disucss it here, bascially for each position, we need to consider how many possibilities can get to associated position.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//this is an example of customized node</span></span><br><span class="line"><span class="comment">//if we do not use the pair, we can define it by this way</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="built_in">Node</span> (<span class="type">int</span> pos, <span class="type">int</span> speed):<span class="built_in">m_pos</span>(pos),<span class="built_in">m_speed</span>(speed)&#123;&#125;;</span><br><span class="line">    <span class="type">int</span> m_pos;</span><br><span class="line">    <span class="type">int</span> m_speed;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Node&amp; obj) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>-&gt;m_pos &lt; obj.m_pos) || (<span class="keyword">this</span>-&gt;m_speed &lt; obj.m_speed)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">racecar</span><span class="params">(<span class="type">int</span> target)</span> </span>&#123;        </span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">//visited position (still exceeds the limitation)</span></span><br><span class="line">        </span><br><span class="line">        set&lt;string&gt; visited;</span><br><span class="line">        <span class="comment">//serilize the pair</span></span><br><span class="line">        visited.<span class="built_in">insert</span>(<span class="string">&quot;0_1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//bfs</span></span><br><span class="line">        <span class="comment">//the first of pair is pos</span></span><br><span class="line">        <span class="comment">//the second of pair is speed</span></span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">empty</span>()==<span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="comment">//process current layer</span></span><br><span class="line">            <span class="type">int</span> qsize = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(qsize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                qsize--;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//check move case</span></span><br><span class="line">                <span class="comment">//if A move</span></span><br><span class="line">                <span class="type">int</span> np = node.first+node.second;</span><br><span class="line">                <span class="type">int</span> ns = node.second*<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(np==target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//if current is in visited set</span></span><br><span class="line">                <span class="comment">//continue, do not further move it</span></span><br><span class="line">                <span class="function">Node <span class="title">nextA</span><span class="params">(np,ns)</span></span>;</span><br><span class="line">                string nextAKey = <span class="built_in">to_string</span>(np)+<span class="string">&quot;_&quot;</span>+<span class="built_in">to_string</span>(ns);</span><br><span class="line">                    <span class="comment">//if the position is positive, moving to the target is meaningful</span></span><br><span class="line">                    <span class="comment">//the second condition is not sure, we refer huahua&#x27;s code (1.5 is also ok)</span></span><br><span class="line">                    <span class="keyword">if</span>(np &gt; <span class="number">0</span> &amp;&amp; ns&lt; <span class="number">1.5</span>*target)&#123;</span><br><span class="line">                        <span class="comment">//do nothing</span></span><br><span class="line">                        q.<span class="built_in">push</span>(&#123;np,ns&#125;);</span><br><span class="line">                        <span class="comment">//printf(&quot;(%d,%d)\n&quot;,nextA.m_pos,nextA.m_speed);  </span></span><br><span class="line">                &#125;</span><br><span class="line">                  </span><br><span class="line">                <span class="comment">//if R move</span></span><br><span class="line">                <span class="comment">//pos does not change, do not need to check target</span></span><br><span class="line">                np = node.first;</span><br><span class="line">                <span class="keyword">if</span>(node.second&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    ns = <span class="number">-1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ns = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                string nextRKey = <span class="built_in">to_string</span>(np)+<span class="string">&quot;_&quot;</span>+<span class="built_in">to_string</span>(ns);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(visited.<span class="built_in">find</span>(nextRKey)==visited.<span class="built_in">end</span>())&#123;                </span><br><span class="line">                    <span class="comment">//only put the node into the queue if it is not visited</span></span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;np,ns&#125;);</span><br><span class="line">                    visited.<span class="built_in">insert</span>(nextRKey);</span><br><span class="line">                    <span class="comment">//printf(&quot;(%d,%d)\n&quot;,nextR.m_pos,nextR.m_speed);</span></span><br><span class="line">                &#125;</span><br><span class="line">                                </span><br><span class="line">            &#125;<span class="comment">//while current qsize</span></span><br><span class="line">            ans++;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="comment">//while q empty</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//does not find the target</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>542. 01 Matrix</strong></p>
<p>The naive thoughts that call the bfs that use each cell at the start position is easy to exceeds the time. Here we use the multisource bfs. The idea is simple, we just insert all source into the queue, and then start the normal bfs operation. Just assumping there are multiple trees, and if we want to do the bfs at the same time, we just need to put them into the queue. For each layer, the node we processed can be on the different tree, but they are in the same level. We need another metrix to record the distance and we just add 1 if we visit a new node.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_row;</span><br><span class="line">    <span class="type">int</span> m_col;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> X[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> Y[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> x&gt;=<span class="number">0</span> &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; x&lt;m_row &amp;&amp; y&lt;m_col;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat) &#123;</span><br><span class="line">        <span class="comment">//range the matrix</span></span><br><span class="line">        <span class="comment">//for each position</span></span><br><span class="line">        </span><br><span class="line">        m_row=mat.<span class="built_in">size</span>();</span><br><span class="line">        m_col=mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(m_row, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m_col,<span class="number">-1</span>));   </span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m_row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m_col;j++)&#123;</span><br><span class="line">                <span class="comment">//put the case with 0 value into the queue</span></span><br><span class="line">                <span class="keyword">if</span>(mat[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(i,j));</span><br><span class="line">                    ans[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;         </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//start the bfs</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> cr = p.first;</span><br><span class="line">            <span class="type">int</span> cc = p.second;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//do not need to consider layer explicitly</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="type">int</span> nr = cr+X[i];</span><br><span class="line">                <span class="type">int</span> nc = cc+Y[i];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">valid</span>(nr,nc) &amp;&amp; ans[nr][nc]==<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="comment">//start to propagate from the source</span></span><br><span class="line">                    ans[nr][nc]=ans[cr][cc]+<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;nr,nc&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="BFS-DFS"><a href="#BFS-DFS" class="headerlink" title="BFS+DFS"></a>BFS+DFS</h3><p><strong>126. Word Ladder II</strong></p>
<p>Compared with the 127, this question requires us to print out the shortest path in explicit way. For bfs, we only remember the distance and the link between two edges, but it does not keep the whole path. We need to use the dfs to trace the whole path. For each time of checking the adjacent nodes, we put them into a map that store the relationship. The key of the map is the current node, the value of the map is a set to store the parent node of the current one.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">findLadders</span>(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)&#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; pathAns;</span><br><span class="line">    <span class="comment">// check if the endword is in the list</span></span><br><span class="line">    <span class="type">bool</span> endExist = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : wordList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (v == endWord) &#123;</span><br><span class="line">        endExist = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (endExist == <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// end not exist</span></span><br><span class="line">      <span class="keyword">return</span> pathAns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build the dic with the pattern</span></span><br><span class="line">    unordered_map&lt;string, set&lt;string&gt;&gt; patternMap;</span><br><span class="line">    string pattern;</span><br><span class="line">    wordList.<span class="built_in">push_back</span>(beginWord);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> word : wordList) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        pattern = word;</span><br><span class="line">        pattern[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        patternMap[pattern].<span class="built_in">insert</span>(word);</span><br><span class="line">        <span class="comment">// printf(&quot;build graph pattern %s word</span></span><br><span class="line">        <span class="comment">// %s\n&quot;,pattern.c_str(),word.c_str());</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check graph</span></span><br><span class="line">    </span><br><span class="line">    set&lt;string&gt; visited;</span><br><span class="line">    <span class="comment">// bfs</span></span><br><span class="line">    <span class="comment">// key is the current nodes</span></span><br><span class="line">    <span class="comment">// value is the parrent node</span></span><br><span class="line">    unordered_map &lt;string, set&lt;string&gt;&gt; pathRecord;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    queue&lt;string&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(beginWord);</span><br><span class="line">    <span class="type">int</span> bestRes = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">empty</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// visit current layer</span></span><br><span class="line">      <span class="comment">// for the new layer</span></span><br><span class="line">      <span class="comment">// if jump to the wordEnd direactly the res is 1</span></span><br><span class="line">      <span class="type">int</span> qsize = q.<span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">while</span> (qsize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// get current</span></span><br><span class="line">        string currw = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        qsize--;</span><br><span class="line">        <span class="keyword">if</span>(visited.<span class="built_in">find</span>(currw)!=visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">//this node is visited previously</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        visited.<span class="built_in">insert</span>(currw);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//printf(&quot;currw %s remain num %d\n&quot;, currw.c_str(), qsize);</span></span><br><span class="line">        <span class="keyword">if</span> (currw == endWord) &#123;</span><br><span class="line">        	<span class="comment">// the first finded one is the shortest one</span></span><br><span class="line">          <span class="comment">// we do not need to iterate all possibilities</span></span><br><span class="line">          <span class="comment">// update the path once find it</span></span><br><span class="line">          bestRes = <span class="built_in">min</span>(bestRes,res);</span><br><span class="line">          vector&lt;string&gt; path;</span><br><span class="line">          path.<span class="built_in">push_back</span>(endWord);</span><br><span class="line">          <span class="built_in">getPathDfs</span>(endWord,beginWord,path,pathAns,pathRecord,<span class="number">1</span>,bestRes);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// check all patterns</span></span><br><span class="line">        <span class="comment">// get to the end</span></span><br><span class="line">        <span class="comment">// check words in pattern map</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; currw.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">          pattern = currw;</span><br><span class="line">          pattern[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">auto</span> pattenw : patternMap[pattern]) &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;pattern %s pattenw</span></span><br><span class="line">            <span class="comment">// %s\n&quot;,pattern.c_str(),pattenw.c_str());</span></span><br><span class="line">            <span class="comment">//if (pathRecord[pattenw].find(pattenw) == pathRecord[pattenw].end()) &#123;</span></span><br><span class="line">              <span class="keyword">if</span>(visited.<span class="built_in">find</span>(pattenw) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">              q.<span class="built_in">push</span>(pattenw);</span><br><span class="line">              <span class="keyword">if</span>(currw!=pattenw)&#123;</span><br><span class="line">                  <span class="comment">//do not insert self</span></span><br><span class="line">                  <span class="comment">//printf(&quot;insert %s\n&quot;,currw.c_str());</span></span><br><span class="line">                  pathRecord[pattenw].<span class="built_in">insert</span>(currw);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="comment">// after while</span></span><br><span class="line">      <span class="comment">// finsh processing one layer</span></span><br><span class="line">      res++;</span><br><span class="line">      <span class="keyword">if</span>(res&gt;bestRes)&#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pathAns;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">getPathDfs</span><span class="params">(string current, string&amp; beginStr, vector&lt;string&gt;&amp; path, vector&lt;vector&lt;string&gt;&gt;&amp; ans, unordered_map &lt;string, set&lt;string&gt;&gt;&amp; pathRecord, <span class="type">int</span> layer, <span class="type">int</span> bestLayer)</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(layer&gt;bestLayer)&#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(current == beginStr)&#123;</span><br><span class="line">          <span class="comment">//put the path into the results</span></span><br><span class="line">          vector&lt;string&gt; revPath = path;</span><br><span class="line">          <span class="built_in">reverse</span>(revPath.<span class="built_in">begin</span>(),revPath.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">          ans.<span class="built_in">push_back</span>(revPath);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//for current node</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v:pathRecord[current])&#123;</span><br><span class="line">            <span class="comment">//next dfs</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(v);</span><br><span class="line">            <span class="built_in">getPathDfs</span>(v,beginStr,path,ans,pathRecord, layer+<span class="number">1</span>, bestLayer);</span><br><span class="line">            <span class="comment">//set back</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="BFS-sorting"><a href="#BFS-sorting" class="headerlink" title="BFS + sorting"></a>BFS + sorting</h3><p>It is usually the hard question when the BFS is used as a subroutine for the other aproaches. Such as 675, I refer to huahua’s code. The question requires to trim the tree from smallest to tallest is actually a label for sorting. Then we can use bfs as a subroutine to compute the dist for each adjacent two points in sorted array. The visited flag and the levelSize techniques are used here. The sorting operation here is a little bit special one, we use the tree hight as the first element of a tuple, subsequent elements are coordinates, then we use first element as the index to do the sorting. </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cutOffTree</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; forest)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//insert into tuple vector</span></span><br><span class="line">        vector&lt;tuple&lt;<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt;nodeList;</span><br><span class="line">        <span class="comment">//sort tuple vector</span></span><br><span class="line">        <span class="type">int</span> r = forest.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (r==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> c = forest[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;c;j++)&#123;</span><br><span class="line">                <span class="comment">//only push the one that need to cut</span></span><br><span class="line">                <span class="comment">//do not contain the element with 0 and 1</span></span><br><span class="line">                <span class="comment">//the element with 1 do not need to be cut</span></span><br><span class="line">                <span class="keyword">if</span>(forest[i][j]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                    nodeList.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(forest[i][j],i,j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nodeList.<span class="built_in">begin</span>(),nodeList.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> stepCount=<span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> startStep=<span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> si=<span class="number">0</span>,sj=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//bfs comoute dist for each two adjacent node</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nodeList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> ei = <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(nodeList[i]);</span><br><span class="line">            <span class="type">int</span> ej = <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(nodeList[i]);</span><br><span class="line">            <span class="type">int</span> d = <span class="built_in">dist</span>(si,sj,ei,ej,forest);</span><br><span class="line">            <span class="keyword">if</span>(d==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="comment">//no connected path</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stepCount=stepCount+d;</span><br><span class="line">            <span class="comment">//cut the tree at the dest</span></span><br><span class="line">            forest[ei][ej]=<span class="number">1</span>;</span><br><span class="line">            si=ei;</span><br><span class="line">            sj=ej;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stepCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dist</span><span class="params">(<span class="type">int</span> si, <span class="type">int</span> sj, <span class="type">int</span> ei, <span class="type">int</span> ej, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; forest)</span></span>&#123;</span><br><span class="line">        <span class="comment">//range of forsest</span></span><br><span class="line">        <span class="keyword">if</span>(si==ei &amp;&amp; sj==ej) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = forest.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> c = forest[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; move=&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">visited</span>(r, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//dist from start to end</span></span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="comment">//init queue</span></span><br><span class="line">        q.<span class="built_in">push</span>(&#123;si,sj&#125;);</span><br><span class="line">        visited[si][sj]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> dist=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//bfs</span></span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">empty</span>()==<span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="type">int</span> levelSize = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (levelSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//extract node from queue and process node</span></span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                    <span class="type">int</span> nexti=node.first+move[i][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> nextj=node.second+move[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(nexti&gt;=<span class="number">0</span> &amp;&amp; nexti &lt;r &amp;&amp; nextj&gt;=<span class="number">0</span> &amp;&amp; nextj&lt;c)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(forest[nexti][nextj]&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(nexti==ei &amp;&amp; nextj==ej)&#123;</span><br><span class="line">                                <span class="keyword">return</span> dist+<span class="number">1</span>;</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                <span class="keyword">if</span>(visited[nexti][nextj]==<span class="number">0</span>)&#123;</span><br><span class="line">                                    q.<span class="built_in">push</span>(&#123;nexti,nextj&#125;);</span><br><span class="line">                                    visited[nexti][nextj]=<span class="number">1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;                            </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                levelSize=levelSize<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dist=dist+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//not find the path to dest</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Multi-sources-BFS"><a href="#Multi-sources-BFS" class="headerlink" title="Multi sources BFS"></a>Multi sources BFS</h3><p>934 is a little bit complicated in structures, it can be viewed as DFS+Multisources BFS question. The shortest path between two island can be viewed as the sortest path from the set 1 to the set 2. Since the question said there are exactly two islands, so we only need to identify one cluster. The process to identify one cluster is to use the DFS (which is simple in code implementation). We just need to go through each element of the grid, when we find the one that equals to 1, it can be viewed as the start point of one island, then we can use the dfs to iterate the graph and find all elements in this island. After detecting it, we can use the bfs to identify the shortest path from current set to the position that have 1 (the shortest path to another island).</p>
<p>The code is listed as follows, it uses lambda expression to find the first element equals to 1, then using dfs to find all elements of first island (using vector + visited flag is more efficient than using the set). At last, we use the multisource BFS to compute the distance. This is a <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=gkINMhbbIbU">good video</a> to discuss these type of questions </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dir&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> m_r;</span><br><span class="line">    <span class="type">int</span> m_c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findisolated</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; island, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        <span class="comment">//insert current elements</span></span><br><span class="line">        island.<span class="built_in">push_back</span>(&#123;r,c&#125;);</span><br><span class="line">        visited[r][c]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//find the adjacent node in island in recursion way</span></span><br><span class="line">        <span class="comment">//only call recursion when next level is valid</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> nr=r+dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nc=c+dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nr&lt;<span class="number">0</span> || nr&gt;=<span class="keyword">this</span>-&gt;m_r || nc&lt;<span class="number">0</span> || nc&gt;=<span class="keyword">this</span>-&gt;m_c)&#123;<span class="comment">//outof bounuds</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//do not further check if the current node have been checked</span></span><br><span class="line">            <span class="comment">//or using find operation for set island.find&#123;nr,nc&#125;!=island.end()</span></span><br><span class="line">            <span class="keyword">if</span>(visited[nr][nc]==<span class="number">1</span> || grid[nr][nc]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//current node is visited or not belongs to the island</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//when subchild is valid one then recursion</span></span><br><span class="line">            <span class="built_in">findisolated</span>(nr,nc,grid,island,visited);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestBridge</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_r = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_c = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ir,ic;<span class="comment">//start position of first island</span></span><br><span class="line">        <span class="comment">//step1, find the first island</span></span><br><span class="line">        <span class="comment">//using lambda expression to find the first element that is not 0</span></span><br><span class="line">        [&amp;]()&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;m_r;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="keyword">this</span>-&gt;m_c;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                        ir=i;</span><br><span class="line">                        ic=j;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;();</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; island;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">visited</span>(<span class="keyword">this</span>-&gt;m_r, (<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">this</span>-&gt;m_c,<span class="number">0</span>)));</span><br><span class="line">        <span class="built_in">findisolated</span>(ir,ic,grid,island,visited);</span><br><span class="line">        <span class="comment">//step2, multisource bfs to measure dist between two islands</span></span><br><span class="line">        <span class="type">int</span> step = <span class="number">0</span>;      </span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;q;</span><br><span class="line">        <span class="comment">//new visited flag for bfd</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">visitedbfs</span>(<span class="keyword">this</span>-&gt;m_r, (<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">this</span>-&gt;m_c,<span class="number">0</span>)));</span><br><span class="line">        <span class="comment">//put all set number into the set</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:island)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(v);</span><br><span class="line">            visitedbfs[v.first][v.second]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> qsize = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(qsize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//getting elements and poping out one node</span></span><br><span class="line">                <span class="keyword">auto</span> p = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                qsize--;</span><br><span class="line">                <span class="comment">//all adjacents nodes</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                    <span class="type">int</span> nr = p.first+dir[i][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> nc = p.second+dir[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="comment">//out of bounuds</span></span><br><span class="line">                    <span class="keyword">if</span>(nr&lt;<span class="number">0</span> || nr&gt;=<span class="keyword">this</span>-&gt;m_r || nc&lt;<span class="number">0</span> || nc&gt;=<span class="keyword">this</span>-&gt;m_c)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;    </span><br><span class="line">                    <span class="comment">//if curent is visited, we can use the set operation</span></span><br><span class="line">                    <span class="comment">//if(visited.find(&#123;nr,nc&#125;)!=visited.end())&#123;</span></span><br><span class="line">                    <span class="keyword">if</span>(visitedbfs[nr][nc]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//find out the destination (another island)</span></span><br><span class="line">                    <span class="keyword">if</span>(grid[nr][nc]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> step;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//if current is not 1, it is 0, put into the queue</span></span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;nr,nc&#125;);</span><br><span class="line">                    visitedbfs[nr][nc]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//while after processing nodes in current layer</span></span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/06/12/Algorithm-9-Search-BFSDFS/" data-id="clt2e88me00158xjr6ndf0677" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
 
<script src="/jquery/jquery.min.js"></script>

  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2022/06/14/Cuda-programming-1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          Cuda programming (1)
        
      </div>
    </a>
  
  
    <a href="/2022/06/12/Mac-Story/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Mac Story</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Key-techniques-and-considerations"><span class="toc-number">1.</span> <span class="toc-text">Key techniques and considerations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Naive-DFS-UpToBottom-Combination"><span class="toc-number">2.</span> <span class="toc-text">Naive DFS-UpToBottom-Combination</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Naive-DFS-UpToBottom-Permutation"><span class="toc-number">3.</span> <span class="toc-text">Naive DFS-UpToBottom-Permutation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Naive-DFS-UpToBottom-Expression"><span class="toc-number">4.</span> <span class="toc-text">Naive DFS-UpToBottom-Expression</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DFS-Partition"><span class="toc-number">5.</span> <span class="toc-text">DFS Partition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFS-with-level-size-and-visited-flag"><span class="toc-number">6.</span> <span class="toc-text">BFS with level size and visited flag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFS-DFS"><span class="toc-number">7.</span> <span class="toc-text">BFS+DFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFS-sorting"><span class="toc-number">8.</span> <span class="toc-text">BFS + sorting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Multi-sources-BFS"><span class="toc-number">9.</span> <span class="toc-text">Multi sources BFS</span></a></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2024 zhe&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;godenwangzhe@gmail.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  



 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>