<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Algorithm(10) Simulation | AverageMind</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Several questions about the simulation, the typical one is to follow specific rules to go through each element of the matrix.">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithm(10) Simulation">
<meta property="og:url" content="http://yoursite.com/2023/08/03/Algorithm-10-simulation/index.html">
<meta property="og:site_name" content="AverageMind">
<meta property="og:description" content="Several questions about the simulation, the typical one is to follow specific rules to go through each element of the matrix.">
<meta property="og:locale">
<meta property="article:published_time" content="2023-08-03T09:21:58.000Z">
<meta property="article:modified_time" content="2023-12-02T01:21:22.515Z">
<meta property="article:author" content="zhe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="AverageMind" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-165927341-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
<!-- Google adds -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5642436380582343"
     crossorigin="anonymous">
</script>
<!-- End Google adds -->




<script defer src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AverageMind</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Algorithm-10-simulation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/08/03/Algorithm-10-simulation/" class="article-date">
  <time datetime="2023-08-03T09:21:58.000Z" itemprop="datePublished">2023-08-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Algorithm(10) Simulation
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>Several questions about the simulation, the typical one is to follow specific rules to go through each element of the matrix.<br><span id="more"></span></p>
<p>There are several imporant concepts, lets using 885 as an example.</p>
<ul>
<li><p>boundry position, the boundry position can change dynamically during the simulation for each iteration, it labels the min and max value the i and j can be. One simple protocol to change the boundy is that for example, when we use the right boundry, such as move j till the maxC, then after this operation, we then shink the right bounudry. Then we can do similar operations for other boundries. The only difference is that we put the updating of minR bounudy at the beginning of the while iteration, since we input the first element out of the while loop, we execute it one more time.</p>
</li>
<li><p>Wall, the wall position is the outter layer of the grid, be careful about it, when the grid is fixed, the wall is fixed, the boundy can be overlap with the wall. In this case, we might need some special operations, such as not inserting the element into the path.</p>
</li>
<li><p>Do not mix the wall and boundry, they are two different concepts, the wall is fixed and the boundry can change dynamically according to the requirments from of the question.</p>
</li>
<li><p>2d vector for iterating the 4 direaction. In order to make the code simple, the good practice is to maintain a 2d vector to control how the x and y move, this is an exmaple, we just need to go through these 2d vector gradually to control the movement of the current element.</p>
</li>
<li><p>Double check the position of (0,0). In most of the case, we set the upper left position as 0,0 which match with our habit to write a matrix in math, we set the first row as 0, and if we have second row, it is 1. Be careful when we output associated reuslts for visualization, in that case, or in the commonly used coordinates system, the left bottom corner is usualy set as 0,0. Which is a common practice when we set coordinates. So be careful about it when we want to visualize sth. In that case, the first row in the output data might be actually the last row in the original data!!! Be careful about this difference.</p>
<p>Some of these questions can also be considered from perspective of the two pointers. Since x and y are ensentially two index of iterating. Instead of going through every combination of x and y, we just select proper combination of x and y and choose suitable elements.</p>
</li>
<li><p>Another tip is that be careful to decide when to break the loop, we need to check weather go out of the loop after move right or move down. If we do not move down, there is logic error when we move from right to left, this might cause that we insert a repeated element.</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int dirs[][2]&#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;; </span><br></pre></td></tr></table></figure>
<ul>
<li>Another small but tricky techniques is to consider the sequence of move and record and how to use loop to divide it. We might need to consider first or last element separately. Considering this loop while (i&lt;maxC) {record i; i++} the second loop is while (i&lt;maxC) {i++; record i}. The difference is that for first element, in the while loop, the case of i==maxC will not be recorded, we might need to consider last element separately. For the second case, the i==maxC will be recorded, we might need to process first element separately before the while loop. Or we need to update the loop condition for the second case, to let the i&lt;=maxC</li>
</ul>
<h3 id="54-Spiral-Matrix"><a href="#54-Spiral-Matrix" class="headerlink" title="54 Spiral Matrix"></a>54 Spiral Matrix</h3><p>There is a workable solution, but not good, a little bit messy, the special case contains one row and one column.</p>
<p>The core issue is that for some cases, we did not execute all 4 move before exiting</p>
<p>This is the code that consider the move in firstly and then insert, we need to consider some cases before the for loop</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        vector&lt;int&gt; path;</span><br><span class="line">        int rows = matrix.size();</span><br><span class="line">        if (rows==0)&#123;</span><br><span class="line">            return path;</span><br><span class="line">        &#125;</span><br><span class="line">        int cols = matrix[0].size();</span><br><span class="line">        //no wal</span><br><span class="line">        //list bounds</span><br><span class="line">        int minC=0;</span><br><span class="line">        int maxC=cols-1;</span><br><span class="line">        int minR=0;</span><br><span class="line">        int maxR=rows-1;</span><br><span class="line">        </span><br><span class="line">        //start position</span><br><span class="line">        int i=0,j=0;</span><br><span class="line">        path.push_back(matrix[i][j]);</span><br><span class="line"></span><br><span class="line">        //go through matrix</span><br><span class="line">        //do not contain last one</span><br><span class="line">        while(path.size()&lt;(rows*cols))&#123;</span><br><span class="line">            //printf(&quot;---Iteration start\n&quot;);</span><br><span class="line">            </span><br><span class="line">            //minR change at the beginning</span><br><span class="line">            //execute it one more time at fitst iterstion</span><br><span class="line">            //printf(&quot;minC maxC %d %d minR maxR %d %d\n&quot;,minC,maxC,minR,maxR);</span><br><span class="line">            if(maxR&gt;minR) &#123;minR=minR+1;&#125;</span><br><span class="line">            //printf(&quot;AC minC maxC %d %d minR maxR %d %d\n&quot;,minC,maxC,minR,maxR);</span><br><span class="line">            //left to right</span><br><span class="line">            //we might miss to push</span><br><span class="line">            //the element at the boundry in this case</span><br><span class="line">            //printf(&quot;lr\n&quot;);</span><br><span class="line">            while(j&lt;maxC)&#123;</span><br><span class="line">                j++;</span><br><span class="line">                //printf(&quot;i j %d %d v %d\n&quot;,i,j,matrix[i][j]);</span><br><span class="line">                //boundy position will also be added into path</span><br><span class="line">                path.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //for example (0,4) is not push in previous</span><br><span class="line">            //the j is at boundy pos now</span><br><span class="line">            if(path.size()==(rows*cols)) &#123;break;&#125;</span><br><span class="line">            //printf(&quot;minC maxC %d %d minR maxR %d %d\n&quot;,minC,maxC,minR,maxR);</span><br><span class="line">            if(maxC&gt;minC) &#123;maxC=maxC-1;&#125;</span><br><span class="line">            //printf(&quot;AC minC maxC %d %d minR maxR %d %d\n&quot;,minC,maxC,minR,maxR);</span><br><span class="line">            //printf(&quot;ud\n&quot;);</span><br><span class="line">            //up to down</span><br><span class="line">            while(i&lt;maxR)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                //printf(&quot;i j %d %d v %d\n&quot;,i,j,matrix[i][j]);</span><br><span class="line">                path.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //trim one column case</span><br><span class="line">            if(path.size()==(rows*cols)) &#123;break;&#125;</span><br><span class="line"></span><br><span class="line">            // for example i is 2 in first itertaion, (2,3) not push</span><br><span class="line">            //printf(&quot;minC maxC %d %d minR maxR %d %d\n&quot;,minC,maxC,minR,maxR);            </span><br><span class="line">            if(maxR&gt;minR) &#123;maxR=maxR-1;&#125;</span><br><span class="line">            //printf(&quot;AC minC maxC %d %d minR maxR %d %d\n&quot;,minC,maxC,minR,maxR);</span><br><span class="line">            //printf(&quot;rl\n&quot;);</span><br><span class="line">            </span><br><span class="line">            //if the up to down does not move back</span><br><span class="line">            //then this one should not be execute</span><br><span class="line">            //this is one line operation</span><br><span class="line">            //right to left</span><br><span class="line">            while(j&gt;minC)&#123;</span><br><span class="line">                j--;</span><br><span class="line">                //printf(&quot;i j %d %d v %d\n&quot;,i,j,matrix[i][j]);</span><br><span class="line">                path.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            //for example, when j=0, the (2,0) is not pushed now</span><br><span class="line">            //shrink</span><br><span class="line">            //printf(&quot;minC maxC %d %d minR maxR %d %d\n&quot;,minC,maxC,minR,maxR); </span><br><span class="line">            if(maxC&gt;minC) &#123;minC=minC+1;&#125;</span><br><span class="line">            //printf(&quot;AC minC maxC %d %d minR maxR %d %d\n&quot;,minC,maxC,minR,maxR);</span><br><span class="line"></span><br><span class="line">            //printf(&quot;du\n&quot;);</span><br><span class="line">            //printf(&quot;minC maxC %d %d minR maxR %d %d\n&quot;,minC,maxC,minR,maxR);            </span><br><span class="line">            //down to up</span><br><span class="line">            while(i&gt;minR)&#123;</span><br><span class="line">                i--;  </span><br><span class="line">                //printf(&quot;i j %d %d v %d\n&quot;,i,j,matrix[i][j]);</span><br><span class="line">                path.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //push last</span><br><span class="line">        </span><br><span class="line">        //this is for the case when we insert element firstly</span><br><span class="line">        //then consider the boundry, we need to consider last element separately</span><br><span class="line">        //if(path.size()==(rows*cols-1))&#123;</span><br><span class="line">        //    path.push_back(matrix[i][j]);</span><br><span class="line">        //&#125;</span><br><span class="line">        </span><br><span class="line">        return path;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="59-Spiral-Matrix-II"><a href="#59-Spiral-Matrix-II" class="headerlink" title="59 Spiral Matrix II"></a>59 Spiral Matrix II</h3><p>After getting familir with all tips and concepts discussed in this blog, we can solve the code and write workable code really quickly</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;</span><br><span class="line"> </span><br><span class="line">        //reserve matrix</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; output (n,vector&lt;int&gt;(n));</span><br><span class="line"></span><br><span class="line">        //fill in the matrix</span><br><span class="line">        output[0][0]=1;</span><br><span class="line">        int v = 1;</span><br><span class="line"></span><br><span class="line">        //move then record</span><br><span class="line">        int minC=0;</span><br><span class="line">        int maxC=n-1;</span><br><span class="line">        int minR=0;</span><br><span class="line">        int maxR=n-1;</span><br><span class="line">        </span><br><span class="line">        int i=0,j=0;</span><br><span class="line">        while(v&lt;=n*n)&#123;</span><br><span class="line">            //minR +1</span><br><span class="line">            if(maxR&gt;minR) &#123;minR++;&#125;</span><br><span class="line">            //move lr</span><br><span class="line">            while(j&lt;maxC)&#123;</span><br><span class="line">                j++;</span><br><span class="line">                v++;</span><br><span class="line">                output[i][j]=v;</span><br><span class="line">            &#125;</span><br><span class="line">            if(v==n*n) &#123;break;&#125;</span><br><span class="line"></span><br><span class="line">            //maxC -1</span><br><span class="line">            if(maxC&gt;minC)&#123;maxC--;&#125;</span><br><span class="line">            //move u to d</span><br><span class="line">            while(i&lt;maxR)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                v++;</span><br><span class="line">                output[i][j]=v;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(v==n*n) &#123;break;&#125;</span><br><span class="line">            //maxR -1</span><br><span class="line">            if(maxR&gt;minR)&#123;maxR--;&#125;</span><br><span class="line">            </span><br><span class="line">            //move right to left</span><br><span class="line">            while(j&gt;minC)&#123;</span><br><span class="line">                j--;</span><br><span class="line">                v++;</span><br><span class="line">                output[i][j]=v;</span><br><span class="line">            &#125;</span><br><span class="line">            //minC++</span><br><span class="line">            if(maxC&gt;minC)&#123;minC++;&#125;</span><br><span class="line"></span><br><span class="line">            while(i&gt;minR)&#123;</span><br><span class="line">                i--;</span><br><span class="line">                v++;</span><br><span class="line">                output[i][j]=v;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="885-Spiral-Matrix-III"><a href="#885-Spiral-Matrix-III" class="headerlink" title="885 Spiral Matrix III"></a>885 Spiral Matrix III</h3><p>This question is a little bit tricky for the boundry case, the key point is to decide wheather the right up conner belongs to the horizental line or vertical line.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; spiralMatrixIII(int rows, int cols, int rStart, int cStart) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; path;</span><br><span class="line">        int i=rStart;</span><br><span class="line">        int j=cStart;</span><br><span class="line">        //maintain the bounds</span><br><span class="line">        int minR=i,maxR=i;</span><br><span class="line">        int minC=j,maxC=j;</span><br><span class="line">        // wall is C=-1 C=cols</span><br><span class="line">        // wall is R=-1 R=rows</span><br><span class="line">        //push current</span><br><span class="line">        path.push_back(&#123;i,j&#125;);</span><br><span class="line">        while(path.size()&lt;rows*cols)&#123;</span><br><span class="line">            //move right bounds before moving from left to right</span><br><span class="line">            if(maxC&lt;cols)&#123;</span><br><span class="line">                maxC = maxC + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            while(j &lt; maxC)&#123;</span><br><span class="line">                j++;</span><br><span class="line">                //when move to the wall (bounds overlap with wall), do not push</span><br><span class="line">                if(j!=cols &amp;&amp; i!=-1)&#123;path.push_back(&#123;i,j&#125;);&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //when this while loop completes, the j goes to the maxC&#x27;s position</span><br><span class="line"></span><br><span class="line">            //expand bound before moving down</span><br><span class="line">            if(maxR&lt;rows)&#123;</span><br><span class="line">                maxR=maxR+1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //from right up to right down</span><br><span class="line">            while(i&lt;maxR)&#123;</span><br><span class="line">                //move step</span><br><span class="line">                i++;</span><br><span class="line">                if(i!=rows &amp;&amp; j!=cols)&#123; path.push_back(&#123;i,j&#125;);&#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //move left bounds before moving from right to left</span><br><span class="line">            if(minC&gt;=0)&#123;</span><br><span class="line">                minC=minC-1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //from down element to most left</span><br><span class="line">            while(j&gt;minC)&#123;</span><br><span class="line">                j--;</span><br><span class="line">                if(j!=-1 &amp;&amp; i!=rows) &#123;path.push_back(&#123;i,j&#125;);&#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //move left bounds after left to right move</span><br><span class="line">            //Similarly, the boundry can expand till the wall&#x27;s position</span><br><span class="line">            if(minR&gt;=0)&#123;</span><br><span class="line">                minR=minR-1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            while(i&gt;minR)&#123;</span><br><span class="line">                i--;</span><br><span class="line">                if(i!=-1 &amp;&amp; j!=-1)&#123;path.push_back(&#123;i,j&#125;);&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return path;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Another solution is to update metadata firstly and then move, it assumes that the element at the right up corner is the one that need to be pushed through vertival line. Maybe I am more comfortable with this type of coding style. Becareful to only push the element into the path when it is not at the wall. We basically put an ghost region among the matrix. When maxC/maxR and minC/minR go to the ghost region, it does not change further. When pointer goes to the ghost region, it will not be pushed into the path. </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">spiralMatrixIII</span>(<span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">int</span> rStart, <span class="type">int</span> cStart) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; path;</span><br><span class="line">        <span class="type">int</span> i=rStart;</span><br><span class="line">        <span class="type">int</span> j=cStart;</span><br><span class="line">        <span class="comment">//maintain the bounds</span></span><br><span class="line">        <span class="type">int</span> minR=i,maxR=i;</span><br><span class="line">        <span class="type">int</span> minC=j,maxC=j;</span><br><span class="line">        <span class="comment">// wall is C=-1 C=cols</span></span><br><span class="line">        <span class="comment">// wall is R=-1 R=rows</span></span><br><span class="line">        <span class="keyword">while</span>(path.<span class="built_in">size</span>()&lt;rows*cols)&#123;</span><br><span class="line">            <span class="comment">//move right bounds before moving from left to right</span></span><br><span class="line">            <span class="comment">//maxC can overlap with the wall at last iteration</span></span><br><span class="line">            <span class="comment">//left to right</span></span><br><span class="line">            <span class="keyword">if</span>(maxC&lt;cols)&#123;</span><br><span class="line">                maxC = maxC + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; maxC)&#123;</span><br><span class="line">                <span class="comment">//when move to the wall (bounds overlap with wall), do not push</span></span><br><span class="line">                <span class="keyword">if</span>(j!=cols &amp;&amp; j!=<span class="number">-1</span> &amp;&amp; i!=<span class="number">-1</span>)&#123;path.<span class="built_in">push_back</span>(&#123;i,j&#125;);&#125;</span><br><span class="line">                <span class="comment">//move when less than bound</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//when out of while loop, pointer is at right up corner</span></span><br><span class="line">            <span class="comment">//right up element is not in path</span></span><br><span class="line">            <span class="keyword">if</span>(path.<span class="built_in">size</span>()==rows*cols)&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="comment">//up to down</span></span><br><span class="line">            <span class="comment">//expand bound before moving down</span></span><br><span class="line">            <span class="keyword">if</span>(maxR&lt;rows)&#123;</span><br><span class="line">                maxR=maxR<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//from right up to right down</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;maxR)&#123;</span><br><span class="line">                <span class="comment">//move step</span></span><br><span class="line">                <span class="keyword">if</span>(i!=rows &amp;&amp; i!=<span class="number">-1</span> &amp;&amp; j!=cols)&#123; path.<span class="built_in">push_back</span>(&#123;i,j&#125;);&#125;</span><br><span class="line">                <span class="comment">//when i &lt; maxR &lt; row, can ++</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(path.<span class="built_in">size</span>()==rows*cols)&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="comment">//right to left</span></span><br><span class="line">            <span class="keyword">if</span>(minC&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                minC=minC<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//from down element to most left</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;minC)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j!=cols &amp;&amp; j!=<span class="number">-1</span> &amp;&amp; i!=rows) &#123;path.<span class="built_in">push_back</span>(&#123;i,j&#125;);&#125;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//bottom to up</span></span><br><span class="line">            <span class="comment">//move left bounds after left to right move</span></span><br><span class="line">            <span class="comment">//Similarly, the boundry can expand till the wall&#x27;s position</span></span><br><span class="line">            <span class="keyword">if</span>(minR&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                minR=minR<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i&gt;minR)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">-1</span> &amp;&amp; i!= rows &amp;&amp; j!=<span class="number">-1</span>)&#123;path.<span class="built_in">push_back</span>(&#123;i,j&#125;);&#125;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2326-Spiral-Matrix-IV"><a href="#2326-Spiral-Matrix-IV" class="headerlink" title="2326 Spiral Matrix IV"></a>2326 Spiral Matrix IV</h3><p>This can be solved quickly based on previous one, just following the same method and adding a small trick for getting values from the nodelist</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getValue(ListNode*&amp; head)&#123;</span><br><span class="line">        if(head==nullptr)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int v = head-&gt;val;</span><br><span class="line">        //only move to next element</span><br><span class="line">        //when the current is not empty</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; spiralMatrix(int m, int n, ListNode* head) &#123;</span><br><span class="line"></span><br><span class="line">        //specify bounds</span><br><span class="line">        //m row n col</span><br><span class="line">        int minR=0;</span><br><span class="line">        int maxR=m-1;</span><br><span class="line"></span><br><span class="line">        int minC=0;</span><br><span class="line">        int maxC=n-1;</span><br><span class="line">        </span><br><span class="line">        //reserve matrix</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; output (m,vector&lt;int&gt;(n));</span><br><span class="line">        int i=0,j=0;</span><br><span class="line"></span><br><span class="line">        //insert first</span><br><span class="line">        output[0][0]=getValue(head);</span><br><span class="line"></span><br><span class="line">        //number of inserted elements</span><br><span class="line">        int c = 1;</span><br><span class="line">        </span><br><span class="line">        //go through each element of matrix</span><br><span class="line">        while(c&lt;=m*n)&#123;</span><br><span class="line">            //move minR</span><br><span class="line">            if(maxR&gt;minR) &#123;minR++;&#125;</span><br><span class="line">            </span><br><span class="line">            //move l ro r</span><br><span class="line">            while(j&lt;maxC)&#123;</span><br><span class="line">                j++;</span><br><span class="line">                c++;</span><br><span class="line">                output[i][j]=getValue(head);</span><br><span class="line">            &#125;</span><br><span class="line">            if(maxC&gt;minC) &#123;maxC--;&#125;</span><br><span class="line">            if(c==m*n)&#123;break;&#125;</span><br><span class="line"></span><br><span class="line">            //move up to bottom</span><br><span class="line">            while(i&lt;maxR)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                c++;</span><br><span class="line">                output[i][j]=getValue(head);</span><br><span class="line">            &#125;</span><br><span class="line">            if(maxR&gt;minR) &#123;maxR--;&#125;</span><br><span class="line">            if(c==m*n)&#123;break;&#125;</span><br><span class="line"></span><br><span class="line">            //move right to left</span><br><span class="line">            while(j&gt;minC)&#123;</span><br><span class="line">                j--;</span><br><span class="line">                c++;</span><br><span class="line">                output[i][j]=getValue(head);</span><br><span class="line">            &#125;</span><br><span class="line">            if(maxC&gt;minC) &#123;minC++;&#125;</span><br><span class="line"></span><br><span class="line">            //move bottom to up</span><br><span class="line">            while(i&gt;minR)&#123;</span><br><span class="line">                i--;</span><br><span class="line">                c++;</span><br><span class="line">                output[i][j]=getValue(head);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2023/08/03/Algorithm-10-simulation/" data-id="cmbw0e4mt0003xmjrgcio1zen" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
 
<script src="/jquery/jquery.min.js"></script>

  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2023/08/10/clip-threshold-slice/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          Clip, Threshold and Slice
        
      </div>
    </a>
  
  
    <a href="/2023/07/30/Study-taolu/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Study-taolu</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#54-Spiral-Matrix"><span class="toc-number">1.</span> <span class="toc-text">54 Spiral Matrix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59-Spiral-Matrix-II"><span class="toc-number">2.</span> <span class="toc-text">59 Spiral Matrix II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#885-Spiral-Matrix-III"><span class="toc-number">3.</span> <span class="toc-text">885 Spiral Matrix III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2326-Spiral-Matrix-IV"><span class="toc-number">4.</span> <span class="toc-text">2326 Spiral Matrix IV</span></a></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2025 zhe&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;godenwangzhe@gmail.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->




 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>