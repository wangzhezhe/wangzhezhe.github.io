<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Algorithm(11) Binary search | AverageMind</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="The questions related to binary search.">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithm(11) Binary search">
<meta property="og:url" content="http://yoursite.com/2023/10/12/Algorithm-11-Binary-search/index.html">
<meta property="og:site_name" content="AverageMind">
<meta property="og:description" content="The questions related to binary search.">
<meta property="og:locale">
<meta property="article:published_time" content="2023-10-13T01:22:12.000Z">
<meta property="article:modified_time" content="2024-01-01T17:24:51.283Z">
<meta property="article:author" content="zhe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="AverageMind" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-165927341-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
<!-- Google adds -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5642436380582343"
     crossorigin="anonymous">
</script>
<!-- End Google adds -->




<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AverageMind</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Algorithm-11-Binary-search" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/10/12/Algorithm-11-Binary-search/" class="article-date">
  <time datetime="2023-10-13T01:22:12.000Z" itemprop="datePublished">2023-10-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Algorithm(11) Binary search
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>The questions related to binary search.</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>Input data</th>
<th>Basic(unique, exact target, one sorted array)</th>
<th>Multiple sorted subarray(peak,mountain)</th>
<th>Repeated element</th>
<th>Close to the target (two variables)</th>
</tr>
</thead>
<tbody><tr>
<td>SingleNumber</td>
<td>TBD</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Array</td>
<td>35,34,704</td>
<td>33,153,162,852</td>
<td>81,154</td>
<td>69,875,1011,74</td>
</tr>
<tr>
<td>Matrix</td>
<td>74</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Useful tips:</p>
<ul>
<li><p>Divide and conquer (D&amp;C) is not an algorithm but algorithm design paradigm used by Binary search algorithm. The only difference is that in binary search we discard half of the remaining elements at each iteration, whereas in most other D&amp;C problems, we don’t discard any elements. For example, the merging sort is famouse divide and conqure approach, we divede the work space into several small parts and then merge results back. In some dp related question, we can also find this pattern easily. The start point is considering how this problem can be formed by solving a smaller scale problem.</p>
</li>
<li><p>注意使用binary search 的前提，<strong>在有序序列</strong>的基础上，通过binary search可以减少时间复杂度，从O(n)的复杂度降低到O(logn)，一看到O(logn)的复杂度的要求，一个标记就是binary search</p>
</li>
<li><p>The basic thing is to write the binary search template quickly, there are multiple syle, just remember one in mind. in while loop, the comparision is left&lt;&#x3D;right, it is important to add &#x3D; here, since left and right pointer can move to the same position, when they overlap with each other, just return the mid value. There are three cases here</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (left &lt;= right)&#123;</span><br><span class="line">mid = (left + right) / 2;</span><br><span class="line">if (array[mid]==val)&#123;return mid&#125;</span><br><span class="line">else if (array[mid]&lt;val)&#123;left=mid+1&#125;</span><br><span class="line">else //(array[mid]&gt;val)&#123;right=mid-1&#125;</span><br><span class="line">&#125;</span><br><span class="line">return left or not find (the left and right pointer is switched here)</span><br></pre></td></tr></table></figure>

<p>Why this template work: </p>
<p>Assuming the array value equals to their index value. If the left is n, right is n+1, there are three cases: </p>
<p>Case 1, target is n, the value of (l+r)&#x2F;2&#x3D;n is the correct position (namely the n), we can find element. </p>
<p>Case 2, target is n+1, (l+r)&#x2F;2&#x3D;n, mid&lt;target, move left from n to n+1, than (l+r)&#x2F;2 &#x3D; n+1, target is found.</p>
<p>Attention for the Case 3, the template dose not work well in this case. Assuming the target is a value between n and n+1, such as n+0.5, (l+r)&#x2F;2&#x3D;n, the return value is smaller than the target value, left pointer still move from n to n+1, the return value of next time is n+1 which is larger than the target, then the right pointer moves from n+1 to n, then the condition in while loop is broken, left pointer is at value n and right pointer is at value n+1. In this case, when we return the left value, it is the first element that has a value larger than target value. <strong>If we want to approach the target from the left side, we need to return left-1 or just right index in this case when the condition is broken</strong></p>
<ul>
<li>The case where there are multiple array elements having same values. Another typical patten of the binary search framework is to consider the case when there are multiple elements have same value, for example the 378, <strong>it requires us to return leftmost elements when there are multiple elements have same value</strong>, in this case, we need to merge the condition when the element equals to target and smaller than target. When the condition is broken, if the element exists, we can return current L, otherwise, we can reutrn -1, this is a simple example:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int test2(int *array, int len, int t)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int l = 0;</span><br><span class="line">    int h = len - 1;</span><br><span class="line">    while (l &lt;= h)</span><br><span class="line">    &#123;</span><br><span class="line">        int m = (l + h) / 2;</span><br><span class="line">        if (array[m] == t)</span><br><span class="line">        &#123;</span><br><span class="line">            h = m - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (array[m] &lt; t)</span><br><span class="line">        &#123;</span><br><span class="line">            l = m + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            // array[m]&gt;t</span><br><span class="line">            h = m - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //current l is the leftmost elements for subarray with equal values</span><br><span class="line">    //if multiple elements have same value, and we also found it</span><br><span class="line">    if (array[l] == t)</span><br><span class="line">    &#123;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">    // not find</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Be careful about the difference between binary search and “divide and conqure” Binaray search is a kind of special use case of divide and conqure, the thought of divide and conqure can be used widely. The most classic case for the divide and conqure is the merge sort or quick sort. The proof about why binary based approach has log(NLogN) complexity. If we use merge sort as a example, and use F(N) to represent the time complexity, after using divide and conqure, there is F(N) &#x3D; 2F(N&#x2F;2)+KN, the K is a constant, since number since we need to do the merge operation after each divide operation. This is a nature way to write a function in a recursive pattern. If we continue replace the F(N&#x2F;2), there is F(N)&#x3D;2^2F(N&#x2F;(2^2))+2KN, the total layer we can do in a recursive way is logN, so the final results is 2^(logN)F(1)+logN(KN), if the base is 2, the 2^(logN) equals to N, so the final time complexity is O(NlogN). So with the divide and conqure strategy, there is no way to decrease the complexity to a smaller number than N. The difference for the binary search case is to <strong>(1) decrease the scale of the subproblem by comparing it with mid element, (2) besides, there is also some other requirement, such as sorted input array</strong>. In the binary search case, there is F(n)&#x3D;K+F(n&#x2F;2) the K is constant to decide if we need to go to left or right branch (we can do this since array is sorted) Then there is F(n&#x2F;2) &#x3D; K+F(n&#x2F;4), finally, we have F(n) &#x3D; K logN + F(1) There is logN level in total to divide the sequence from N to 1. That is why the complexity can be O(logN), which is different with the divide and conqure scenario for the merging sort which needs to go through both branch in each recursion and there is linear time for each merging operation.</p>
</li>
<li><p>Multiple sorted array is a typical estension in this part, just be careful about the case where there are repeated elements, in this case, just move one element.</p>
</li>
<li><p>For searching the matrix, we need to update the i and j at the same time. The condition is different to the 1d case (l&lt;r)</p>
</li>
</ul>
<h3 id="Recursive-style"><a href="#Recursive-style" class="headerlink" title="Recursive style"></a>Recursive style</h3><p>35 This is the standard binary search question, it can be also written in a form of while loop (since in each iteration, we have a clear idea about move to left or move to right branch), when start position value is larger than end position value, the condition is broken and we can not find the value, we want a position where we can insert it, this is tricky, assuming the current list is [3,5] we want insert 4, the when the start position moves to element 5(index 1), we break the loop, this is also the position we want to insert 4, so we return s in this case.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bsearch</span>(<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>,nums,target);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bsearch</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e, vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="comment">//check edge case</span></span><br><span class="line">        <span class="comment">//the opposit case of s&lt;=e</span></span><br><span class="line">        <span class="keyword">if</span>(s&gt;e)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check middle</span></span><br><span class="line">        <span class="type">int</span> m = (s+e)/<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(target==nums[m])&#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//process current situation</span></span><br><span class="line">        <span class="keyword">if</span>(target&lt;nums[m])&#123;</span><br><span class="line">            <span class="comment">//search left, s to m-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">bsearch</span>(s,m<span class="number">-1</span>,nums,target);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//last case</span></span><br><span class="line">        <span class="comment">//search right, m+1 to e</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bsearch</span>(m+<span class="number">1</span>,e,nums,target);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>34 This question extend the original form of binary search from one branch to the two branch, so it is not conveient use the while loop style program to go through one brach of the tree each time. The basic form to considing this quesiton is as follows: The goal is to find the left end and the right end of the substr. The original two pointer approach is to set a start and end pointer at the each end of the array, then move from the middle if they does not equal with target. When they does not equal, just move, the logic is simple, but this is O(n) time complexity.</p>
<p>For the O(logn) case, we split the whole array into three cases at each iteration, mid element, left part of the middle (from negative infinity to mid-1), right part of the middle (from mid+1 to the positive infinity), for the general case, if the middle equals to the target, then left end and right end of the substr is at the left range and right range, then we just need to write a recursive style algorithm to do similar things. At each iteration, we update left and right when we hit the situation when v[mid] equals target. Be care of the edge case, when position of mid index is out of the range between left to right index, we return it.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int spos=INT_MAX;</span><br><span class="line">    int epos=INT_MIN;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        </span><br><span class="line">        //bsearch</span><br><span class="line">        int s = 0;</span><br><span class="line">        int e = nums.size()-1;</span><br><span class="line">        bsearch(s,e,nums,target);</span><br><span class="line">        </span><br><span class="line">        if(spos==INT_MAX || epos==INT_MIN)&#123;</span><br><span class="line">            //did not find</span><br><span class="line">            return &#123;-1,-1&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; ans = &#123;spos,epos&#125;;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //binary search</span><br><span class="line">    //start pos, end pos</span><br><span class="line">    void bsearch(int s, int e, vector&lt;int&gt;&amp; nums, int&amp; target)&#123;</span><br><span class="line">        //if the end of the tree</span><br><span class="line">        int mid = (s+e)/2;</span><br><span class="line">        if(mid&lt;s || mid &gt;e)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //the opertion in curren node</span><br><span class="line">        if(nums[mid]==target)&#123;</span><br><span class="line">            if(mid&lt;spos) spos = mid;</span><br><span class="line">            if(mid&gt;epos) epos = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        //search left half in dfs manner</span><br><span class="line">        bsearch(s,mid-1,nums,target);</span><br><span class="line">            </span><br><span class="line">        //search right half in dfs manner</span><br><span class="line">        bsearch(mid+1,e,nums,target);</span><br><span class="line">        </span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>704 The idea is similar to previous one, it is easy to come up with a binary search solution based on while loop</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> e=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//the termination condition of searching is s&gt;e</span></span><br><span class="line">        <span class="keyword">while</span>(s&lt;=e)&#123;</span><br><span class="line">            <span class="type">int</span> m = (s+e)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;nums[m])&#123;</span><br><span class="line">                <span class="comment">//search left</span></span><br><span class="line">                e=m<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s=m+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>981 Time Based Key-Value Store The value stored in the map should be sorted according to the timestep, which is tyical binary search use case scenarios. In some online code (huahua’s code), we can use <code>upper_bound</code> function to get the first element in array which is larger than dedicated value. However, we can use a binaray search based subroutine here.</p>
<p>33.Search in Rotated Sorted Array. This question use binary search as a subroutine to process this. We first to find the pivotal element, then search the 0 to p and p to end respectively by binary search to find the target element.<br>The operation to find the pivotal element is tricky, it is actually <strong>the first element in the array that is larger then num[0]</strong>. Just be careful about when to use +1 in the binary search, the edge case can be hard to debug.</p>
<p>One key point is that, for the binary code to find value that equals to target exactly, each binary search, we get three situations, the current element is what we find, or the dedicated element is at the left segment, or the dedicated element is at the right segment. so we use m+1 and m-1 in the next round binary search. For this case, when the  value at current position is larger than num[0], it is still can be the element we want to find, so we keep it in the next round (let h &#x3D; m).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//find pivotal pos p</span></span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> h=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//p is the first one in the second segment</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;h)&#123; </span><br><span class="line">           <span class="comment">//only need to compare with the first elem</span></span><br><span class="line">           <span class="type">int</span> m=(l+h)/<span class="number">2</span>; </span><br><span class="line">           <span class="keyword">if</span>(nums[m]&gt;=nums[<span class="number">0</span>])&#123;</span><br><span class="line">               <span class="comment">//in the left segment</span></span><br><span class="line">               l = m+<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//in the right segment</span></span><br><span class="line">               h = m;</span><br><span class="line">           &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pivotal elem is </span></span><br><span class="line">        <span class="type">int</span> p = l;</span><br><span class="line">        <span class="keyword">if</span>(target&gt;=nums[p] &amp;&amp; target&lt;=nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="comment">//bsearch l to size-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">bsearch</span>(nums,target,p,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//else, search 0 to p</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bsearch</span>(nums,target,<span class="number">0</span>,p<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bsearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target, <span class="type">int</span> l, <span class="type">int</span> h)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=h)&#123;</span><br><span class="line">            <span class="type">int</span> m = (l+h)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;nums[m])&#123;</span><br><span class="line">                <span class="comment">//search left</span></span><br><span class="line">                h=m<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l=m+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>81 Search in Rotated Sorted Array II. For this one, the first step is to find out the pivotal element. Then we can know 0 to p and p+1 to size-1 in the array are sorted, respectively. And we can use the binary serach for searching the target element. Since there is repeated elements in the string, there is no simple way to use binaray search to find the targeted element (such as case [1,1,1,1,5,1,1] the mid element is still 1, we do not know if to move to left or right branch for the next iteration). We just use the linear searching to find the first position where <code>nums[i]&lt;nums[i-1]</code> the nums[i] is the pivotal element.</p>
<p>Actually the 154 can be the first part of this question. However, it is a little bit hard to think all possibilities clearly. (The key is that, it is not always the O(logN)), we can make it O(logN) at best case and O(N) at the worst case. This is still better than O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findFirstDecreasePos</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]==target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">findFirstDecreasePos</span>(nums);</span><br><span class="line">        <span class="comment">//printf(&quot;lower bound index p %d\n&quot;,p);</span></span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//all elements is larger or equal to current one</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">bsearch</span>(nums,target,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span>(target&gt;=nums[p] &amp;&amp; target&lt;=nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="comment">//bsearch start to size-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">bsearch</span>(nums,target,p,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//search 0 to p</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bsearch</span>(nums,target,<span class="number">0</span>,p<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">bsearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target, <span class="type">int</span> l, <span class="type">int</span> h)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> m=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=h)&#123;</span><br><span class="line">            m = (l+h)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[m]&lt;target)&#123;</span><br><span class="line">                l=m+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//&gt;target</span></span><br><span class="line">                h=m<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>153 Find Minimum in Rotated Sorted Array. This is ctually the first part of the question 33 to find the pivotal element. Since the question said the element is unique, we can use binaray search to accelarate the finding procedure. Just using nums[0] as a pivotal element and then we can continue find the pivotal element, which is the start position of the second segment and it is also the minimal element in the array. Be careful about the return value, it should be the l. Since we need to return the first element of the second segment, not the last element of the first segment.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//find pivotal pos p</span></span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> h=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//p is the first one for the second segment</span></span><br><span class="line">        <span class="comment">//p here is the origianl start position</span></span><br><span class="line">        <span class="comment">//which is also index for the minimal value</span></span><br><span class="line">        <span class="keyword">if</span>(nums[h]&gt;nums[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="comment">//normal order</span></span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;h)&#123; </span><br><span class="line">           <span class="comment">//only need to compare with the first elem</span></span><br><span class="line">          p=(h+l)/<span class="number">2</span>; </span><br><span class="line">          <span class="keyword">if</span>(nums[p]&gt;=nums[<span class="number">0</span>])&#123;</span><br><span class="line">               l = p+<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               h = p;</span><br><span class="line">           &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>154 Find Minimum in Rotated Sorted Array II. It is tricky but inspiring to consider all kinds of cases clearly (that is the key points to use the binary search). This <a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/discuss/2344382/Binary-Search-Facebook">answer</a> provides a really good analysis. However, it seems that the code can be simplified based on 153, we just add an specical case to check the situation when there is repeated elements.</p>
<p>During each iteration, there are three cases, (1) when nums[m]&#x3D;&#x3D;nums[r], we do not have clear thought about the minimal element’s position, it can be [1,1,1,5,1,1] or [1,5,1,1,1] so we just decrease r in a linear way. (2) when nums[m]&lt;nums[r], the m position is at the right side of the subarray. If the m is at the left side, there is <code>nums[m]&gt;nums[0]&gt;nums[n-1]</code> (after rotating, we can guarantee there is nums[0]&lt;nums[n-1])  which conflict with condition, so m position is at left side. (3) Similarly, when nums[m]&gt;nums[r], the m’s position is at right side. In this case we only let r&#x3D;m instead of r&#x3D;m-1 since the m can be the position of minimal value exactly.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int l = 0, r = n - 1;     </span><br><span class="line">        while(l &lt; r) &#123;</span><br><span class="line">            int m = (l+r)/2;</span><br><span class="line">            if(nums[m]==nums[r])&#123;</span><br><span class="line">                //duplicated case</span><br><span class="line">                r=r-1;</span><br><span class="line">            &#125;else if(nums[m]&lt;nums[r])&#123;</span><br><span class="line">                r=m;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //nums[m]&gt;nums[r]</span><br><span class="line">                l=m+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //pivotal is l</span><br><span class="line">        return nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>162 Find Peak Element. We have 4 classifications for the middle one, when it is at the peak, at the bottom (just either move l or r), in the ascending part or in the decending part, then we can move l or r make it close to the large end. Be careful with the edge cases a little bit. The condition is made by comparing m with m-1 and m+1, so we need to consider the case when m is at 0 or n-1 position. 852 is a similar version to this one, we do not list detailed solution of 852, they use similar idea to do the classification.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> m=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//edge cases</span></span><br><span class="line">        <span class="keyword">if</span>(r==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//one elements</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[l]&gt;nums[r]?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//moving to the direction </span></span><br><span class="line">        <span class="comment">//where there is larger element</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r &amp;&amp; l&gt;=<span class="number">0</span> &amp;&amp; r&lt;=(nums.<span class="built_in">size</span>()<span class="number">-1</span>))&#123;</span><br><span class="line">            m = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//edge cases</span></span><br><span class="line">            <span class="comment">//we need to consider it since the </span></span><br><span class="line">            <span class="comment">//condition is determined by m m-1 and m+1</span></span><br><span class="line">            <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[m]&gt;nums[m+<span class="number">1</span>]?m:m+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(m==(nums.<span class="built_in">size</span>()<span class="number">-1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[m]&gt;nums[m<span class="number">-1</span>]?m:m<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[m]&gt;nums[m<span class="number">-1</span>] &amp;&amp; nums[m]&gt;nums[m+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//the peak case</span></span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[m]&gt;nums[m<span class="number">-1</span>] &amp;&amp; nums[m]&lt;=nums[m+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//ascending case, move to right</span></span><br><span class="line">                l=m+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[m]&lt;=nums[m<span class="number">-1</span>] &amp;&amp; nums[m]&gt;nums[m+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//descending case, move to left</span></span><br><span class="line">                r=m<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[m]&lt;=nums[m<span class="number">-1</span>] &amp;&amp; nums[m]&lt;=nums[m+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//either moving direaction is ok</span></span><br><span class="line">                l=m+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>852 Peak Index in a Mountain Array. Be careful about this case, the element can be at the minimal position. For other cases, they are similar to the previous one, increasing, decreasing, top of the mountain, at the end of arrays. etc.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assuming the mountain exist</span></span><br><span class="line">        <span class="comment">// and elements is larger than 3</span></span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r=arr.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> m=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            m = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//when there are two elements</span></span><br><span class="line">            <span class="comment">//and m equals to either l or r</span></span><br><span class="line">            <span class="keyword">if</span>(m==l || m==r)&#123;</span><br><span class="line">                <span class="comment">//mountain point is at the start or end position of array</span></span><br><span class="line">                <span class="keyword">return</span> arr[l]&gt;arr[r]?l:r;</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="comment">//when there are more than 2 elements in the range</span></span><br><span class="line">            <span class="keyword">if</span>(arr[m]&gt;arr[m<span class="number">-1</span>] &amp;&amp; arr[m]&gt;arr[m+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//exact mountain point</span></span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[m]&gt;arr[m<span class="number">-1</span>] &amp;&amp; arr[m]&lt;=arr[m+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//increasing order</span></span><br><span class="line">                l=m+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[m]&lt;=arr[m<span class="number">-1</span>] &amp;&amp; arr[m]&gt;arr[m+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//decreasing order</span></span><br><span class="line">                r=m<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[m]&lt;=arr[m<span class="number">-1</span>] &amp;&amp; arr[m]&lt;=arr[m+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//minimal point</span></span><br><span class="line">                l=m+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>69 Sqrt(x) This is the first type of <strong>close to target</strong> question. The condition of this type question is different with previous one to find exact target. If we use previous condition such as l&lt;r, it is hard to tell which one is more close to the target point. For example, when we compute sart(8) in this case, if there is l&lt;r in the condition, the final step of l and r is both 3. If we choose to use l&lt;&#x3D;r, the position of l and r are swithced around the targed elements, so we can find the closer one by return min(l,r), or just return r. Another issue that we need to pay attention is the range of the number (we use long long int for this question), and the edge case, such as when there is 0 and 1 for this question.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r=x;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> m=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span> || x==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            m=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> m2 = m*m;</span><br><span class="line">            <span class="keyword">if</span>(m2==x)&#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(m2&lt;x)&#123;</span><br><span class="line">                l=m+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r=m<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>74 Search a 2D Matrix. This is a simple extension from 1d to 2d, for the 2d case, we need to use two pointer, one is to index the middle position of row, another is to index the middle position of column. Be careful about the pointer case when we move the row index, we need to reset the left and right column index back to 0 and n-1 each time.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> row = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> row_l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> row_r=row<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> col_l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> col_r=col<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row_l&lt;=row_r &amp;&amp; col_l&lt;=col_r)&#123;</span><br><span class="line">            <span class="comment">//searching</span></span><br><span class="line">            <span class="type">int</span> row_m=(row_l+row_r)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> col_m=(col_l+col_r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row_m][col_m]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[row_m][col_m]&gt;target)&#123;</span><br><span class="line">                <span class="comment">//can be same row or different row</span></span><br><span class="line">                <span class="keyword">if</span>(matrix[row_m][<span class="number">0</span>]&lt;=target)&#123;</span><br><span class="line">                    <span class="comment">//same row, move col</span></span><br><span class="line">                    col_r=col_m<span class="number">-1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//different rows</span></span><br><span class="line">                    row_r=row_m<span class="number">-1</span>;</span><br><span class="line">                    <span class="comment">//reset col index</span></span><br><span class="line">                    col_l=<span class="number">0</span>;</span><br><span class="line">                    col_r=col<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//m[row_m][col_m]&lt;target</span></span><br><span class="line">                <span class="keyword">if</span>(matrix[row_m][col<span class="number">-1</span>]&gt;=target)&#123;</span><br><span class="line">                    <span class="comment">//same row, move col</span></span><br><span class="line">                    col_l=col_m+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//different rows</span></span><br><span class="line">                    row_l=row_m+<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//reset col index</span></span><br><span class="line">                    col_l=<span class="number">0</span>;</span><br><span class="line">                    col_r=col<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>875 Koko Eating Bananas. This is also the one to find the value close to the target. The fancy part that in each iteration, when we decide the condition, it is not straightforward comparison between the middle value with the target value, we need to use a function such as <code>canFinish</code> here to decide it. This is a good exmaple to use the binary search to solve problem with interesting background.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles, <span class="type">const</span> <span class="type">int</span> h, <span class="type">const</span> <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> size = piles.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> takeHours=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="type">int</span> currNum=piles[i];</span><br><span class="line">            <span class="type">int</span> currTakeHour=currNum%k==<span class="number">0</span>?currNum/k:(currNum/k)+<span class="number">1</span>;</span><br><span class="line">            takeHours=takeHours+currTakeHour;</span><br><span class="line">            <span class="keyword">if</span>(takeHours&gt;h)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minEatingSpeed</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//range of the k</span></span><br><span class="line">        <span class="keyword">auto</span> result = std::<span class="built_in">max_element</span>(piles.<span class="built_in">begin</span>(), piles.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> kl=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> kr=*result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(kl&lt;=kr)&#123;</span><br><span class="line">            <span class="type">int</span> km=(kl+kr)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">canFinish</span>(piles, h, km))&#123;</span><br><span class="line">                kr=km<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                kl=km+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> kl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1011 TThis is a little bit similar to previous one (875) The interesting part is that although we are given an array, but we actually not use binary search to search that array. That array is just an tool to help us to determine if the current answer is good enough. The good strategy so solve this type of problem is to draw a line that labesl the relatipnship between two variables, we basicaly move a 1d case binary search to a 2d case binary search.</p>
<p>What we need to compare is the number of days we can complete the work. This number has a positive relationship with the size of package. What we can control is the size of package, and what we need to compare is the size of days. We chage package size and find a completion days that close to the one provided by question.</p>
<p>Understanding “no less than” is important, it means closest value of the bag size from right side of the weight axis. Try to draw a 2-d plot the y axis is the days and the x axis is the weight of the package, the line shows an decreasing trend.</p>
<p>Be careful about the start and end position of the weight in this question, the right element should be the sum of all weights.</p>
<p>Another small trick we can learn from this question’s coding is the programming for the for loop. The ensential pattern of the loop is <code>1 do some computation, 2 update some metadata</code> if we consider it logically. such as pattern in this: <code>--|--|--|</code> however, in practial programming, we may use some condition to detect if we need to move the element to the next iteration. <code>--*|--*|...</code> where <code>*</code> represent the condition checking to move to next element. We might forget to update the metadata when exit the loop. The good practice might be to make each for loop indepedent. If we need to introduce some depedency anyway (we can use dummy element or maybe write the sequence of for loop, such as pattern we shoned above before programming), don’t forget to update metadata when exit the for loop, for the last elements, there might some specical case.  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //if the package with w can complete all tasks within d days</span><br><span class="line">    int canFinish(int targetd, int w, const vector&lt;int&gt;&amp; weights)&#123;</span><br><span class="line">        int cd=0;</span><br><span class="line">        int cw=0;</span><br><span class="line">        for(int i=0;i&lt;weights.size();i++)&#123;</span><br><span class="line">            if(w&lt;weights[i])&#123;</span><br><span class="line">                //the bag size too small</span><br><span class="line">                //there is no way to put it into the bag</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if(cw+weights[i]&lt;=w)&#123;</span><br><span class="line">                //cw has enough space to load weights[i]</span><br><span class="line">                cw+=weights[i];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //cw do not have enough space</span><br><span class="line">                //update states for the last time</span><br><span class="line">                cd+=1;</span><br><span class="line">                //return earlier</span><br><span class="line">                if(cd&gt;targetd)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                //reset cw and put current one into the bag</span><br><span class="line">                cw=weights[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //for the last element, we did not +1</span><br><span class="line">        cd=cd+1;</span><br><span class="line">        return cd&lt;=targetd;</span><br><span class="line">    &#125;</span><br><span class="line">    int shipWithinDays(vector&lt;int&gt;&amp; weights, int days) &#123;</span><br><span class="line">        //assuming days &lt; weights length</span><br><span class="line">        //range of w, its size can not be smaller than the min element</span><br><span class="line">        int wl=*std::min_element(weights.begin(), weights.end());</span><br><span class="line">        //the largest one can be sum of all weight</span><br><span class="line">        int wr = std::accumulate(weights.begin(), weights.end(), 0);</span><br><span class="line">        while(wl&lt;=wr)&#123;</span><br><span class="line">            int wm=(wl+wr)/2;</span><br><span class="line">            if(canFinish(days,wm,weights))&#123;</span><br><span class="line">                //try to decrease weight</span><br><span class="line">                //if we can finish the task</span><br><span class="line">                wr=wm-1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                wl=wm+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return wl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4 This is a hard one, just jump this temporarily. The key difficulty is figure out why the midean elements are one of these four elements in two sorted array.<br>Maybe learn from this video:<br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/4397580/99-87-beginner-friendly-video-optimal-solution-explained/">https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/4397580/99-87-beginner-friendly-video-optimal-solution-explained/</a></p>
<p>378</p>
<p>Understand the question: kth smallest element, k starts from 1. It means that for all the element before position of current value v, there are k-1 elements that have value less or equal to the v (Be careful, we include the one with value that equals to v here). This is a function of the original given value, which can be a second variable.</p>
<p>The most tricky part in this question is figure out what is the first variable (searching space that can be used in binary search). It start from the smallest element in the matrix and the end with the last element in the matrix. <strong>The matrix is just a tool used for derive the value of the second variable</strong>. Do not mix this type of problem with 74, they are differet, for 74, the searching space is just that matrix, and the first element in each row is larger than the last one in the previous row. But the matrix in current one is different, there is no guarantee about the relationship between the last element in previous row and first element in the current row.</p>
<p>Another tricky part is that the property of the matrix. It is ascending in row and colum, it means that m[i][j]&lt;m[i][j+1] and m[i][j]&lt;m[i+1][j]. But is does not mean that the last element in previous row less or equals to the first element in the current row.</p>
<p>The logic to find the number of element that is less or equal to the target is not quite straightforward to understand. Assuming 0,0 position is at the top left corner of the matrix. We look at first column, find how many element less or equal to the target one. Then goes to the second column, so on so forth. This is one version of code to go through the matrix to find how many elements are less or equal than dedicated one. We use a for loop plus a while loop. Altough it is simple to understand, it takes me a little while to think it in a clear way.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int countLess(vector&lt;vector&lt;int&gt;&gt;&amp; m, int v)&#123;</span><br><span class="line">    //count how many element in the matrix is less or equals to v</span><br><span class="line">    int n=m.size();</span><br><span class="line">    int i=0;</span><br><span class="line">    int j=0;</span><br><span class="line">    int c=0;</span><br><span class="line">    for(j=0;j&lt;=n-1;j++)&#123;</span><br><span class="line">        while(i&lt;=n-1 &amp;&amp; m[i][j]&lt;=v)&#123;</span><br><span class="line">            c=c+1;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        //set i&#x27;s position back to the first row</span><br><span class="line">        //start checking next column</span><br><span class="line">        i=0;</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using this kernel with the typical framework of binary search, we can find the element that have kth smaller element in the matrix. Be careful about the repeated value.</p>
<p>The last step is to map the middle element back to the element in the matrix. The middle element, L and R value might not exist in the matrix. So we need to find element in the matrix that is cloeset to what we find. There are two cases, when the L &lt;&#x3D; R, it means we need to find first element in the matrix that is equal or larger than m. When the L and R are switched, it means there are a lot of same repeated elements:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[1,1,3,8,13],[4,4,4,8,18],[9,14,18,19,20],[14,19,23,25,25],[18,21,26,28,29]]</span><br><span class="line">k=13</span><br></pre></td></tr></table></figure>
<p>For this case, when m is 17, the ck value is 12, when m is 18 the ck value is 15, but the target is 13. So the L and R are switched at last, the element we need to find within the upper bounud that equals to the L’s value (L and R are switched). This is the compete solution, we use similar strategy to check the matrix and find the element that using L value as its upper bounud.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//the idea is to searching all 2d space and see how many element is less than</span></span><br><span class="line">    <span class="comment">//targeted one</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countLess</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; m, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="comment">//count how many element in the matrix is less or equals to v</span></span><br><span class="line">        <span class="type">int</span> n=m.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=n<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=n<span class="number">-1</span> &amp;&amp; m[i][j]&lt;=v)&#123;</span><br><span class="line">                c=c+<span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//set i&#x27;s position back to the first row</span></span><br><span class="line">            <span class="comment">//start checking next column</span></span><br><span class="line">            i=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//using t as the upper bounud</span></span><br><span class="line">    <span class="comment">//find element in the matrix m that close to t as much as possible</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lessClose</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; m, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n=m.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//init value of v is the smallest element in matrix</span></span><br><span class="line">        <span class="type">int</span> v=m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=n<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=n<span class="number">-1</span> &amp;&amp; m[i][j]&lt;=t)&#123;</span><br><span class="line">                <span class="comment">//store the largest one</span></span><br><span class="line">                v=<span class="built_in">max</span>(v,m[i][j]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//find the one that is larger than m, break</span></span><br><span class="line">            <span class="comment">//rest i to zero</span></span><br><span class="line">            i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(v==t)&#123;</span><br><span class="line">                <span class="comment">//we have found the t value </span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> L=matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> R=matrix[n<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        <span class="keyword">while</span>(L&lt;=R)&#123;</span><br><span class="line">            m = (L+R)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> ck = <span class="built_in">countLess</span>(matrix, m);</span><br><span class="line">            <span class="comment">//printf(&quot;debug L %d R %d m %d ck %d\n&quot;,L,R,m,ck);</span></span><br><span class="line">            <span class="keyword">if</span>(ck==k)&#123;</span><br><span class="line">                <span class="comment">//keep the m</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ck&lt;k)&#123;</span><br><span class="line">                L=m+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//ck&gt;k</span></span><br><span class="line">                R=m<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=R)&#123;</span><br><span class="line">            <span class="comment">//go through matrix find value close to m</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lessClose</span>(matrix,m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//L and R are switched, using L as the upper bounud</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">lessClose</span>(matrix,L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>668</p>
<p>719</p>
<p>786</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2023/10/12/Algorithm-11-Binary-search/" data-id="clrc9gx550004lxjr9ys169b8" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
 
<script src="/jquery/jquery.min.js"></script>

  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2023/10/14/Thoughts-about-computing-history-musem-and-ECP/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          Thoughts about computing history musem and ECP
        
      </div>
    </a>
  
  
    <a href="/2023/10/04/common-mathmetical-operations-and-python-examples/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Common mathmetical operations and python examples</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Recursive-style"><span class="toc-number">1.</span> <span class="toc-text">Recursive style</span></a></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2024 zhe&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;godenwangzhe@gmail.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  



 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>